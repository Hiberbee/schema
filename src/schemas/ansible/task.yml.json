{
   "description": "Auto-Generated JSON Schema for Ansible-stable 2.9 (https://github.com/shaded-enmity/ansible-schema-generator)",
   "title": "Ansible 2.9",
   "$schema": "http://json-schema.org/draft-04/schema#",
   "type": "array",
   "items": {
      "anyOf": [
         {
            "name": {
               "type": "string"
            },
            "include_vars": {
               "type": "string"
            },
            "properties": {
               "file": {
                  "type": "string",
                  "description": "The file name from which variables should be loaded.\nIf the path is relative, it will look for the file in vars/ subdirectory of a role or relative to playbook."
               },
               "dir": {
                  "type": "string",
                  "description": "The directory name from which the variables should be loaded.\nIf the path is relative and the task is inside a role, it will look inside the role's vars/ subdirectory.\nIf the path is relative and not inside a role, it will be parsed relative to the playbook."
               },
               "name": {
                  "type": "string",
                  "description": "The name of a variable into which assign the included vars.\nIf omitted (null) they will be made top level vars."
               },
               "depth": {
                  "$ref": "#/definitions/ansible_number",
                  "description": "When using C(dir), this module will, by default, recursively go through each sub directory and load up the variables. By explicitly setting the depth, this module will only go as deep as the depth."
               },
               "files_matching": {
                  "type": "string",
                  "description": "Limit the files that are loaded within any directory to this regular expression."
               },
               "ignore_files": {
                  "type": "array",
                  "description": "List of file names to ignore."
               },
               "extensions": {
                  "type": "array",
                  "description": "Default: ['json', 'yaml', 'yml']\n\nList of file extensions to read when using C(dir)."
               },
               "ignore_unknown_extensions": {
                  "$ref": "#/definitions/ansible_truth",
                  "description": "Ignore unknown file extensions within the directory.\nThis allows users to specify a directory containing vars files that are intermingled with non-vars files extension types (e.g. a directory with a README in it and vars files)."
               }
            },
            "required": [
               "include_vars"
            ]
         },
         {
            "name": {
               "type": "string"
            },
            "include_tasks": {
               "type": "string"
            },
            "properties": {
               "file": {
                  "type": "string",
                  "description": "The name of the imported file is specified directly without any other option.\nUnlike M(import_tasks), most keywords, including loop, with_items, and conditionals, apply to this statement.\nThe do until loop is not supported on M(include_tasks)."
               },
               "apply": {
                  "type": "string",
                  "description": "Accepts a hash of task keywords (e.g. C(tags), C(become)) that will be applied to the tasks within the include."
               }
            },
            "required": [
               "include_tasks"
            ]
         },
         {
            "name": {
               "type": "string"
            },
            "include": {
               "type": "string"
            },
            "properties": {},
            "required": [
               "include"
            ]
         },
         {
            "name": {
               "type": "string"
            },
            "import_tasks": {
               "type": "string"
            },
            "properties": {},
            "required": [
               "import_tasks"
            ]
         },
         {
            "name": {
               "type": "string"
            },
            "import_playbook": {
               "type": "string"
            },
            "properties": {},
            "required": [
               "import_playbook"
            ]
         },
         {
            "type": "object",
            "properties": {
               "name": {
                  "type": "string"
               },
               "args": {
                  "type": "object",
                  "properties": {
                     "cmd": {
                        "type": "string",
                        "description": "The command to run followed by optional arguments."
                     },
                     "creates": {
                        "type": "string",
                        "description": "A filename, when it already exists, this step will B(not) be run."
                     },
                     "removes": {
                        "type": "string",
                        "description": "A filename, when it does not exist, this step will B(not) be run."
                     },
                     "chdir": {
                        "type": "string",
                        "description": "Change into this directory before running the command."
                     },
                     "executable": {
                        "type": "string",
                        "description": "Change the shell used to execute the command.\nThis expects an absolute path to the executable."
                     },
                     "warn": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nWhether to enable task warnings."
                     },
                     "stdin": {
                        "type": "string",
                        "description": "Set the stdin of the command directly to the specified value."
                     },
                     "stdin_add_newline": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nWhether to append a newline to stdin data."
                     }
                  }
               },
               "shell": {
                  "type": "string"
               }
            },
            "required": [
               "shell"
            ]
         },
         {
            "type": "object",
            "properties": {
               "name": {
                  "type": "string"
               },
               "args": {
                  "type": "object",
                  "properties": {
                     "cmd": {
                        "type": "string",
                        "description": "Path to the local script to run followed by optional arguments."
                     },
                     "creates": {
                        "type": "string",
                        "description": "A filename on the remote node, when it already exists, this step will B(not) be run."
                     },
                     "removes": {
                        "type": "string",
                        "description": "A filename on the remote node, when it does not exist, this step will B(not) be run."
                     },
                     "chdir": {
                        "type": "string",
                        "description": "Change into this directory on the remote node before running the script."
                     },
                     "executable": {
                        "type": "string",
                        "description": "Name or path of a executable to invoke the script with."
                     }
                  }
               },
               "script": {
                  "type": "string"
               }
            },
            "required": [
               "script"
            ]
         },
         {
            "type": "object",
            "properties": {
               "name": {
                  "type": "string"
               },
               "args": {
                  "type": "object",
                  "properties": {
                     "executable": {
                        "type": "string",
                        "description": "Change the shell used to execute the command. Should be an absolute path to the executable.\nWhen using privilege escalation (C(become)) a default shell will be assigned if one is not provided as privilege escalation requires a shell."
                     }
                  }
               },
               "raw": {
                  "type": "string"
               }
            },
            "required": [
               "raw"
            ]
         },
         {
            "type": "object",
            "properties": {
               "name": {
                  "type": "string"
               },
               "args": {
                  "type": "object",
                  "properties": {
                     "cmd": {
                        "type": "string",
                        "description": "The command to run."
                     },
                     "argv": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Passes the command as a list rather than a string.\nUse C(argv) to avoid quoting values that would otherwise be interpreted incorrectly (for example \"user name\").\nOnly the string or the list form can be provided, not both.  One or the other must be provided."
                     },
                     "creates": {
                        "type": "string",
                        "description": "A filename or (since 2.0) glob pattern. If it already exists, this step B(won't) be run."
                     },
                     "removes": {
                        "type": "string",
                        "description": "A filename or (since 2.0) glob pattern. If it already exists, this step B(will) be run."
                     },
                     "chdir": {
                        "type": "string",
                        "description": "Change into this directory before running the command."
                     },
                     "warn": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nEnable or disable task warnings."
                     },
                     "stdin": {
                        "type": "string",
                        "description": "Set the stdin of the command directly to the specified value."
                     },
                     "stdin_add_newline": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nIf set to C(yes), append a newline to stdin data."
                     },
                     "strip_empty_ends": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nStrip empty lines from the end of stdout/stderr in result."
                     }
                  }
               },
               "command": {
                  "type": "string"
               }
            },
            "required": [
               "command"
            ]
         },
         {
            "type": "object",
            "properties": {
               "name": {
                  "type": "string"
               },
               "ping": {
                  "type": "object",
                  "description": "A trivial test module, this module always returns C(pong) on successful contact. It does not make sense in playbooks, but it is useful from C(/usr/bin/ansible) to verify the ability to login and that a usable python is configured.\nThis is NOT ICMP ping, this is just a trivial test module.",
                  "properties": {}
               },
               "testmodule": {
                  "type": "object",
                  "description": "for testing",
                  "properties": {}
               },
               "test_docs_removed_status": {
                  "type": "object",
                  "description": "Test module",
                  "properties": {}
               },
               "test_docs_non_iterable_status": {
                  "type": "object",
                  "description": "Test module",
                  "properties": {}
               },
               "test_docs_no_status": {
                  "type": "object",
                  "description": "Test module",
                  "properties": {}
               },
               "test_docs_no_metadata": {
                  "type": "object",
                  "description": "Test module",
                  "properties": {}
               },
               "test_docs": {
                  "type": "object",
                  "description": "Test module",
                  "properties": {}
               },
               "win_xml": {
                  "type": "object",
                  "description": "Manages XML nodes, attributes and text, using xpath to select which xml nodes need to be managed.\nXML fragments, formatted as strings, are used to specify the desired state of a part or parts of XML files on remote Windows servers.\nFor non-Windows targets, use the M(xml) module instead.",
                  "properties": {
                     "attribute": {
                        "type": "string",
                        "description": "The attribute name if the type is 'attribute'.\nRequired if C(type=attribute)."
                     },
                     "count": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "When set to C(yes), return the number of nodes matched by I(xpath)."
                     },
                     "backup": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Determine whether a backup should be created.\nWhen set to C(yes), create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly."
                     },
                     "fragment": {
                        "type": "string",
                        "description": "The string representation of the XML fragment expected at xpath.  Since ansible 2.9 not required when I(state=absent), or when I(count=yes)."
                     },
                     "xmlstring": {
                        "type": "string",
                        "description": "The string representation of the XML fragment expected at xpath.  Since ansible 2.9 not required when I(state=absent), or when I(count=yes)."
                     },
                     "path": {
                        "type": "string",
                        "description": "Path to the file to operate on."
                     },
                     "dest": {
                        "type": "string",
                        "description": "Path to the file to operate on."
                     },
                     "file": {
                        "type": "string",
                        "description": "Path to the file to operate on."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nSet or remove the nodes (or attributes) matched by I(xpath).",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "type": {
                        "type": "string",
                        "description": "Default: element\n\nThe type of XML node you are working with.",
                        "enum": [
                           "attribute",
                           "element",
                           "text"
                        ]
                     },
                     "xpath": {
                        "type": "string",
                        "description": "Xpath to select the node or nodes to operate on."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "fragment",
                                    "xmlstring"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "path",
                                    "dest",
                                    "file"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "path"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "dest"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "file"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "win_whoami": {
                  "type": "object",
                  "description": "Designed to return the same information as the C(whoami /all) command.\nAlso includes information missing from C(whoami) such as logon metadata like logon rights, id, type.",
                  "properties": {}
               },
               "win_webpicmd": {
                  "type": "object",
                  "description": "Installs packages using Web Platform Installer command-line (U(http://www.iis.net/learn/install/web-platform-installer/web-platform-installer-v4-command-line-webpicmdexe-rtw-release)).\nMust be installed and present in PATH (see M(win_chocolatey) module; 'webpicmd' is the package name, and you must install 'lessmsi' first too)?\nInstall IIS first (see M(win_feature) module).",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the package to be installed."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "win_wakeonlan": {
                  "type": "object",
                  "description": "The C(win_wakeonlan) module sends magic Wake-on-LAN (WoL) broadcast packets.\nFor non-Windows targets, use the M(wakeonlan) module instead.",
                  "properties": {
                     "mac": {
                        "type": "string",
                        "description": "MAC address to send Wake-on-LAN broadcast packet for."
                     },
                     "broadcast": {
                        "type": "string",
                        "description": "Default: 255.255.255.255\n\nNetwork broadcast address to use for broadcasting magic Wake-on-LAN packet."
                     },
                     "port": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 7\n\nUDP port to use for magic Wake-on-LAN packet."
                     }
                  },
                  "required": [
                     "mac"
                  ]
               },
               "win_wait_for_process": {
                  "type": "object",
                  "description": "Waiting for a process to start or stop.\nThis is useful when Windows services behave poorly and do not enumerate external dependencies in their manifest.",
                  "properties": {
                     "process_name_exact": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "The name of the process(es) for which to wait.  The name of the process(es) should not include the file extension suffix."
                     },
                     "process_name_pattern": {
                        "type": "string",
                        "description": "RegEx pattern matching desired process(es)."
                     },
                     "sleep": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 1\n\nNumber of seconds to sleep between checks.\nOnly applies when waiting for a process to start.  Waiting for a process to start does not have a native non-polling mechanism. Waiting for a stop uses native PowerShell and does not require polling."
                     },
                     "process_min_count": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 1\n\nMinimum number of process matching the supplied pattern to satisfy C(present) condition.\nOnly applies to C(present)."
                     },
                     "pid": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "The PID of the process."
                     },
                     "owner": {
                        "type": "string",
                        "description": "The owner of the process.\nRequires PowerShell version 4.0 or newer."
                     },
                     "pre_wait_delay": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Seconds to wait before checking processes."
                     },
                     "post_wait_delay": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Seconds to wait after checking for processes."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhen checking for a running process C(present) will block execution until the process exists, or until the timeout has been reached. C(absent) will block execution until the process no longer exists, or until the timeout has been reached.\nWhen waiting for C(present), the module will return changed only if the process was not present on the initial check but became present on subsequent checks.\nIf, while waiting for C(absent), new processes matching the supplied pattern are started, these new processes will not be included in the action.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "timeout": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 300\n\nThe maximum number of seconds to wait for a for a process to start or stop before erroring out."
                     }
                  }
               },
               "win_wait_for": {
                  "type": "object",
                  "description": "You can wait for a set amount of time C(timeout), this is the default if nothing is specified.\nWaiting for a port to become available is useful for when services are not immediately available after their init scripts return which is true of certain Java application servers.\nYou can wait for a file to exist or not exist on the filesystem.\nThis module can also be used to wait for a regex match string to be present in a file.\nYou can wait for active connections to be closed before continuing on a local port.",
                  "properties": {
                     "connect_timeout": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 5\n\nThe maximum number of seconds to wait for a connection to happen before closing and retrying."
                     },
                     "delay": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "The number of seconds to wait before starting to poll."
                     },
                     "exclude_hosts": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "The list of hosts or IPs to ignore when looking for active TCP connections when C(state=drained)."
                     },
                     "host": {
                        "type": "string",
                        "description": "Default: 127.0.0.1\n\nA resolvable hostname or IP address to wait for.\nIf C(state=drained) then it will only check for connections on the IP specified, you can use '0.0.0.0' to use all host IPs."
                     },
                     "path": {
                        "type": "string",
                        "description": "The path to a file on the filesystem to check.\nIf C(state) is present or started then it will wait until the file exists.\nIf C(state) is absent then it will wait until the file does not exist."
                     },
                     "port": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "The port number to poll on C(host)."
                     },
                     "regex": {
                        "type": "string",
                        "description": "Can be used to match a string in a file.\nIf C(state) is present or started then it will wait until the regex matches.\nIf C(state) is absent then it will wait until the regex does not match.\nDefaults to a multiline regex."
                     },
                     "search_regex": {
                        "type": "string",
                        "description": "Can be used to match a string in a file.\nIf C(state) is present or started then it will wait until the regex matches.\nIf C(state) is absent then it will wait until the regex does not match.\nDefaults to a multiline regex."
                     },
                     "regexp": {
                        "type": "string",
                        "description": "Can be used to match a string in a file.\nIf C(state) is present or started then it will wait until the regex matches.\nIf C(state) is absent then it will wait until the regex does not match.\nDefaults to a multiline regex."
                     },
                     "sleep": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 1\n\nNumber of seconds to sleep between checks."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: started\n\nWhen checking a port, C(started) will ensure the port is open, C(stopped) will check that is it closed and C(drained) will check for active connections.\nWhen checking for a file or a search string C(present) or C(started) will ensure that the file or string is present, C(absent) will check that the file or search string is absent or removed.",
                        "enum": [
                           "absent",
                           "drained",
                           "present",
                           "started",
                           "stopped"
                        ]
                     },
                     "timeout": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 300\n\nThe maximum number of seconds to wait for."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "regex",
                                    "search_regex",
                                    "regexp"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "win_user_right": {
                  "type": "object",
                  "description": "Add, remove or set User Rights for a group or users or groups.\nYou can set user rights for both local and domain accounts.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name of the User Right as shown by the C(Constant Name) value from U(https://technet.microsoft.com/en-us/library/dd349804.aspx).\nThe module will return an error if the right is invalid."
                     },
                     "users": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "A list of users or groups to add/remove on the User Right.\nThese can be in the form DOMAIN\\user-group, user-group@DOMAIN.COM for domain users/groups.\nFor local users/groups it can be in the form user-group, .\\user-group, SERVERNAME\\user-group where SERVERNAME is the name of the remote server.\nYou can also add special local accounts like SYSTEM and others.\nCan be set to an empty list with I(action=set) to remove all accounts from the right."
                     },
                     "action": {
                        "type": "string",
                        "description": "Default: set\n\nC(add) will add the users/groups to the existing right.\nC(remove) will remove the users/groups from the existing right.\nC(set) will replace the users/groups of the existing right.",
                        "enum": [
                           "add",
                           "remove",
                           "set"
                        ]
                     }
                  },
                  "required": [
                     "name",
                     "users"
                  ]
               },
               "win_user_profile": {
                  "type": "object",
                  "description": "Used to create or remove user profiles on a Windows host.\nThis can be used to create a profile before a user logs on or delete a profile when removing a user account.\nA profile can be created for both a local or domain account.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Specifies the base name for the profile path.\nWhen I(state) is C(present) this is used to create the profile for I(username) at a specific path within the profile directory.\nThis cannot be used to specify a path outside of the profile directory but rather it specifies a folder(s) within this directory.\nIf a profile for another user already exists at the same path, then a 3 digit incremental number is appended by Windows automatically.\nWhen I(state) is C(absent) and I(username) is not set, then the module will remove all profiles that point to the profile path derived by this value.\nThis is useful if the account no longer exists but the profile still remains."
                     },
                     "remove_multiple": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "When I(state) is C(absent) and the value for I(name) matches multiple profiles the module will fail.\nSet this value to C(yes) to force the module to delete all the profiles found."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWill ensure the profile exists when set to C(present).\nWhen creating a profile the I(username) option must be set to a valid account.\nWill remove the profile(s) when set to C(absent).\nWhen removing a profile either I(username) must be set to a valid account, or I(name) is set to the profile's base name.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "username": {
                        "type": "string",
                        "description": "The account name of security identifier (SID) for the profile.\nThis must be set when I(state) is C(present) and must be a valid account or the SID of a valid account.\nWhen I(state) is C(absent) then this must still be a valid account number but the SID can be a deleted user's SID."
                     }
                  }
               },
               "win_user": {
                  "type": "object",
                  "description": "Manages local Windows user accounts.\nFor non-Windows targets, use the M(user) module instead.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the user to create, remove or modify."
                     },
                     "fullname": {
                        "type": "string",
                        "description": "Full name of the user."
                     },
                     "description": {
                        "type": "string",
                        "description": "Description of the user."
                     },
                     "password": {
                        "type": "string",
                        "description": "Optionally set the user's password to this (plain text) value."
                     },
                     "update_password": {
                        "type": "string",
                        "description": "Default: always\n\nC(always) will update passwords if they differ.  C(on_create) will only set the password for newly created users.",
                        "enum": [
                           "always",
                           "on_create"
                        ]
                     },
                     "password_expired": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "C(yes) will require the user to change their password at next login.\nC(no) will clear the expired password flag."
                     },
                     "password_never_expires": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "C(yes) will set the password to never expire.\nC(no) will allow the password to expire."
                     },
                     "user_cannot_change_password": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "C(yes) will prevent the user from changing their password.\nC(no) will allow the user to change their password."
                     },
                     "account_disabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "C(yes) will disable the user account.\nC(no) will clear the disabled flag."
                     },
                     "account_locked": {
                        "type": "string",
                        "description": "C(no) will unlock the user account if locked.",
                        "enum": [
                           "no"
                        ]
                     },
                     "groups": {
                        "type": "string",
                        "description": "Adds or removes the user from this comma-separated list of groups, depending on the value of I(groups_action).\nWhen I(groups_action) is C(replace) and I(groups) is set to the empty string ('groups='), the user is removed from all groups."
                     },
                     "groups_action": {
                        "type": "string",
                        "description": "Default: replace\n\nIf C(add), the user is added to each group in I(groups) where not already a member.\nIf C(replace), the user is added as a member of each group in I(groups) and removed from any other groups.\nIf C(remove), the user is removed from each group in I(groups).",
                        "enum": [
                           "add",
                           "replace",
                           "remove"
                        ]
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhen C(absent), removes the user account if it exists.\nWhen C(present), creates or updates the user account.\nWhen C(query) (new in 1.9), retrieves the user account details without making any changes.",
                        "enum": [
                           "absent",
                           "present",
                           "query"
                        ]
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "win_uri": {
                  "type": "object",
                  "description": "Interacts with FTP, HTTP and HTTPS web services.\nSupports Digest, Basic and WSSE HTTP authentication mechanisms.\nFor non-Windows targets, use the M(uri) module instead.",
                  "properties": {
                     "url": {
                        "type": "string",
                        "description": "Supports FTP, HTTP or HTTPS URLs in the form of (ftp|http|https)://host.domain:port/path."
                     },
                     "method": {
                        "type": "string",
                        "description": "Default: GET\n\nThe HTTP Method of the request or response."
                     },
                     "content_type": {
                        "type": "string",
                        "description": "Sets the \"Content-Type\" header."
                     },
                     "body": {
                        "type": "string",
                        "description": "The body of the HTTP request/response to the web service."
                     },
                     "dest": {
                        "type": "string",
                        "description": "Output the response body to a file."
                     },
                     "creates": {
                        "type": "string",
                        "description": "A filename, when it already exists, this step will be skipped."
                     },
                     "removes": {
                        "type": "string",
                        "description": "A filename, when it does not exist, this step will be skipped."
                     },
                     "return_content": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether or not to return the body of the response as a \"content\" key in the dictionary result. If the reported Content-type is \"application/json\", then the JSON is additionally loaded into a key called C(json) in the dictionary results."
                     },
                     "status_code": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Default: [200]\n\nA valid, numeric, HTTP status code that signifies success of the request.\nCan also be comma separated list of status codes."
                     },
                     "url_username": {
                        "type": "string",
                        "description": "The username to use for authentication.\nWas originally called I(user) but was changed to I(url_username) in Ansible 2.9."
                     },
                     "url_password": {
                        "type": "string",
                        "description": "The password for I(url_username).\nWas originally called I(password) but was changed to I(url_password) in Ansible 2.9."
                     },
                     "follow_redirects": {
                        "type": "string",
                        "description": ""
                     },
                     "maximum_redirection": {
                        "type": "string",
                        "description": ""
                     },
                     "client_cert": {
                        "type": "string",
                        "description": ""
                     },
                     "client_cert_password": {
                        "type": "string",
                        "description": ""
                     },
                     "use_proxy": {
                        "type": "string",
                        "description": ""
                     },
                     "proxy_url": {
                        "type": "string",
                        "description": ""
                     },
                     "proxy_username": {
                        "type": "string",
                        "description": ""
                     },
                     "proxy_password": {
                        "type": "string",
                        "description": ""
                     }
                  },
                  "required": [
                     "url"
                  ]
               },
               "win_updates": {
                  "type": "object",
                  "description": "Searches, downloads, and installs Windows updates synchronously by automating the Windows Update client.",
                  "properties": {
                     "blacklist": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "A list of update titles or KB numbers that can be used to specify which updates are to be excluded from installation.\nIf an available update does match one of the entries, then it is skipped and not installed.\nEach entry can either be the KB article or Update title as a regex according to the PowerShell regex rules."
                     },
                     "category_names": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Default: ['CriticalUpdates', 'SecurityUpdates', 'UpdateRollups']\n\nA scalar or list of categories to install updates from. To get the list of categories, run the module with C(state=searched). The category must be the full category string, but is case insensitive.\nSome possible categories are Application, Connectors, Critical Updates, Definition Updates, Developer Kits, Feature Packs, Guidance, Security Updates, Service Packs, Tools, Update Rollups and Updates."
                     },
                     "reboot": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Ansible will automatically reboot the remote host if it is required and continue to install updates after the reboot.\nThis can be used instead of using a M(win_reboot) task after this one and ensures all updates for that category is installed in one go.\nAsync does not work when C(reboot=yes)."
                     },
                     "reboot_timeout": {
                        "type": "string",
                        "description": "Default: 1200\n\nThe time in seconds to wait until the host is back online from a reboot.\nThis is only used if C(reboot=yes) and a reboot is required."
                     },
                     "server_selection": {
                        "type": "string",
                        "description": "Default: default\n\nDefines the Windows Update source catalog.\nC(default) Use the default search source. For many systems default is set to the Microsoft Windows Update catalog. Systems participating in Windows Server Update Services (WSUS), Systems Center Configuration Manager (SCCM), or similar corporate update server environments may default to those managed update sources instead of the Windows Update catalog.\nC(managed_server) Use a managed server catalog. For environments utilizing Windows Server Update Services (WSUS), Systems Center Configuration Manager (SCCM), or similar corporate update servers, this option selects the defined corporate update source.\nC(windows_update) Use the Microsoft Windows Update catalog.",
                        "enum": [
                           "default",
                           "managed_server",
                           "windows_update"
                        ]
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: installed\n\nControls whether found updates are downloaded or installed or listed\nThis module also supports Ansible check mode, which has the same effect as setting state=searched",
                        "enum": [
                           "installed",
                           "searched",
                           "downloaded"
                        ]
                     },
                     "log_path": {
                        "type": "string",
                        "description": "If set, C(win_updates) will append update progress to the specified file. The directory must already exist."
                     },
                     "whitelist": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "A list of update titles or KB numbers that can be used to specify which updates are to be searched or installed.\nIf an available update does not match one of the entries, then it is skipped and not installed.\nEach entry can either be the KB article or Update title as a regex according to the PowerShell regex rules.\nThe whitelist is only validated on updates that were found based on I(category_names). It will not force the module to install an update if it was not in the category specified."
                     },
                     "use_scheduled_task": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Will not auto elevate the remote process with I(become) and use a scheduled task instead.\nSet this to C(yes) when using this module with async on Server 2008, 2008 R2, or Windows 7, or on Server 2008 that is not authenticated with basic or credssp.\nCan also be set to C(yes) on newer hosts where become does not work due to further privilege restrictions from the OS defaults."
                     }
                  }
               },
               "win_unzip": {
                  "type": "object",
                  "description": "Unzips compressed files and archives.\nSupports .zip files natively.\nSupports other formats supported by the Powershell Community Extensions (PSCX) module (basically everything 7zip supports).\nFor non-Windows targets, use the M(unarchive) module instead.",
                  "properties": {
                     "src": {
                        "type": "string",
                        "description": "File to be unzipped (provide absolute path)."
                     },
                     "dest": {
                        "type": "string",
                        "description": "Destination of zip file (provide absolute path of directory). If it does not exist, the directory will be created."
                     },
                     "delete_archive": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Remove the zip file, after unzipping."
                     },
                     "rm": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Remove the zip file, after unzipping."
                     },
                     "recurse": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Recursively expand zipped files within the src file.\nSetting to a value of C(yes) requires the PSCX module to be installed."
                     },
                     "creates": {
                        "type": "string",
                        "description": "If this file or directory exists the specified src will not be extracted."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "delete_archive",
                                    "rm"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "win_toast": {
                  "type": "object",
                  "description": "Sends alerts which appear in the Action Center area of the windows desktop.",
                  "properties": {
                     "expire": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 45\n\nHow long in seconds before the notification expires."
                     },
                     "group": {
                        "type": "string",
                        "description": "Default: Powershell\n\nWhich notification group to add the notification to."
                     },
                     "msg": {
                        "type": "string",
                        "description": "Default: Hello, World!\n\nThe message to appear inside the notification.\nMay include \\n to format the message to appear within the Action Center."
                     },
                     "popup": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nIf C(no), the notification will not pop up and will only appear in the Action Center."
                     },
                     "tag": {
                        "type": "string",
                        "description": "Default: Ansible\n\nThe tag to add to the notification."
                     },
                     "title": {
                        "type": "string",
                        "description": "Default: Notification HH:mm\n\nThe notification title, which appears in the pop up.."
                     }
                  }
               },
               "win_timezone": {
                  "type": "object",
                  "description": "Sets machine time to the specified timezone.",
                  "properties": {
                     "timezone": {
                        "type": "string",
                        "description": "Timezone to set to.\nExample: Central Standard Time"
                     }
                  },
                  "required": [
                     "timezone"
                  ]
               },
               "win_template": {
                  "type": "object",
                  "description": "",
                  "properties": {
                     "backup": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Determine whether a backup should be created.\nWhen set to C(yes), create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly."
                     },
                     "newline_sequence": {
                        "type": "string",
                        "description": "Default: \\r\\n\n\n"
                     },
                     "force": {
                        "type": "string",
                        "description": ""
                     }
                  }
               },
               "win_tempfile": {
                  "type": "object",
                  "description": "Creates temporary files and directories.\nFor non-Windows targets, please use the M(tempfile) module instead.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: file\n\nWhether to create file or directory.",
                        "enum": [
                           "directory",
                           "file"
                        ]
                     },
                     "path": {
                        "type": "string",
                        "description": "Default: %TEMP%\n\nLocation where temporary file or directory should be created.\nIf path is not specified default system temporary directory (%TEMP%) will be used."
                     },
                     "dest": {
                        "type": "string",
                        "description": "Default: %TEMP%\n\nLocation where temporary file or directory should be created.\nIf path is not specified default system temporary directory (%TEMP%) will be used."
                     },
                     "prefix": {
                        "type": "string",
                        "description": "Default: ansible.\n\nPrefix of file/directory name created by module."
                     },
                     "suffix": {
                        "type": "string",
                        "description": "Suffix of file/directory name created by module."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "path",
                                    "dest"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "win_stat": {
                  "type": "object",
                  "description": "Returns information about a Windows file.\nFor non-Windows targets, use the M(stat) module instead.",
                  "properties": {
                     "path": {
                        "type": "string",
                        "description": "The full path of the file/object to get the facts of; both forward and back slashes are accepted."
                     },
                     "dest": {
                        "type": "string",
                        "description": "The full path of the file/object to get the facts of; both forward and back slashes are accepted."
                     },
                     "name": {
                        "type": "string",
                        "description": "The full path of the file/object to get the facts of; both forward and back slashes are accepted."
                     },
                     "get_md5": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether to return the checksum sum of the file. Between Ansible 1.9 and Ansible 2.2 this is no longer an MD5, but a SHA1 instead. As of Ansible 2.3 this is back to an MD5. Will return None if host is unable to use specified algorithm.\nThe default of this option changed from C(yes) to C(no) in Ansible 2.5 and will be removed altogether in Ansible 2.9.\nUse C(get_checksum=yes) with C(checksum_algorithm=md5) to return an md5 hash under the C(checksum) return value."
                     },
                     "get_checksum": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nWhether to return a checksum of the file (default sha1)"
                     },
                     "checksum_algorithm": {
                        "type": "string",
                        "description": "Default: sha1\n\nAlgorithm to determine checksum of file.\nWill throw an error if the host is unable to use specified algorithm.",
                        "enum": [
                           "md5",
                           "sha1",
                           "sha256",
                           "sha384",
                           "sha512"
                        ]
                     },
                     "follow": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether to follow symlinks or junction points.\nIn the case of C(path) pointing to another link, then that will be followed until no more links are found."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "path",
                                    "dest",
                                    "name"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "path"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "dest"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "win_snmp": {
                  "type": "object",
                  "description": "This module configures the Windows SNMP service.",
                  "properties": {
                     "permitted_managers": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "The list of permitted SNMP managers."
                     },
                     "community_strings": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "The list of read-only SNMP community strings."
                     },
                     "action": {
                        "type": "string",
                        "description": "Default: set\n\nC(add) will add new SNMP community strings and/or SNMP managers\nC(set) will replace SNMP community strings and/or SNMP managers. An empty list for either C(community_strings) or C(permitted_managers) will result in the respective lists being removed entirely.\nC(remove) will remove SNMP community strings and/or SNMP managers",
                        "enum": [
                           "add",
                           "set",
                           "remove"
                        ]
                     }
                  }
               },
               "win_shortcut": {
                  "type": "object",
                  "description": "Create, manage and delete Windows shortcuts",
                  "properties": {
                     "src": {
                        "type": "string",
                        "description": "Executable or URL the shortcut points to.\nThe executable needs to be in your PATH, or has to be an absolute path to the executable."
                     },
                     "description": {
                        "type": "string",
                        "description": "Description for the shortcut.\nThis is usually shown when hoovering the icon."
                     },
                     "dest": {
                        "type": "string",
                        "description": "Destination file for the shortcuting file.\nFile name should have a C(.lnk) or C(.url) extension."
                     },
                     "arguments": {
                        "type": "string",
                        "description": "Additional arguments for the executable defined in C(src).\nWas originally just C(args) but renamed in Ansible 2.8."
                     },
                     "args": {
                        "type": "string",
                        "description": "Additional arguments for the executable defined in C(src).\nWas originally just C(args) but renamed in Ansible 2.8."
                     },
                     "directory": {
                        "type": "string",
                        "description": "Working directory for executable defined in C(src)."
                     },
                     "icon": {
                        "type": "string",
                        "description": "Icon used for the shortcut.\nFile name should have a C(.ico) extension.\nThe file name is followed by a comma and the number in the library file (.dll) or use 0 for an image file."
                     },
                     "hotkey": {
                        "type": "string",
                        "description": "Key combination for the shortcut.\nThis is a combination of one or more modifiers and a key.\nPossible modifiers are Alt, Ctrl, Shift, Ext.\nPossible keys are [A-Z] and [0-9]."
                     },
                     "windowstyle": {
                        "type": "string",
                        "description": "Influences how the application is displayed when it is launched.",
                        "enum": [
                           "maximized",
                           "minimized",
                           "normal"
                        ]
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhen C(absent), removes the shortcut if it exists.\nWhen C(present), creates or updates the shortcut.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "run_as_admin": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "When C(src) is an executable, this can control whether the shortcut will be opened as an administrator or not."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "arguments",
                                    "args"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "win_share": {
                  "type": "object",
                  "description": "Add, modify or remove Windows share and set share permissions.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Share name."
                     },
                     "path": {
                        "type": "string",
                        "description": "Share directory."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nSpecify whether to add C(present) or remove C(absent) the specified share.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "description": {
                        "type": "string",
                        "description": "Share description."
                     },
                     "list": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Specify whether to allow or deny file listing, in case user has no permission on share. Also known as Access-Based Enumeration."
                     },
                     "read": {
                        "type": "string",
                        "description": "Specify user list that should get read access on share, separated by comma."
                     },
                     "change": {
                        "type": "string",
                        "description": "Specify user list that should get read and write access on share, separated by comma."
                     },
                     "full": {
                        "type": "string",
                        "description": "Specify user list that should get full access on share, separated by comma."
                     },
                     "deny": {
                        "type": "string",
                        "description": "Specify user list that should get no access, regardless of implied access on share, separated by comma."
                     },
                     "caching_mode": {
                        "type": "string",
                        "description": "Default: Manual\n\nSet the CachingMode for this share.",
                        "enum": [
                           "BranchCache",
                           "Documents",
                           "Manual",
                           "None",
                           "Programs",
                           "Unknown"
                        ]
                     },
                     "encrypt": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Sets whether to encrypt the traffic to the share or not."
                     }
                  },
                  "required": [
                     "name",
                     "path"
                  ]
               },
               "win_service": {
                  "type": "object",
                  "description": "Manage and query Windows services.\nFor non-Windows targets, use the M(service) module instead.",
                  "properties": {
                     "dependencies": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "A list of service dependencies to set for this particular service.\nThis should be a list of service names and not the display name of the service.\nThis works by C(dependency_action) to either add/remove or set the services in this list."
                     },
                     "dependency_action": {
                        "type": "string",
                        "description": "Default: set\n\nUsed in conjunction with C(dependency) to either add the dependencies to the existing service dependencies.\nRemove the dependencies to the existing dependencies.\nSet the dependencies to only the values in the list replacing the existing dependencies.",
                        "enum": [
                           "add",
                           "remove",
                           "set"
                        ]
                     },
                     "desktop_interact": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether to allow the service user to interact with the desktop.\nThis should only be set to C(yes) when using the C(LocalSystem) username."
                     },
                     "description": {
                        "type": "string",
                        "description": "The description to set for the service."
                     },
                     "display_name": {
                        "type": "string",
                        "description": "The display name to set for the service."
                     },
                     "force_dependent_services": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "If C(yes), stopping or restarting a service with dependent services will force the dependent services to stop or restart also.\nIf C(no), stopping or restarting a service with dependent services may fail."
                     },
                     "name": {
                        "type": "string",
                        "description": "Name of the service.\nIf only the name parameter is specified, the module will report on whether the service exists or not without making any changes."
                     },
                     "path": {
                        "type": "string",
                        "description": "The path to the executable to set for the service."
                     },
                     "password": {
                        "type": "string",
                        "description": "The password to set the service to start as.\nThis and the C(username) argument must be supplied together.\nIf specifying C(LocalSystem), C(NetworkService) or C(LocalService) this field must be an empty string and not null."
                     },
                     "start_mode": {
                        "type": "string",
                        "description": "Set the startup type for the service.\nA newly created service will default to C(auto).\nC(delayed) added in Ansible 2.3",
                        "enum": [
                           "auto",
                           "delayed",
                           "disabled",
                           "manual"
                        ]
                     },
                     "state": {
                        "type": "string",
                        "description": "The desired state of the service.\nC(started)/C(stopped)/C(absent)/C(paused) are idempotent actions that will not run commands unless necessary.\nC(restarted) will always bounce the service.\nC(absent) was added in Ansible 2.3\nC(paused) was added in Ansible 2.4\nOnly services that support the paused state can be paused, you can check the return value C(can_pause_and_continue).\nYou can only pause a service that is already started.\nA newly created service will default to C(stopped).",
                        "enum": [
                           "absent",
                           "paused",
                           "started",
                           "stopped",
                           "restarted"
                        ]
                     },
                     "username": {
                        "type": "string",
                        "description": "The username to set the service to start as.\nThis and the C(password) argument must be supplied together when using a local or domain account.\nSet to C(LocalSystem) to use the SYSTEM account.\nA newly created service will default to C(LocalSystem).\nIf using a custom user account, it must have the C(SeServiceLogonRight) granted to be able to start up. You can use the M(win_user_right) module to grant this user right for you."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "win_security_policy": {
                  "type": "object",
                  "description": "Allows you to set the local security policies that are configured by SecEdit.exe.",
                  "properties": {
                     "section": {
                        "type": "string",
                        "description": "The ini section the key exists in.\nIf the section does not exist then the module will return an error.\nExample sections to use are 'Account Policies', 'Local Policies', 'Event Log', 'Restricted Groups', 'System Services', 'Registry' and 'File System'\nIf wanting to edit the C(Privilege Rights) section, use the M(win_user_right) module instead."
                     },
                     "key": {
                        "type": "string",
                        "description": "The ini key of the section or policy name to modify.\nThe module will return an error if this key is invalid."
                     },
                     "value": {
                        "type": "string",
                        "description": "The value for the ini key or policy name.\nIf the key takes in a boolean value then 0 = False and 1 = True."
                     }
                  },
                  "required": [
                     "section",
                     "key",
                     "value"
                  ]
               },
               "win_scheduled_task_stat": {
                  "type": "object",
                  "description": "Will return whether the folder and task exists.\nReturns the names of tasks in the folder specified.\nUse M(win_scheduled_task) to configure a scheduled task.",
                  "properties": {
                     "path": {
                        "type": "string",
                        "description": "Default: \\\n\nThe folder path where the task lives."
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the scheduled task to get information for.\nIf C(name) is set and exists, will return information on the task itself."
                     }
                  }
               },
               "win_scheduled_task": {
                  "type": "object",
                  "description": "Creates/modified or removes Windows scheduled tasks.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name of the scheduled task without the path."
                     },
                     "path": {
                        "type": "string",
                        "description": "Default: \\\n\nTask folder in which this task will be stored.\nWill create the folder when C(state=present) and the folder does not already exist.\nWill remove the folder when C(state=absent) and there are no tasks left in the folder."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhen C(state=present) will ensure the task exists.\nWhen C(state=absent) will ensure the task does not exist.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "actions": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "A list of action to configure for the task.\nSee suboptions for details on how to construct each list entry.\nWhen creating a task there MUST be at least one action but when deleting a task this can be a null or an empty list.\nThe ordering of this list is important, the module will ensure the order is kept when modifying the task.\nThis module only supports the C(ExecAction) type but can still delete the older legacy types."
                     },
                     "triggers": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "A list of triggers to configure for the task.\nSee suboptions for details on how to construct each list entry.\nThe ordering of this list is important, the module will ensure the order is kept when modifying the task.\nThere are multiple types of triggers, see U(https://msdn.microsoft.com/en-us/library/windows/desktop/aa383868.aspx) for a list of trigger types and their options.\nThe suboption options listed below are not required for all trigger types, read the description for more details."
                     },
                     "display_name": {
                        "type": "string",
                        "description": "The name of the user/group that is displayed in the Task Scheduler UI."
                     },
                     "group": {
                        "type": "string",
                        "description": "The group that will run the task.\nC(group) and C(username) are exclusive to each other and cannot be set at the same time.\nC(logon_type) can either be not set or equal C(group)."
                     },
                     "logon_type": {
                        "type": "string",
                        "description": "The logon method that the task will run with.\nC(password) means the password will be stored and the task has access to network resources.\nC(s4u) means the existing token will be used to run the task and no password will be stored with the task. Means no network or encrypted files access.\nC(interactive_token) means the user must already be logged on interactively and will run in an existing interactive session.\nC(group) means that the task will run as a group.\nC(service_account) means that a service account like System, Local Service or Network Service will run the task.",
                        "enum": [
                           "none",
                           "password",
                           "s4u",
                           "interactive_token",
                           "group",
                           "service_account",
                           "token_or_password"
                        ]
                     },
                     "run_level": {
                        "type": "string",
                        "description": "The level of user rights used to run the task.\nIf not specified the task will be created with limited rights.",
                        "enum": [
                           "limited",
                           "highest"
                        ]
                     },
                     "runlevel": {
                        "type": "string",
                        "description": "The level of user rights used to run the task.\nIf not specified the task will be created with limited rights.",
                        "enum": [
                           "limited",
                           "highest"
                        ]
                     },
                     "username": {
                        "type": "string",
                        "description": "The user to run the scheduled task as.\nWill default to the current user under an interactive token if not specified during creation."
                     },
                     "user": {
                        "type": "string",
                        "description": "The user to run the scheduled task as.\nWill default to the current user under an interactive token if not specified during creation."
                     },
                     "password": {
                        "type": "string",
                        "description": "The password for the user account to run the scheduled task as.\nThis is required when running a task without the user being logged in, excluding the builtin service accounts and Group Managed Service Accounts (gMSA).\nIf set, will always result in a change unless C(update_password) is set to C(no) and no other changes are required for the service."
                     },
                     "update_password": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nWhether to update the password even when not other changes have occurred.\nWhen C(yes) will always result in a change when executing the module."
                     },
                     "author": {
                        "type": "string",
                        "description": "The author of the task."
                     },
                     "date": {
                        "type": "string",
                        "description": "The date when the task was registered."
                     },
                     "description": {
                        "type": "string",
                        "description": "The description of the task."
                     },
                     "source": {
                        "type": "string",
                        "description": "The source of the task."
                     },
                     "version": {
                        "type": "string",
                        "description": "The version number of the task."
                     },
                     "allow_demand_start": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether the task can be started by using either the Run command or the Context menu."
                     },
                     "allow_hard_terminate": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether the task can be terminated by using TerminateProcess."
                     },
                     "compatibility": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "The integer value with indicates which version of Task Scheduler a task is compatible with.\nC(0) means the task is compatible with the AT command.\nC(1) means the task is compatible with Task Scheduler 1.0.\nC(2) means the task is compatible with Task Scheduler 2.0."
                     },
                     "delete_expired_task_after": {
                        "type": "string",
                        "description": "The amount of time that the Task Scheduler will wait before deleting the task after it expires.\nA task expires after the end_boundary has been exceeded for all triggers associated with the task.\nThis is in the ISO 8601 Duration format C(P[n]Y[n]M[n]DT[n]H[n]M[n]S)."
                     },
                     "disallow_start_if_on_batteries": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether the task will not be started if the computer is running on battery power."
                     },
                     "enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether the task is enabled, the task can only run when C(yes)."
                     },
                     "execution_time_limit": {
                        "type": "string",
                        "description": "The amount of time allowed to complete the task.\nWhen not set, the time limit is infinite.\nThis is in the ISO 8601 Duration format C(P[n]Y[n]M[n]DT[n]H[n]M[n]S)."
                     },
                     "hidden": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether the task will be hidden in the UI."
                     },
                     "multiple_instances": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "An integer that indicates the behaviour when starting a task that is already running.\nC(0) will start a new instance in parallel with existing instances of that task.\nC(1) will wait until other instances of that task to finish running before starting itself.\nC(2) will not start a new instance if another is running.\nC(3) will stop other instances of the task and start the new one."
                     },
                     "priority": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "The priority level (0-10) of the task.\nWhen creating a new task the default is C(7).\nSee U(https://msdn.microsoft.com/en-us/library/windows/desktop/aa383512.aspx) for details on the priority levels."
                     },
                     "restart_count": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "The number of times that the Task Scheduler will attempt to restart the task."
                     },
                     "restart_interval": {
                        "type": "string",
                        "description": "How long the Task Scheduler will attempt to restart the task.\nIf this is set then C(restart_count) must also be set.\nThe maximum allowed time is 31 days.\nThe minimum allowed time is 1 minute.\nThis is in the ISO 8601 Duration format C(P[n]Y[n]M[n]DT[n]H[n]M[n]S)."
                     },
                     "run_only_if_idle": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether the task will run the task only if the computer is in an idle state."
                     },
                     "run_only_if_network_available": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether the task will run only when a network is available."
                     },
                     "start_when_available": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether the task can start at any time after its scheduled time has passed."
                     },
                     "stop_if_going_on_batteries": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether the task will be stopped if the computer begins to run on battery power."
                     },
                     "wake_to_run": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether the task will wake the computer when it is time to run the task."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "run_level",
                                    "runlevel"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "username",
                                    "user"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "win_say": {
                  "type": "object",
                  "description": "Uses .NET libraries to convert text to speech and optionally play .wav sounds.  Audio Service needs to be running and some kind of speakers or headphones need to be attached to the windows target(s) for the speech to be audible.",
                  "properties": {
                     "msg": {
                        "type": "string",
                        "description": "The text to be spoken.\nUse either C(msg) or C(msg_file).\nOptional so that you can use this module just to play sounds."
                     },
                     "msg_file": {
                        "type": "string",
                        "description": "Full path to a windows format text file containing the text to be spoken.\nUse either C(msg) or C(msg_file).\nOptional so that you can use this module just to play sounds."
                     },
                     "voice": {
                        "type": "string",
                        "description": "Which voice to use. See notes for how to discover installed voices.\nIf the requested voice is not available the default voice will be used. Example voice names from Windows 10 are C(Microsoft Zira Desktop) and C(Microsoft Hazel Desktop)."
                     },
                     "speech_speed": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "How fast or slow to speak the text.\nMust be an integer value in the range -10 to 10.\n-10 is slowest, 10 is fastest."
                     },
                     "start_sound_path": {
                        "type": "string",
                        "description": "Full path to a C(.wav) file containing a sound to play before the text is spoken.\nUseful on conference calls to alert other speakers that ansible has something to say."
                     },
                     "end_sound_path": {
                        "type": "string",
                        "description": "Full path to a C(.wav) file containing a sound to play after the text has been spoken.\nUseful on conference calls to alert other speakers that ansible has finished speaking."
                     }
                  }
               },
               "win_route": {
                  "type": "object",
                  "description": "Add or remove a static route.",
                  "properties": {
                     "destination": {
                        "type": "string",
                        "description": "Destination IP address in CIDR format (ip address/prefix length)."
                     },
                     "gateway": {
                        "type": "string",
                        "description": "The gateway used by the static route.\nIf C(gateway) is not provided it will be set to C(0.0.0.0)."
                     },
                     "metric": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 1\n\nMetric used by the static route."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIf C(absent), it removes a network static route.\nIf C(present), it adds a network static route.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     }
                  },
                  "required": [
                     "destination"
                  ]
               },
               "win_robocopy": {
                  "type": "object",
                  "description": "Synchronizes the contents of files/directories from a source to destination.\nUnder the hood this just calls out to RoboCopy, since that should be available on most modern Windows systems.",
                  "properties": {
                     "src": {
                        "type": "string",
                        "description": "Source file/directory to sync."
                     },
                     "dest": {
                        "type": "string",
                        "description": "Destination file/directory to sync (Will receive contents of src)."
                     },
                     "recurse": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Includes all subdirectories (Toggles the C(/e) flag to RoboCopy).\nIf C(flags) is set, this will be ignored."
                     },
                     "purge": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Deletes any files/directories found in the destination that do not exist in the source.\nToggles the C(/purge) flag to RoboCopy.\nIf C(flags) is set, this will be ignored."
                     },
                     "flags": {
                        "type": "string",
                        "description": "Directly supply Robocopy flags.\nIf set, C(purge) and C(recurse) will be ignored."
                     }
                  },
                  "required": [
                     "src",
                     "dest"
                  ]
               },
               "win_regmerge": {
                  "type": "object",
                  "description": "Wraps the reg.exe command to import the contents of a registry file.\nSuitable for use with registry files created using M(win_template).\nWindows registry files have a specific format and must be constructed correctly with carriage return and line feed line endings otherwise they will not be merged.\nExported registry files often start with a Byte Order Mark which must be removed if the file is to templated using M(win_template).\nRegistry file format is described at U(https://support.microsoft.com/en-us/kb/310516)\nSee also M(win_template), M(win_regedit)",
                  "properties": {
                     "path": {
                        "type": "string",
                        "description": "The full path including file name to the registry file on the remote machine to be merged"
                     },
                     "compare_key": {
                        "type": "string",
                        "description": "The parent key to use when comparing the contents of the registry to the contents of the file.  Needs to be in HKLM or HKCU part of registry. Use a PS-Drive style path for example HKLM:\\SOFTWARE not HKEY_LOCAL_MACHINE\\SOFTWARE If not supplied, or the registry key is not found, no comparison will be made, and the module will report changed."
                     }
                  },
                  "required": [
                     "path"
                  ]
               },
               "win_region": {
                  "type": "object",
                  "description": "Set the location settings of a Windows Server.\nSet the format settings of a Windows Server.\nSet the unicode language settings of a Windows Server.\nCopy across these settings to the default profile.",
                  "properties": {
                     "location": {
                        "type": "string",
                        "description": "The location to set for the current user, see U(https://msdn.microsoft.com/en-us/library/dd374073.aspx) for a list of GeoIDs you can use and what location it relates to.\nThis needs to be set if C(format) or C(unicode_language) is not set."
                     },
                     "format": {
                        "type": "string",
                        "description": "The language format to set for the current user, see U(https://msdn.microsoft.com/en-us/library/system.globalization.cultureinfo.aspx) for a list of culture names to use.\nThis needs to be set if C(location) or C(unicode_language) is not set."
                     },
                     "unicode_language": {
                        "type": "string",
                        "description": "The unicode language format to set for all users, see U(https://msdn.microsoft.com/en-us/library/system.globalization.cultureinfo.aspx) for a list of culture names to use.\nThis needs to be set if C(location) or C(format) is not set. After setting this value a reboot is required for it to take effect."
                     },
                     "copy_settings": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "This will copy the current format and location values to new user profiles and the welcome screen. This will only run if C(location), C(format) or C(unicode_language) has resulted in a change. If this process runs then it will always result in a change."
                     }
                  }
               },
               "win_regedit": {
                  "type": "object",
                  "description": "Add, modify or remove registry keys and values.\nMore information about the windows registry from Wikipedia U(https://en.wikipedia.org/wiki/Windows_Registry).",
                  "properties": {
                     "path": {
                        "type": "string",
                        "description": "Name of the registry path.\nShould be in one of the following registry hives: HKCC, HKCR, HKCU, HKLM, HKU."
                     },
                     "key": {
                        "type": "string",
                        "description": "Name of the registry path.\nShould be in one of the following registry hives: HKCC, HKCR, HKCU, HKLM, HKU."
                     },
                     "name": {
                        "type": "string",
                        "description": "Name of the registry entry in the above C(path) parameters.\nIf not provided, or empty then the '(Default)' property for the key will be used."
                     },
                     "entry": {
                        "type": "string",
                        "description": "Name of the registry entry in the above C(path) parameters.\nIf not provided, or empty then the '(Default)' property for the key will be used."
                     },
                     "data": {
                        "type": "string",
                        "description": "Value of the registry entry C(name) in C(path).\nIf not specified then the value for the property will be null for the corresponding C(type).\nBinary and None data should be expressed in a yaml byte array or as comma separated hex values.\nAn easy way to generate this is to run C(regedit.exe) and use the I(export) option to save the registry values to a file.\nIn the exported file, binary value will look like C(hex:be,ef,be,ef), the C(hex:) prefix is optional.\nDWORD and QWORD values should either be represented as a decimal number or a hex value.\nMultistring values should be passed in as a list.\nSee the examples for more details on how to format this data."
                     },
                     "type": {
                        "type": "string",
                        "description": "Default: string\n\nThe registry value data type.",
                        "enum": [
                           "binary",
                           "dword",
                           "expandstring",
                           "multistring",
                           "string",
                           "qword"
                        ]
                     },
                     "datatype": {
                        "type": "string",
                        "description": "Default: string\n\nThe registry value data type.",
                        "enum": [
                           "binary",
                           "dword",
                           "expandstring",
                           "multistring",
                           "string",
                           "qword"
                        ]
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nThe state of the registry entry.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "delete_key": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nWhen C(state) is 'absent' then this will delete the entire key.\nIf C(no) then it will only clear out the '(Default)' property for that key."
                     },
                     "hive": {
                        "type": "string",
                        "description": "A path to a hive key like C:\\Users\\Default\\NTUSER.DAT to load in the registry.\nThis hive is loaded under the HKLM:\\ANSIBLE key which can then be used in I(name) like any other path.\nThis can be used to load the default user profile registry hive or any other hive saved as a file.\nUsing this function requires the user to have the C(SeRestorePrivilege) and C(SeBackupPrivilege) privileges enabled."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "path",
                                    "key"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "path"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "key"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "entry"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "type",
                                    "datatype"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "win_reg_stat": {
                  "type": "object",
                  "description": "Like M(win_file), M(win_reg_stat) will return whether the key/property exists.\nIt also returns the sub keys and properties of the key specified.\nIf specifying a property name through I(property), it will return the information specific for that property.",
                  "properties": {
                     "path": {
                        "type": "string",
                        "description": "The full registry key path including the hive to search for."
                     },
                     "key": {
                        "type": "string",
                        "description": "The full registry key path including the hive to search for."
                     },
                     "name": {
                        "type": "string",
                        "description": "The registry property name to get information for, the return json will not include the sub_keys and properties entries for the I(key) specified.\nSet to an empty string to target the registry key's C((Default)) property value."
                     },
                     "entry": {
                        "type": "string",
                        "description": "The registry property name to get information for, the return json will not include the sub_keys and properties entries for the I(key) specified.\nSet to an empty string to target the registry key's C((Default)) property value."
                     },
                     "value": {
                        "type": "string",
                        "description": "The registry property name to get information for, the return json will not include the sub_keys and properties entries for the I(key) specified.\nSet to an empty string to target the registry key's C((Default)) property value."
                     },
                     "property": {
                        "type": "string",
                        "description": "The registry property name to get information for, the return json will not include the sub_keys and properties entries for the I(key) specified.\nSet to an empty string to target the registry key's C((Default)) property value."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "path",
                                    "key"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "path"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "key"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "entry",
                                    "value",
                                    "property"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "win_reboot": {
                  "type": "object",
                  "description": "Reboot a Windows machine, wait for it to go down, come back up, and respond to commands.\nFor non-Windows targets, use the M(reboot) module instead.",
                  "properties": {
                     "pre_reboot_delay": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 2\n\nSeconds to wait before reboot. Passed as a parameter to the reboot command."
                     },
                     "pre_reboot_delay_sec": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 2\n\nSeconds to wait before reboot. Passed as a parameter to the reboot command."
                     },
                     "post_reboot_delay": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Seconds to wait after the reboot command was successful before attempting to validate the system rebooted successfully.\nThis is useful if you want wait for something to settle despite your connection already working."
                     },
                     "post_reboot_delay_sec": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Seconds to wait after the reboot command was successful before attempting to validate the system rebooted successfully.\nThis is useful if you want wait for something to settle despite your connection already working."
                     },
                     "shutdown_timeout": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 600\n\nMaximum seconds to wait for shutdown to occur.\nIncrease this timeout for very slow hardware, large update applications, etc.\nThis option has been removed since Ansible 2.5 as the win_reboot behavior has changed."
                     },
                     "shutdown_timeout_sec": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 600\n\nMaximum seconds to wait for shutdown to occur.\nIncrease this timeout for very slow hardware, large update applications, etc.\nThis option has been removed since Ansible 2.5 as the win_reboot behavior has changed."
                     },
                     "reboot_timeout": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 600\n\nMaximum seconds to wait for machine to re-appear on the network and respond to a test command.\nThis timeout is evaluated separately for both reboot verification and test command success so maximum clock time is actually twice this value."
                     },
                     "reboot_timeout_sec": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 600\n\nMaximum seconds to wait for machine to re-appear on the network and respond to a test command.\nThis timeout is evaluated separately for both reboot verification and test command success so maximum clock time is actually twice this value."
                     },
                     "connect_timeout": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 5\n\nMaximum seconds to wait for a single successful TCP connection to the WinRM endpoint before trying again."
                     },
                     "connect_timeout_sec": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 5\n\nMaximum seconds to wait for a single successful TCP connection to the WinRM endpoint before trying again."
                     },
                     "test_command": {
                        "type": "string",
                        "description": "Default: whoami\n\nCommand to expect success for to determine the machine is ready for management."
                     },
                     "msg": {
                        "type": "string",
                        "description": "Default: Reboot initiated by Ansible\n\nMessage to display to users."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "pre_reboot_delay",
                                    "pre_reboot_delay_sec"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "post_reboot_delay",
                                    "post_reboot_delay_sec"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "shutdown_timeout",
                                    "shutdown_timeout_sec"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "reboot_timeout",
                                    "reboot_timeout_sec"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "connect_timeout",
                                    "connect_timeout_sec"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "win_rds_settings": {
                  "type": "object",
                  "description": "Configure general settings of a Remote Desktop Gateway server.",
                  "properties": {
                     "certificate_hash": {
                        "type": "string",
                        "description": "Certificate hash (thumbprint) for the Remote Desktop Gateway server. The certificate hash is the unique identifier for the certificate."
                     },
                     "max_connections": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "The maximum number of connections allowed.\nIf set to C(0), no new connections are allowed.\nIf set to C(-1), the number of connections is unlimited."
                     },
                     "ssl_bridging": {
                        "type": "string",
                        "description": "Specifies whether to use SSL Bridging.\nC(none): no SSL bridging.\nC(https_http): HTTPS-HTTP bridging.\nC(https_https): HTTPS-HTTPS bridging.",
                        "enum": [
                           "https_http",
                           "https_https",
                           "none"
                        ]
                     },
                     "enable_only_messaging_capable_clients": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "If enabled, only clients that support logon messages and administrator messages can connect."
                     }
                  }
               },
               "win_rds_rap": {
                  "type": "object",
                  "description": "Creates, removes and configures a Remote Desktop resource authorization policy (RD RAP).\nA RD RAP allows you to specify the network resources (computers) that users can connect to remotely through a Remote Desktop Gateway server.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the resource authorization policy."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nThe state of resource authorization policy.\nIf C(absent) will ensure the policy is removed.\nIf C(present) will ensure the policy is configured and exists.\nIf C(enabled) will ensure the policy is configured, exists and enabled.\nIf C(disabled) will ensure the policy is configured, exists, but disabled.",
                        "enum": [
                           "absent",
                           "disabled",
                           "enabled",
                           "present"
                        ]
                     },
                     "description": {
                        "type": "string",
                        "description": "Optional description of the resource authorization policy."
                     },
                     "user_groups": {
                        "type": "array",
                        "description": "List of user groups that are associated with this resource authorization policy (RAP). A user must belong to one of these groups to access the RD Gateway server.\nRequired when a new RAP is created."
                     },
                     "allowed_ports": {
                        "type": "array",
                        "description": "List of port numbers through which connections are allowed for this policy.\nTo allow connections through any port, specify 'any'."
                     },
                     "computer_group_type": {
                        "type": "string",
                        "description": "The computer group type:\nC(rdg_group): RD Gateway-managed group\nC(ad_network_resource_group): Active Directory Domain Services network resource group\nC(allow_any): Allow users to connect to any network resource.",
                        "enum": [
                           "rdg_group",
                           "ad_network_resource_group",
                           "allow_any"
                        ]
                     },
                     "computer_group": {
                        "type": "string",
                        "description": "The computer group name that is associated with this resource authorization policy (RAP).\nThis is required when I(computer_group_type) is C(rdg_group) or C(ad_network_resource_group)."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "win_rds_cap": {
                  "type": "object",
                  "description": "Creates, removes and configures a Remote Desktop connection authorization policy (RD CAP).\nA RD CAP allows you to specify the users who can connect to a Remote Desktop Gateway server.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the connection authorization policy."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nThe state of connection authorization policy.\nIf C(absent) will ensure the policy is removed.\nIf C(present) will ensure the policy is configured and exists.\nIf C(enabled) will ensure the policy is configured, exists and enabled.\nIf C(disabled) will ensure the policy is configured, exists, but disabled.",
                        "enum": [
                           "absent",
                           "enabled",
                           "disabled",
                           "present"
                        ]
                     },
                     "auth_method": {
                        "type": "string",
                        "description": "Specifies how the RD Gateway server authenticates users.\nWhen a new CAP is created, the default value is C(password).",
                        "enum": [
                           "both",
                           "none",
                           "password",
                           "smartcard"
                        ]
                     },
                     "order": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Evaluation order of the policy.\nThe CAP in which I(order) is set to a value of '1' is evaluated first.\nBy default, a newly created CAP will take the first position.\nIf the given value exceed the total number of existing policies, the policy will take the last position but the evaluation order will be capped to this number."
                     },
                     "session_timeout": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "The maximum time, in minutes, that a session can be idle.\nA value of zero disables session timeout."
                     },
                     "session_timeout_action": {
                        "type": "string",
                        "description": "Default: disconnect\n\nThe action the server takes when a session times out.\nC(disconnect): disconnect the session.\nC(reauth): silently reauthenticate and reauthorize the session.",
                        "enum": [
                           "disconnect",
                           "reauth"
                        ]
                     },
                     "idle_timeout": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Specifies the time interval, in minutes, after which an idle session is disconnected.\nA value of zero disables idle timeout."
                     },
                     "allow_only_sdrts_servers": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Specifies whether connections are allowed only to Remote Desktop Session Host servers that enforce Remote Desktop Gateway redirection policy."
                     },
                     "user_groups": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "A list of user groups that is allowed to connect to the Remote Gateway server.\nRequired when a new CAP is created."
                     },
                     "computer_groups": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "A list of computer groups that is allowed to connect to the Remote Gateway server."
                     },
                     "redirect_clipboard": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Allow clipboard redirection."
                     },
                     "redirect_drives": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Allow disk drive redirection."
                     },
                     "redirect_printers": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Allow printers redirection."
                     },
                     "redirect_serial": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Allow serial port redirection."
                     },
                     "redirect_pnp": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Allow Plug and Play devices redirection."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "win_rabbitmq_plugin": {
                  "type": "object",
                  "description": "Manage RabbitMQ plugins.",
                  "properties": {
                     "names": {
                        "type": "string",
                        "description": "Comma-separated list of plugin names."
                     },
                     "name": {
                        "type": "string",
                        "description": "Comma-separated list of plugin names."
                     },
                     "new_only": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Only enable missing plugins.\nDoes not disable plugins that are not in the names list."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: enabled\n\nSpecify if plugins are to be enabled or disabled.",
                        "enum": [
                           "disabled",
                           "enabled"
                        ]
                     },
                     "prefix": {
                        "type": "string",
                        "description": "Specify a custom install prefix to a Rabbit."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "names",
                                    "name"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "names"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "win_psrepository": {
                  "type": "object",
                  "description": "This module helps to add, remove and update Windows PowerShell repository on Windows-based systems.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the repository to work with."
                     },
                     "source": {
                        "type": "string",
                        "description": "Specifies the URI for discovering and installing modules from this repository.\nA URI can be a NuGet server feed (most common situation), HTTP, HTTPS, FTP or file location."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIf C(present) a new repository is added or updated.\nIf C(absent) a repository is removed.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "installation_policy": {
                        "type": "string",
                        "description": "Sets the C(InstallationPolicy) of a repository.\nWill default to C(trusted) when creating a new repository.",
                        "enum": [
                           "trusted",
                           "untrusted"
                        ]
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "win_psmodule": {
                  "type": "object",
                  "description": "This module helps to install Windows PowerShell modules and register custom modules repository on Windows-based systems.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the Windows PowerShell module that has to be installed."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIf C(present) a new module is installed.\nIf C(absent) a module is removed.\nIf C(latest) a module is updated to the newest version. This option was added in version 2.8.",
                        "enum": [
                           "absent",
                           "latest",
                           "present"
                        ]
                     },
                     "required_version": {
                        "type": "string",
                        "description": "The exact version of the PowerShell module that has to be installed."
                     },
                     "minimum_version": {
                        "type": "string",
                        "description": "The minimum version of the PowerShell module that has to be installed."
                     },
                     "maximum_version": {
                        "type": "string",
                        "description": "The maximum version of the PowerShell module that has to be installed."
                     },
                     "allow_clobber": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "If C(yes) allows install modules that contains commands those have the same names as commands that already exists."
                     },
                     "skip_publisher_check": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "If C(yes), allows you to install a different version of a module that already exists on your computer in the case when a different one is not digitally signed by a trusted publisher and the newest existing module is digitally signed by a trusted publisher."
                     },
                     "allow_prerelease": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "If C(yes) installs modules marked as prereleases.\nIt doesn't work with the parameters C(minimum_version) and/or C(maximum_version).\nIt doesn't work with the C(state) set to absent."
                     },
                     "repository": {
                        "type": "string",
                        "description": "Name of the custom repository to use."
                     },
                     "url": {
                        "type": "string",
                        "description": "URL of the custom repository to register.\nThis option is deprecated and will be removed in Ansible 2.12. Use the M(win_psrepository) module instead."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "win_psexec": {
                  "type": "object",
                  "description": "Run commands (remotely) through the PsExec service.\nRun commands as another (domain) user (with elevated privileges).",
                  "properties": {
                     "command": {
                        "type": "string",
                        "description": "The command line to run through PsExec (limited to 260 characters)."
                     },
                     "executable": {
                        "type": "string",
                        "description": "Default: psexec.exe\n\nThe location of the PsExec utility (in case it is not located in your PATH)."
                     },
                     "extra_opts": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Specify additional options to add onto the PsExec invocation.\nThis module was undocumented in older releases and will be removed in Ansible 2.10."
                     },
                     "hostnames": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "The hostnames to run the command.\nIf not provided, the command is run locally."
                     },
                     "username": {
                        "type": "string",
                        "description": "The (remote) user to run the command as.\nIf not provided, the current user is used."
                     },
                     "password": {
                        "type": "string",
                        "description": "The password for the (remote) user to run the command as.\nThis is mandatory in order authenticate yourself."
                     },
                     "chdir": {
                        "type": "string",
                        "description": "Run the command from this (remote) directory."
                     },
                     "nobanner": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Do not display the startup banner and copyright message.\nThis only works for specific versions of the PsExec binary."
                     },
                     "noprofile": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Run the command without loading the account's profile."
                     },
                     "elevated": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Run the command with elevated privileges."
                     },
                     "interactive": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Run the program so that it interacts with the desktop on the remote system."
                     },
                     "session": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Specifies the session ID to use.\nThis parameter works in conjunction with I(interactive).\nIt has no effect when I(interactive) is set to C(no)."
                     },
                     "limited": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Run the command as limited user (strips the Administrators group and allows only privileges assigned to the Users group)."
                     },
                     "system": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Run the remote command in the System account."
                     },
                     "priority": {
                        "type": "string",
                        "description": "Used to run the command at a different priority.",
                        "enum": [
                           "abovenormal",
                           "background",
                           "belownormal",
                           "high",
                           "low",
                           "realtime"
                        ]
                     },
                     "timeout": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "The connection timeout in seconds"
                     },
                     "wait": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nWait for the application to terminate.\nOnly use for non-interactive applications."
                     }
                  },
                  "required": [
                     "command"
                  ]
               },
               "win_product_facts": {
                  "type": "object",
                  "description": "Provides Windows product and license information.",
                  "properties": {}
               },
               "win_power_plan": {
                  "type": "object",
                  "description": "This module will change the power plan of a Windows system to the defined string.\nWindows defaults to C(balanced) which will cause CPU throttling. In some cases it can be preferable to change the mode to C(high performance) to increase CPU performance.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "String value that indicates the desired power plan.\nThe power plan must already be present on the system.\nCommonly there will be options for C(balanced) and C(high performance)."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "win_ping": {
                  "type": "object",
                  "description": "Checks management connectivity of a windows host.\nThis is NOT ICMP ping, this is just a trivial test module.\nFor non-Windows targets, use the M(ping) module instead.\nFor Network targets, use the M(net_ping) module instead.",
                  "properties": {
                     "data": {
                        "type": "string",
                        "description": "Default: pong\n\nAlternate data to return instead of 'pong'.\nIf this parameter is set to C(crash), the module will cause an exception."
                     }
                  }
               },
               "win_pester": {
                  "type": "object",
                  "description": "Run Pester tests on Windows hosts.\nTest files have to be available on the remote host.",
                  "properties": {
                     "path": {
                        "type": "string",
                        "description": "Path to a pester test file or a folder where tests can be found.\nIf the path is a folder, the module will consider all ps1 files as Pester tests."
                     },
                     "tags": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Runs only tests in Describe blocks with specified Tags values.\nAccepts multiple comma separated tags."
                     },
                     "test_parameters": {
                        "type": "object",
                        "description": "Allows to specify parameters to the test script."
                     },
                     "version": {
                        "type": "string",
                        "description": "Minimum version of the pester module that has to be available on the remote host."
                     }
                  },
                  "required": [
                     "path"
                  ]
               },
               "win_path": {
                  "type": "object",
                  "description": "Allows element-based ordering, addition, and removal of Windows path environment variables.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Default: PATH\n\nTarget path environment variable name."
                     },
                     "elements": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "A single path element, or a list of path elements (ie, directories) to add or remove.\nWhen multiple elements are included in the list (and C(state) is C(present)), the elements are guaranteed to appear in the same relative order in the resultant path value.\nVariable expansions (eg, C(%VARNAME%)) are allowed, and are stored unexpanded in the target path element.\nAny existing path elements not mentioned in C(elements) are always preserved in their current order.\nNew path elements are appended to the path, and existing path elements may be moved closer to the end to satisfy the requested ordering.\nPaths are compared in a case-insensitive fashion, and trailing backslashes are ignored for comparison purposes. However, note that trailing backslashes in YAML require quotes."
                     },
                     "state": {
                        "type": "string",
                        "description": "Whether the path elements specified in C(elements) should be present or absent.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "scope": {
                        "type": "string",
                        "description": "Default: machine\n\nThe level at which the environment variable specified by C(name) should be managed (either for the current user or global machine scope).",
                        "enum": [
                           "machine",
                           "user"
                        ]
                     }
                  },
                  "required": [
                     "elements"
                  ]
               },
               "win_partition": {
                  "type": "object",
                  "description": "The M(win_partition) module can create, modify or delete a partition on a disk",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nUsed to specify the state of the partition. Use C(absent) to specify if a partition should be removed and C(present) to specify if the partition should be created or updated.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "drive_letter": {
                        "type": "string",
                        "description": "Used for accessing partitions if I(disk_number) and I(partition_number) are not provided.\nUse C(auto) for automatically assigning a drive letter, or a letter A-Z for manually assigning a drive letter to a new partition. If not specified, no drive letter is assigned when creating a new partition."
                     },
                     "disk_number": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Disk number is mandatory for creating new partitions.\nA combination of I(disk_number) and I(partition_number) can be used to specify the partition instead of I(drive_letter) if required."
                     },
                     "partition_number": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Used in conjunction with I(disk_number) to uniquely identify a partition."
                     },
                     "partition_size": {
                        "type": "string",
                        "description": "Specify size of the partition in B, KB, KiB, MB, MiB, GB, GiB, TB or TiB. Use -1 to specify maximum supported size.\nPartition size is mandatory for creating a new partition but not for updating or deleting a partition.\nThe decimal SI prefixes kilo, mega, giga, tera, etc., are powers of 10^3 = 1000. The binary prefixes kibi, mebi, gibi, tebi, etc. respectively refer to the corresponding power of 2^10 = 1024. Thus, a gigabyte (GB) is 1000000000 (1000^3) bytes while 1 gibibyte (GiB) is 1073741824 (1024^3) bytes."
                     },
                     "read_only": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Make the partition read only, restricting changes from being made to the partition."
                     },
                     "active": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Specifies if the partition is active and can be used to start the system. This property is only valid when the disk's partition style is MBR."
                     },
                     "hidden": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Hides the target partition, making it undetectable by the mount manager."
                     },
                     "offline": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Sets the partition offline.\nAdding a mount point (such as a drive letter) will cause the partition to go online again."
                     },
                     "mbr_type": {
                        "type": "string",
                        "description": "Specify the partition's MBR type if the disk's partition style is MBR.\nThis only applies to new partitions.\nThis does not relate to the partitions file system formatting.",
                        "enum": [
                           "fat12",
                           "fat16",
                           "extended",
                           "huge",
                           "ifs",
                           "fat32"
                        ]
                     },
                     "gpt_type": {
                        "type": "string",
                        "description": "Specify the partition's GPT type if the disk's partition style is GPT.\nThis only applies to new partitions.\nThis does not relate to the partitions file system formatting.",
                        "enum": [
                           "system_partition",
                           "microsoft_reserved",
                           "basic_data",
                           "microsoft_recovery"
                        ]
                     }
                  }
               },
               "win_pagefile": {
                  "type": "object",
                  "description": "Query current pagefile configuration.\nEnable/Disable AutomaticManagedPagefile.\nCreate new or override pagefile configuration.",
                  "properties": {
                     "drive": {
                        "type": "string",
                        "description": "The drive of the pagefile."
                     },
                     "initial_size": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "The initial size of the pagefile in megabytes."
                     },
                     "maximum_size": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "The maximum size of the pagefile in megabytes."
                     },
                     "override": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nOverride the current pagefile on the drive."
                     },
                     "system_managed": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Configures current pagefile to be managed by the system."
                     },
                     "automatic": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Configures AutomaticManagedPagefile for the entire system."
                     },
                     "remove_all": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Remove all pagefiles in the system, not including automatic managed."
                     },
                     "test_path": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nUse Test-Path on the drive to make sure the drive is accessible before creating the pagefile."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: query\n\nState of the pagefile.",
                        "enum": [
                           "absent",
                           "present",
                           "query"
                        ]
                     }
                  }
               },
               "win_package": {
                  "type": "object",
                  "description": "Installs or uninstalls a package in either an MSI or EXE format.\nThese packages can be sources from the local file system, network file share or a url.\nPlease read the notes section around some caveats with this module.",
                  "properties": {
                     "arguments": {
                        "type": "string",
                        "description": "Any arguments the installer needs to either install or uninstall the package.\nIf the package is an MSI do not supply the C(/qn), C(/log) or C(/norestart) arguments.\nAs of Ansible 2.5, this parameter can be a list of arguments and the module will escape the arguments as necessary, it is recommended to use a string when dealing with MSI packages due to the unique escaping issues with msiexec."
                     },
                     "chdir": {
                        "type": "string",
                        "description": "Set the specified path as the current working directory before installing or uninstalling a package."
                     },
                     "creates_path": {
                        "type": "string",
                        "description": "Will check the existence of the path specified and use the result to determine whether the package is already installed.\nYou can use this in conjunction with C(product_id) and other C(creates_*)."
                     },
                     "creates_service": {
                        "type": "string",
                        "description": "Will check the existing of the service specified and use the result to determine whether the package is already installed.\nYou can use this in conjunction with C(product_id) and other C(creates_*)."
                     },
                     "creates_version": {
                        "type": "string",
                        "description": "Will check the file version property of the file at C(creates_path) and use the result to determine whether the package is already installed.\nC(creates_path) MUST be set and is a file.\nYou can use this in conjunction with C(product_id) and other C(creates_*)."
                     },
                     "expected_return_code": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Default: [0, 3010]\n\nOne or more return codes from the package installation that indicates success.\nBefore Ansible 2.4 this was just 0 but since Ansible 2.4 this is both C(0) and C(3010).\nA return code of C(3010) usually means that a reboot is required, the C(reboot_required) return value is set if the return code is C(3010)."
                     },
                     "password": {
                        "type": "string",
                        "description": "The password for C(user_name), must be set when C(user_name) is."
                     },
                     "user_password": {
                        "type": "string",
                        "description": "The password for C(user_name), must be set when C(user_name) is."
                     },
                     "path": {
                        "type": "string",
                        "description": "Location of the package to be installed or uninstalled.\nThis package can either be on the local file system, network share or a url.\nIf the path is on a network share and the current WinRM transport doesn't support credential delegation, then C(user_name) and C(user_password) must be set to access the file.\nThere are cases where this file will be copied locally to the server so it can access it, see the notes for more info.\nIf C(state=present) then this value MUST be set.\nIf C(state=absent) then this value does not need to be set if C(product_id) is."
                     },
                     "product_id": {
                        "type": "string",
                        "description": "The product id of the installed packaged.\nThis is used for checking whether the product is already installed and getting the uninstall information if C(state=absent).\nYou can find product ids for installed programs in the Windows registry editor either at C(HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall) or for 32 bit programs at C(HKLM:Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall).\nThis SHOULD be set when the package is not an MSI, or the path is a url or a network share and credential delegation is not being used. The C(creates_*) options can be used instead but is not recommended."
                     },
                     "productid": {
                        "type": "string",
                        "description": "The product id of the installed packaged.\nThis is used for checking whether the product is already installed and getting the uninstall information if C(state=absent).\nYou can find product ids for installed programs in the Windows registry editor either at C(HKLM:Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall) or for 32 bit programs at C(HKLM:Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall).\nThis SHOULD be set when the package is not an MSI, or the path is a url or a network share and credential delegation is not being used. The C(creates_*) options can be used instead but is not recommended."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether to install or uninstall the package.\nThe module uses C(product_id) and whether it exists at the registry path to see whether it needs to install or uninstall the package.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "ensure": {
                        "type": "string",
                        "description": "Default: present\n\nWhether to install or uninstall the package.\nThe module uses C(product_id) and whether it exists at the registry path to see whether it needs to install or uninstall the package.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "username": {
                        "type": "string",
                        "description": "Username of an account with access to the package if it is located on a file share.\nThis is only needed if the WinRM transport is over an auth method that does not support credential delegation like Basic or NTLM."
                     },
                     "user_name": {
                        "type": "string",
                        "description": "Username of an account with access to the package if it is located on a file share.\nThis is only needed if the WinRM transport is over an auth method that does not support credential delegation like Basic or NTLM."
                     },
                     "validate_certs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nIf C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates.\nBefore Ansible 2.4 this defaulted to C(no)."
                     },
                     "log_path": {
                        "type": "string",
                        "description": "Specifies the path to a log file that is persisted after an MSI package is installed or uninstalled.\nWhen omitted, a temporary log file is used for MSI packages.\nThis is only valid for MSI files, use C(arguments) for other package types."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "password",
                                    "user_password"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "product_id",
                                    "productid"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "state",
                                    "ensure"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "username",
                                    "user_name"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "win_owner": {
                  "type": "object",
                  "description": "Set owner of files or directories.",
                  "properties": {
                     "path": {
                        "type": "string",
                        "description": "Path to be used for changing owner."
                     },
                     "user": {
                        "type": "string",
                        "description": "Name to be used for changing owner."
                     },
                     "recurse": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Indicates if the owner should be changed recursively."
                     }
                  },
                  "required": [
                     "path",
                     "user"
                  ]
               },
               "win_optional_feature": {
                  "type": "object",
                  "description": "Install or uninstall optional Windows features on non-Server Windows.\nThis module uses the C(Enable-WindowsOptionalFeature) and C(Disable-WindowsOptionalFeature) cmdlets.",
                  "properties": {
                     "name": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "The name(s) of the feature to install.\nThis relates to C(FeatureName) in the Powershell cmdlet.\nTo list all available features use the PowerShell command C(Get-WindowsOptionalFeature)."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether to ensure the feature is absent or present on the system.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "include_parent": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether to enable the parent feature and the parent's dependencies."
                     },
                     "source": {
                        "type": "string",
                        "description": "Specify a source to install the feature from.\nCan either be C({driveletter}:\\sources\\sxs) or C(\\\\{IP}\\share\\sources\\sxs)."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "win_nssm": {
                  "type": "object",
                  "description": "Install a Windows service using the NSSM wrapper.\nNSSM is a service helper which doesn't suck. See U(https://nssm.cc/) for more information.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the service to operate on."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nState of the service on the system.\nValues C(started), C(stopped), and C(restarted) are deprecated since v2.8, please use the M(win_service) module instead to start, stop or restart the service.",
                        "enum": [
                           "absent",
                           "present",
                           "started",
                           "stopped",
                           "restarted"
                        ]
                     },
                     "application": {
                        "type": "string",
                        "description": "The application binary to run as a service\nRequired when I(state) is C(present), C(started), C(stopped), or C(restarted)."
                     },
                     "executable": {
                        "type": "string",
                        "description": "Default: nssm.exe\n\nThe location of the NSSM utility (in case it is not located in your PATH)."
                     },
                     "description": {
                        "type": "string",
                        "description": "The description to set for the service."
                     },
                     "display_name": {
                        "type": "string",
                        "description": "The display name to set for the service."
                     },
                     "working_directory": {
                        "type": "string",
                        "description": "The working directory to run the service executable from (defaults to the directory containing the application binary)"
                     },
                     "app_directory": {
                        "type": "string",
                        "description": "The working directory to run the service executable from (defaults to the directory containing the application binary)"
                     },
                     "chdir": {
                        "type": "string",
                        "description": "The working directory to run the service executable from (defaults to the directory containing the application binary)"
                     },
                     "stdout_file": {
                        "type": "string",
                        "description": "Path to receive output."
                     },
                     "stderr_file": {
                        "type": "string",
                        "description": "Path to receive error output."
                     },
                     "app_parameters": {
                        "type": "string",
                        "description": "A string representing a dictionary of parameters to be passed to the application when it starts.\nDEPRECATED since v2.8, please use I(arguments) instead.\nThis is mutually exclusive with I(arguments)."
                     },
                     "arguments": {
                        "type": "string",
                        "description": "Parameters to be passed to the application when it starts.\nThis can be either a simple string or a list.\nThis parameter was renamed from I(app_parameters_free_form) in 2.8.\nThis is mutually exclusive with I(app_parameters)."
                     },
                     "app_parameters_free_form": {
                        "type": "string",
                        "description": "Parameters to be passed to the application when it starts.\nThis can be either a simple string or a list.\nThis parameter was renamed from I(app_parameters_free_form) in 2.8.\nThis is mutually exclusive with I(app_parameters)."
                     },
                     "dependencies": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Service dependencies that has to be started to trigger startup, separated by comma.\nDEPRECATED since v2.8, please use the M(win_service) module instead."
                     },
                     "user": {
                        "type": "string",
                        "description": "User to be used for service startup.\nDEPRECATED since v2.8, please use the M(win_service) module instead."
                     },
                     "password": {
                        "type": "string",
                        "description": "Password to be used for service startup.\nDEPRECATED since v2.8, please use the M(win_service) module instead."
                     },
                     "start_mode": {
                        "type": "string",
                        "description": "Default: auto\n\nIf C(auto) is selected, the service will start at bootup.\nC(delayed) causes a delayed but automatic start after boot (added in version 2.5).\nC(manual) means that the service will start only when another service needs it.\nC(disabled) means that the service will stay off, regardless if it is needed or not.\nDEPRECATED since v2.8, please use the M(win_service) module instead.",
                        "enum": [
                           "auto",
                           "delayed",
                           "disabled",
                           "manual"
                        ]
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "working_directory",
                                    "app_directory",
                                    "chdir"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "arguments",
                                    "app_parameters_free_form"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "win_netbios": {
                  "type": "object",
                  "description": "Enables or disables NetBIOS on Windows network adapters.\nCan be used to protect a system against NBT-NS poisoning and avoid NBNS broadcast storms.\nSettings can be applied system wide or per adapter.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Whether NetBIOS should be enabled, disabled, or default (use setting from DHCP server or if static IP address is assigned enable NetBIOS).",
                        "enum": [
                           "enabled",
                           "disabled",
                           "default"
                        ]
                     },
                     "adapter_names": {
                        "type": "array",
                        "description": "List of adapter names for which to manage NetBIOS settings. If this option is omitted then configuration is applied to all adapters on the system.\nThe adapter name used is the connection caption in the Network Control Panel or via C(Get-NetAdapter), eg C(Ethernet 2)."
                     }
                  },
                  "required": [
                     "state"
                  ]
               },
               "win_msg": {
                  "type": "object",
                  "description": "Wraps the msg.exe command in order to send messages to Windows hosts.",
                  "properties": {
                     "to": {
                        "type": "string",
                        "description": "Default: *\n\nWho to send the message to. Can be a username, sessionname or sessionid."
                     },
                     "display_seconds": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 10\n\nHow long to wait for receiver to acknowledge message, in seconds."
                     },
                     "wait": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nWhether to wait for users to respond.  Module will only wait for the number of seconds specified in display_seconds or 10 seconds if not specified. However, if I(wait) is C(yes), the message is sent to each logged on user in turn, waiting for the user to either press 'ok' or for the timeout to elapse before moving on to the next user."
                     },
                     "msg": {
                        "type": "string",
                        "description": "Default: Hello world!\n\nThe text of the message to be displayed.\nThe message must be less than 256 characters."
                     }
                  }
               },
               "win_mapped_drive": {
                  "type": "object",
                  "description": "Allows you to modify mapped network drives for individual users.\nAlso support WebDAV endpoints in the UNC form.",
                  "properties": {
                     "letter": {
                        "type": "string",
                        "description": "The letter of the network path to map to.\nThis letter must not already be in use with Windows."
                     },
                     "password": {
                        "type": "string",
                        "description": "The password for C(username) that is used when testing the initial connection.\nThis is never saved with a mapped drive, use the M(win_credential) module to persist a username and password for a host."
                     },
                     "path": {
                        "type": "string",
                        "description": "The UNC path to map the drive to.\nIf pointing to a WebDAV location this must still be in a UNC path in the format C(\\\\hostname\\path) and not a URL, see examples for more details.\nTo specify a C(https) WebDAV path, add C(@SSL) after the hostname. To specify a custom WebDAV port add C(@<port num>) after the C(@SSL) or hostname portion of the UNC path, e.g. C(\\\\server@SSL@1234) or C(\\\\server@1234).\nThis is required if C(state=present).\nIf C(state=absent) and I(path) is not set, the module will delete the mapped drive regardless of the target.\nIf C(state=absent) and the I(path) is set, the module will throw an error if path does not match the target of the mapped drive."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIf C(present) will ensure the mapped drive exists.\nIf C(absent) will ensure the mapped drive does not exist.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "username": {
                        "type": "string",
                        "description": "The username that is used when testing the initial connection.\nThis is never saved with a mapped drive, the the M(win_credential) module to persist a username and password for a host.\nThis is required if the mapped drive requires authentication with custom credentials and become, or CredSSP cannot be used.\nIf become or CredSSP is used, any credentials saved with M(win_credential) will automatically be used instead."
                     }
                  },
                  "required": [
                     "letter"
                  ]
               },
               "win_lineinfile": {
                  "type": "object",
                  "description": "This module will search a file for a line, and ensure that it is present or absent.\nThis is primarily useful when you want to change a single line in a file only.",
                  "properties": {
                     "path": {
                        "type": "string",
                        "description": "The path of the file to modify.\nNote that the Windows path delimiter C(\\) must be escaped as C(\\\\) when the line is double quoted.\nBefore Ansible 2.3 this option was only usable as I(dest), I(destfile) and I(name)."
                     },
                     "dest": {
                        "type": "string",
                        "description": "The path of the file to modify.\nNote that the Windows path delimiter C(\\) must be escaped as C(\\\\) when the line is double quoted.\nBefore Ansible 2.3 this option was only usable as I(dest), I(destfile) and I(name)."
                     },
                     "destfile": {
                        "type": "string",
                        "description": "The path of the file to modify.\nNote that the Windows path delimiter C(\\) must be escaped as C(\\\\) when the line is double quoted.\nBefore Ansible 2.3 this option was only usable as I(dest), I(destfile) and I(name)."
                     },
                     "name": {
                        "type": "string",
                        "description": "The path of the file to modify.\nNote that the Windows path delimiter C(\\) must be escaped as C(\\\\) when the line is double quoted.\nBefore Ansible 2.3 this option was only usable as I(dest), I(destfile) and I(name)."
                     },
                     "backup": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Determine whether a backup should be created.\nWhen set to C(yes), create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly."
                     },
                     "regex": {
                        "type": "string",
                        "description": "The regular expression to look for in every line of the file. For C(state=present), the pattern to replace if found; only the last line found will be replaced. For C(state=absent), the pattern of the line to remove. Uses .NET compatible regular expressions; see U(https://msdn.microsoft.com/en-us/library/hs600312%28v=vs.110%29.aspx)."
                     },
                     "regexp": {
                        "type": "string",
                        "description": "The regular expression to look for in every line of the file. For C(state=present), the pattern to replace if found; only the last line found will be replaced. For C(state=absent), the pattern of the line to remove. Uses .NET compatible regular expressions; see U(https://msdn.microsoft.com/en-us/library/hs600312%28v=vs.110%29.aspx)."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the line should be there or not.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "line": {
                        "type": "string",
                        "description": "Required for C(state=present). The line to insert/replace into the file. If C(backrefs) is set, may contain backreferences that will get expanded with the C(regexp) capture groups if the regexp matches.\nBe aware that the line is processed first on the controller and thus is dependent on yaml quoting rules. Any double quoted line will have control characters, such as '\\r\\n', expanded. To print such characters literally, use single or no quotes."
                     },
                     "backrefs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Used with C(state=present). If set, line can contain backreferences (both positional and named) that will get populated if the C(regexp) matches. This flag changes the operation of the module slightly; C(insertbefore) and C(insertafter) will be ignored, and if the C(regexp) doesn't match anywhere in the file, the file will be left unchanged.\nIf the C(regexp) does match, the last matching line will be replaced by the expanded line parameter."
                     },
                     "insertafter": {
                        "type": "string",
                        "description": "Default: EOF\n\nUsed with C(state=present). If specified, the line will be inserted after the last match of specified regular expression. A special value is available; C(EOF) for inserting the line at the end of the file.\nIf specified regular expression has no matches, EOF will be used instead. May not be used with C(backrefs).",
                        "enum": [
                           "EOF",
                           "*regex*"
                        ]
                     },
                     "insertbefore": {
                        "type": "string",
                        "description": "Used with C(state=present). If specified, the line will be inserted before the last match of specified regular expression. A value is available; C(BOF) for inserting the line at the beginning of the file.\nIf specified regular expression has no matches, the line will be inserted at the end of the file. May not be used with C(backrefs).",
                        "enum": [
                           "BOF",
                           "*regex*"
                        ]
                     },
                     "create": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Used with C(state=present). If specified, the file will be created if it does not already exist. By default it will fail if the file is missing."
                     },
                     "validate": {
                        "type": "string",
                        "description": "Validation to run before copying into place. Use %s in the command to indicate the current file to validate.\nThe command is passed securely so shell features like expansion and pipes won't work."
                     },
                     "encoding": {
                        "type": "string",
                        "description": "Default: auto\n\nSpecifies the encoding of the source text file to operate on (and thus what the output encoding will be). The default of C(auto) will cause the module to auto-detect the encoding of the source file and ensure that the modified file is written with the same encoding.\nAn explicit encoding can be passed as a string that is a valid value to pass to the .NET framework System.Text.Encoding.GetEncoding() method - see U(https://msdn.microsoft.com/en-us/library/system.text.encoding%28v=vs.110%29.aspx).\nThis is mostly useful with C(create=yes) if you want to create a new file with a specific encoding. If C(create=yes) is specified without a specific encoding, the default encoding (UTF-8, no BOM) will be used."
                     },
                     "newline": {
                        "type": "string",
                        "description": "Default: windows\n\nSpecifies the line separator style to use for the modified file. This defaults to the windows line separator (C(\\r\\n)). Note that the indicated line separator will be used for file output regardless of the original line separator that appears in the input file.",
                        "enum": [
                           "unix",
                           "windows"
                        ]
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "path",
                                    "dest",
                                    "destfile",
                                    "name"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "path"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "dest"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "destfile"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "regex",
                                    "regexp"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "win_inet_proxy": {
                  "type": "object",
                  "description": "Used to set or remove proxy settings for Windows INet which includes Internet Explorer.\nWinINet is a framework used by interactive applications to submit web requests through.\nThe proxy settings can also be used by other applications like Firefox, Chrome, and others but there is no definitive list.",
                  "properties": {
                     "auto_detect": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nWhether to configure WinINet to automatically detect proxy settings through Web Proxy Auto-Detection C(WPAD).\nThis corresponds to the checkbox I(Automatically detect settings) in the connection settings window."
                     },
                     "auto_config_url": {
                        "type": "string",
                        "description": "The URL of a proxy configuration script.\nProxy configuration scripts are typically JavaScript files with the C(.pac) extension that implement the C(FindProxyForURL(url, host) function.\nOmit, set to null or an empty string to remove the auto config URL.\nThis corresponds to the checkbox I(Use automatic configuration script) in the connection settings window."
                     },
                     "bypass": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "A list of hosts that will bypass the set proxy when being accessed.\nUse C(<local>) to match hostnames that are not fully qualified domain names. This is useful when needing to connect to intranet sites using just the hostname. If defined, this should be the last entry in the bypass list.\nUse C(<-loopback>) to stop automatically bypassing the proxy when connecting through any loopback address like C(127.0.0.1), C(localhost), or the local hostname.\nOmit, set to null or an empty string/list to remove the bypass list.\nIf this is set then I(proxy) must also be set."
                     },
                     "connection": {
                        "type": "string",
                        "description": "The name of the IE connection to set the proxy settings for.\nThese are the connections under the I(Dial-up and Virtual Private Network) header in the IE settings.\nWhen omitted, the default LAN connection is used."
                     },
                     "proxy": {
                        "type": "string",
                        "description": "A string or dict that specifies the proxy to be set.\nIf setting a string, should be in the form C(hostname), C(hostname:port), or C(protocol=hostname:port).\nIf the port is undefined, the default port for the protocol in use is used.\nIf setting a dict, the keys should be the protocol and the values should be the hostname and/or port for that protocol.\nValid protocols are C(http), C(https), C(ftp), and C(socks).\nOmit, set to null or an empty string to remove the proxy settings."
                     }
                  }
               },
               "win_iis_website": {
                  "type": "object",
                  "description": "Creates, Removes and configures a IIS Web site.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Names of web site."
                     },
                     "site_id": {
                        "type": "string",
                        "description": "Explicitly set the IIS numeric ID for a site.\nNote that this value cannot be changed after the website has been created."
                     },
                     "state": {
                        "type": "string",
                        "description": "State of the web site",
                        "enum": [
                           "absent",
                           "started",
                           "stopped",
                           "restarted"
                        ]
                     },
                     "physical_path": {
                        "type": "string",
                        "description": "The physical path on the remote host to use for the new site.\nThe specified folder must already exist."
                     },
                     "application_pool": {
                        "type": "string",
                        "description": "The application pool in which the new site executes."
                     },
                     "port": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "The port to bind to / use for the new site."
                     },
                     "ip": {
                        "type": "string",
                        "description": "The IP address to bind to / use for the new site."
                     },
                     "hostname": {
                        "type": "string",
                        "description": "The host header to bind to / use for the new site."
                     },
                     "ssl": {
                        "type": "string",
                        "description": "Enables HTTPS binding on the site.."
                     },
                     "parameters": {
                        "type": "string",
                        "description": "Custom site Parameters from string where properties are separated by a pipe and property name/values by colon Ex. \"foo:1|bar:2\""
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "win_iis_webbinding": {
                  "type": "object",
                  "description": "Creates, removes and configures a binding to an existing IIS Web site.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Names of web site."
                     },
                     "website": {
                        "type": "string",
                        "description": "Names of web site."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nState of the binding.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "port": {
                        "type": "string",
                        "description": "Default: 80\n\nThe port to bind to / use for the new site."
                     },
                     "ip": {
                        "type": "string",
                        "description": "Default: *\n\nThe IP address to bind to / use for the new site."
                     },
                     "host_header": {
                        "type": "string",
                        "description": "The host header to bind to / use for the new site.\nIf you are creating/removing a catch-all binding, omit this parameter rather than defining it as '*'."
                     },
                     "protocol": {
                        "type": "string",
                        "description": "Default: http\n\nThe protocol to be used for the Web binding (usually HTTP, HTTPS, or FTP)."
                     },
                     "certificate_hash": {
                        "type": "string",
                        "description": "Certificate hash (thumbprint) for the SSL binding. The certificate hash is the unique identifier for the certificate."
                     },
                     "certificate_store_name": {
                        "type": "string",
                        "description": "Default: my\n\nName of the certificate store where the certificate for the binding is located."
                     },
                     "ssl_flags": {
                        "type": "string",
                        "description": "This parameter is only valid on Server 2012 and newer.\nPrimarily used for enabling and disabling server name indication (SNI).\nSet to c(0) to disable SNI.\nSet to c(1) to enable SNI."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "website"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "website"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "win_iis_webapppool": {
                  "type": "object",
                  "description": "Creates, removes and configures an IIS Web Application Pool.",
                  "properties": {
                     "attributes": {
                        "type": "string",
                        "description": "This field is a free form dictionary value for the application pool attributes.\nThese attributes are based on the naming standard at U(https://www.iis.net/configreference/system.applicationhost/applicationpools/add#005), see the examples section for more details on how to set this.\nYou can also set the attributes of child elements like cpu and processModel, see the examples to see how it is done.\nWhile you can use the numeric values for enums it is recommended to use the enum name itself, e.g. use SpecificUser instead of 3 for processModel.identityType.\nmanagedPipelineMode may be either \"Integrated\" or \"Classic\".\nstartMode may be either \"OnDemand\" or \"AlwaysRunning\".\nUse C(state) module parameter to modify the state of the app pool.\nWhen trying to set 'processModel.password' and you receive a 'Value does fall within the expected range' error, you have a corrupted keystore. Please follow U(http://structuredsight.com/2014/10/26/im-out-of-range-youre-out-of-range/) to help fix your host."
                     },
                     "name": {
                        "type": "string",
                        "description": "Name of the application pool."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nThe state of the application pool.\nIf C(absent) will ensure the app pool is removed.\nIf C(present) will ensure the app pool is configured and exists.\nIf C(restarted) will ensure the app pool exists and will restart, this is never idempotent.\nIf C(started) will ensure the app pool exists and is started.\nIf C(stopped) will ensure the app pool exists and is stopped.",
                        "enum": [
                           "absent",
                           "present",
                           "restarted",
                           "started",
                           "stopped"
                        ]
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "win_iis_webapplication": {
                  "type": "object",
                  "description": "Creates, removes, and configures IIS web applications.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the web application."
                     },
                     "site": {
                        "type": "string",
                        "description": "Name of the site on which the application is created."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nState of the web application.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "physical_path": {
                        "type": "string",
                        "description": "The physical path on the remote host to use for the new application.\nThe specified folder must already exist."
                     },
                     "application_pool": {
                        "type": "string",
                        "description": "The application pool in which the new site executes."
                     }
                  },
                  "required": [
                     "name",
                     "site"
                  ]
               },
               "win_iis_virtualdirectory": {
                  "type": "object",
                  "description": "Creates, Removes and configures a virtual directory in IIS.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name of the virtual directory to create or remove."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether to add or remove the specified virtual directory.\nRemoving will remove the virtual directory and all under it (Recursively).",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "site": {
                        "type": "string",
                        "description": "The site name under which the virtual directory is created or exists."
                     },
                     "application": {
                        "type": "string",
                        "description": "The application under which the virtual directory is created or exists."
                     },
                     "physical_path": {
                        "type": "string",
                        "description": "The physical path to the folder in which the new virtual directory is created.\nThe specified folder must already exist."
                     }
                  },
                  "required": [
                     "name",
                     "site"
                  ]
               },
               "win_http_proxy": {
                  "type": "object",
                  "description": "Used to set, remove, or import proxy settings for Windows HTTP Services C(WinHTTP).\nWinHTTP is a framework used by applications or services, typically .NET applications or non-interactive services, to make web requests.",
                  "properties": {
                     "bypass": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "A list of hosts that will bypass the set proxy when being accessed.\nUse C(<local>) to match hostnames that are not fully qualified domain names. This is useful when needing to connect to intranet sites using just the hostname.\nOmit, set to null or an empty string/list to remove the bypass list.\nIf this is set then I(proxy) must also be set."
                     },
                     "proxy": {
                        "type": "string",
                        "description": "A string or dict that specifies the proxy to be set.\nIf setting a string, should be in the form C(hostname), C(hostname:port), or C(protocol=hostname:port).\nIf the port is undefined, the default port for the protocol in use is used.\nIf setting a dict, the keys should be the protocol and the values should be the hostname and/or port for that protocol.\nValid protocols are C(http), C(https), C(ftp), and C(socks).\nOmit, set to null or an empty string to remove the proxy settings."
                     },
                     "source": {
                        "type": "string",
                        "description": "Instead of manually specifying the I(proxy) and/or I(bypass), set this to import the proxy from a set source like Internet Explorer.\nUsing C(ie) will import the Internet Explorer proxy settings for the current active network connection of the current user.\nOnly IE's proxy URL and bypass list will be imported into WinHTTP.\nThis is like running C(netsh winhttp import proxy source=ie).\nThe value is imported when the module runs and will not automatically be updated if the IE configuration changes in the future. The module will have to be run again to sync the latest changes.",
                        "enum": [
                           "ie"
                        ]
                     }
                  }
               },
               "win_hotfix": {
                  "type": "object",
                  "description": "Install, uninstall a Windows hotfix.",
                  "properties": {
                     "hotfix_identifier": {
                        "type": "string",
                        "description": "The name of the hotfix as shown in DISM, see examples for details.\nThis or C(hotfix_kb) MUST be set when C(state=absent).\nIf C(state=present) then the hotfix at C(source) will be validated against this value, if it does not match an error will occur.\nYou can get the identifier by running 'Get-WindowsPackage -Online -PackagePath path-to-cab-in-msu' after expanding the msu file."
                     },
                     "hotfix_kb": {
                        "type": "string",
                        "description": "The name of the KB the hotfix relates to, see examples for details.\nThis or C(hotfix_identifier) MUST be set when C(state=absent).\nIf C(state=present) then the hotfix at C(source) will be validated against this value, if it does not match an error will occur.\nBecause DISM uses the identifier as a key and doesn't refer to a KB in all cases it is recommended to use C(hotfix_identifier) instead."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether to install or uninstall the hotfix.\nWhen C(present), C(source) MUST be set.\nWhen C(absent), C(hotfix_identifier) or C(hotfix_kb) MUST be set.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "source": {
                        "type": "string",
                        "description": "The path to the downloaded hotfix .msu file.\nThis MUST be set if C(state=present) and MUST be a .msu hotfix file."
                     }
                  }
               },
               "win_hosts": {
                  "type": "object",
                  "description": "Manages hosts file entries on Windows.\nMaps IPv4 or IPv6 addresses to canonical names.\nAdds, removes, or sets cname records for ip and hostname pairs.\nModifies %windir%\\\\system32\\\\drivers\\\\etc\\\\hosts.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the entry should be present or absent.\nIf only I(canonical_name) is provided when C(state=absent), then all hosts entries with the canonical name of I(canonical_name) will be removed.\nIf only I(ip_address) is provided when C(state=absent), then all hosts entries with the ip address of I(ip_address) will be removed.\nIf I(ip_address) and I(canonical_name) are both omitted when C(state=absent), then all hosts entries will be removed.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "canonical_name": {
                        "type": "string",
                        "description": "A canonical name for the host entry.\nrequired for C(state=present)."
                     },
                     "ip_address": {
                        "type": "string",
                        "description": "The ip address for the host entry.\nCan be either IPv4 (A record) or IPv6 (AAAA record).\nRequired for C(state=present)."
                     },
                     "aliases": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "A list of additional names (cname records) for the host entry.\nOnly applicable when C(state=present)."
                     },
                     "action": {
                        "type": "string",
                        "description": "Default: set\n\nControls the behavior of I(aliases).\nOnly applicable when C(state=present).\nIf C(add), each alias in I(aliases) will be added to the host entry.\nIf C(set), each alias in I(aliases) will be added to the host entry, and other aliases will be removed from the entry.",
                        "enum": [
                           "add",
                           "remove",
                           "set"
                        ]
                     }
                  }
               },
               "win_hostname": {
                  "type": "object",
                  "description": "Manages local Windows computer name.\nA reboot is required for the computer name to take effect.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The hostname to set for the computer."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "win_group_membership": {
                  "type": "object",
                  "description": "Allows the addition and removal of local, service and domain users, and domain groups from a local group.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the local group to manage membership on."
                     },
                     "members": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "A list of members to ensure are present/absent from the group.\nAccepts local users as .\\username, and SERVERNAME\\username.\nAccepts domain users and groups as DOMAIN\\username and username@DOMAIN.\nAccepts service users as NT AUTHORITY\\username.\nAccepts all local, domain and service user types as username, favoring domain lookups when in a domain."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDesired state of the members in the group.\nC(pure) was added in Ansible 2.8.\nWhen C(state) is C(pure), only the members specified will exist, and all other existing members not specified are removed.",
                        "enum": [
                           "absent",
                           "present",
                           "pure"
                        ]
                     }
                  },
                  "required": [
                     "name",
                     "members"
                  ]
               },
               "win_group": {
                  "type": "object",
                  "description": "Add and remove local groups.\nFor non-Windows targets, please use the M(group) module instead.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the group."
                     },
                     "description": {
                        "type": "string",
                        "description": "Description of the group."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nCreate or remove the group.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "win_get_url": {
                  "type": "object",
                  "description": "Downloads files from HTTP, HTTPS, or FTP to the remote server.\nThe remote server I(must) have direct access to the remote resource.\nFor non-Windows targets, use the M(get_url) module instead.",
                  "properties": {
                     "url": {
                        "type": "string",
                        "description": "The full URL of a file to download."
                     },
                     "dest": {
                        "type": "string",
                        "description": "The location to save the file at the URL.\nBe sure to include a filename and extension as appropriate."
                     },
                     "force": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nIf C(yes), will download the file every time and replace the file if the contents change. If C(no), will only download the file if it does not exist or the remote file has been modified more recently than the local file.\nThis works by sending an http HEAD request to retrieve last modified time of the requested resource, so for this to work, the remote web server must support HEAD requests."
                     },
                     "checksum": {
                        "type": "string",
                        "description": "If a I(checksum) is passed to this parameter, the digest of the destination file will be calculated after it is downloaded to ensure its integrity and verify that the transfer completed successfully.\nThis option cannot be set with I(checksum_url)."
                     },
                     "checksum_algorithm": {
                        "type": "string",
                        "description": "Default: sha1\n\nSpecifies the hashing algorithm used when calculating the checksum of the remote and destination file.",
                        "enum": [
                           "md5",
                           "sha1",
                           "sha256",
                           "sha384",
                           "sha512"
                        ]
                     },
                     "checksum_url": {
                        "type": "string",
                        "description": "Specifies a URL that contains the checksum values for the resource at I(url).\nLike C(checksum), this is used to verify the integrity of the remote transfer.\nThis option cannot be set with I(checksum)."
                     },
                     "proxy_url": {
                        "type": "string",
                        "description": ""
                     },
                     "proxy_username": {
                        "type": "string",
                        "description": ""
                     },
                     "proxy_password": {
                        "type": "string",
                        "description": ""
                     },
                     "headers": {
                        "type": "string",
                        "description": ""
                     },
                     "use_proxy": {
                        "type": "string",
                        "description": ""
                     },
                     "follow_redirects": {
                        "type": "string",
                        "description": ""
                     },
                     "maximum_redirection": {
                        "type": "string",
                        "description": ""
                     },
                     "client_cert": {
                        "type": "string",
                        "description": ""
                     },
                     "client_cert_password": {
                        "type": "string",
                        "description": ""
                     },
                     "method": {
                        "type": "string",
                        "description": "This option is not for use with C(win_get_url) and should be ignored."
                     }
                  },
                  "required": [
                     "url",
                     "dest"
                  ]
               },
               "win_format": {
                  "type": "object",
                  "description": "The M(win_format) module formats an existing volume or a new volume on an existing partition on Windows",
                  "properties": {
                     "drive_letter": {
                        "type": "string",
                        "description": "Used to specify the drive letter of the volume to be formatted."
                     },
                     "path": {
                        "type": "string",
                        "description": "Used to specify the path to the volume to be formatted."
                     },
                     "label": {
                        "type": "string",
                        "description": "Used to specify the label of the volume to be formatted."
                     },
                     "new_label": {
                        "type": "string",
                        "description": "Used to specify the new file system label of the formatted volume."
                     },
                     "file_system": {
                        "type": "string",
                        "description": "Used to specify the file system to be used when formatting the target volume.",
                        "enum": [
                           "ntfs",
                           "refs",
                           "exfat",
                           "fat32",
                           "fat"
                        ]
                     },
                     "allocation_unit_size": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Specifies the cluster size to use when formatting the volume.\nIf no cluster size is specified when you format a partition, defaults are selected based on the size of the partition."
                     },
                     "large_frs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Specifies that large File Record System (FRS) should be used."
                     },
                     "compress": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Enable compression on the resulting NTFS volume.\nNTFS compression is not supported where I(allocation_unit_size) is more than 4096."
                     },
                     "integrity_streams": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Enable integrity streams on the resulting ReFS volume."
                     },
                     "full": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "A full format writes to every sector of the disk, takes much longer to perform than the default (quick) format, and is not recommended on storage that is thinly provisioned.\nSpecify C(true) for full format."
                     },
                     "force": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Specify if formatting should be forced for volumes that are not created from new partitions or if the source and target file system are different."
                     }
                  }
               },
               "win_firewall_rule": {
                  "type": "object",
                  "description": "Allows you to create/remove/update firewall rules.",
                  "properties": {
                     "enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether this firewall rule is enabled or disabled.\nDefaults to C(true) when creating a new rule."
                     },
                     "enable": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether this firewall rule is enabled or disabled.\nDefaults to C(true) when creating a new rule."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nShould this rule be added or removed.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The rule's display name."
                     },
                     "group": {
                        "type": "string",
                        "description": "The group name for the rule."
                     },
                     "direction": {
                        "type": "string",
                        "description": "Whether this rule is for inbound or outbound traffic.\nDefaults to C(in) when creating a new rule.",
                        "enum": [
                           "in",
                           "out"
                        ]
                     },
                     "action": {
                        "type": "string",
                        "description": "What to do with the items this rule is for.\nDefaults to C(allow) when creating a new rule.",
                        "enum": [
                           "allow",
                           "block"
                        ]
                     },
                     "description": {
                        "type": "string",
                        "description": "Description for the firewall rule."
                     },
                     "localip": {
                        "type": "string",
                        "description": "The local ip address this rule applies to.\nSet to C(any) to apply to all local ip addresses.\nDefaults to C(any) when creating a new rule."
                     },
                     "remoteip": {
                        "type": "string",
                        "description": "The remote ip address/range this rule applies to.\nSet to C(any) to apply to all remote ip addresses.\nDefaults to C(any) when creating a new rule."
                     },
                     "localport": {
                        "type": "string",
                        "description": "The local port this rule applies to.\nSet to C(any) to apply to all local ports.\nDefaults to C(any) when creating a new rule.\nMust have I(protocol) set"
                     },
                     "remoteport": {
                        "type": "string",
                        "description": "The remote port this rule applies to.\nSet to C(any) to apply to all remote ports.\nDefaults to C(any) when creating a new rule.\nMust have I(protocol) set"
                     },
                     "program": {
                        "type": "string",
                        "description": "The program this rule applies to.\nSet to C(any) to apply to all programs.\nDefaults to C(any) when creating a new rule."
                     },
                     "service": {
                        "type": "string",
                        "description": "The service this rule applies to.\nSet to C(any) to apply to all services.\nDefaults to C(any) when creating a new rule."
                     },
                     "protocol": {
                        "type": "string",
                        "description": "The protocol this rule applies to.\nSet to C(any) to apply to all services.\nDefaults to C(any) when creating a new rule."
                     },
                     "profiles": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "The profile this rule applies to.\nDefaults to C(domain,private,public) when creating a new rule."
                     },
                     "profile": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "The profile this rule applies to.\nDefaults to C(domain,private,public) when creating a new rule."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "enabled",
                                    "enable"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "profiles",
                                    "profile"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "win_firewall": {
                  "type": "object",
                  "description": "Enable or Disable Windows Firewall profiles.",
                  "properties": {
                     "profiles": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Default: ['Domain', 'Private', 'Public']\n\nSpecify one or more profiles to change."
                     },
                     "state": {
                        "type": "string",
                        "description": "Set state of firewall for given profile.",
                        "enum": [
                           "disabled",
                           "enabled"
                        ]
                     }
                  }
               },
               "win_find": {
                  "type": "object",
                  "description": "Return a list of files based on specified criteria.\nMultiple criteria are AND'd together.\nFor non-Windows targets, use the M(find) module instead.",
                  "properties": {
                     "age": {
                        "type": "string",
                        "description": "Select files or folders whose age is equal to or greater than the specified time.\nUse a negative age to find files equal to or less than the specified time.\nYou can choose seconds, minutes, hours, days or weeks by specifying the first letter of an of those words (e.g., \"2s\", \"10d\", 1w\")."
                     },
                     "age_stamp": {
                        "type": "string",
                        "description": "Default: mtime\n\nChoose the file property against which we compare C(age).\nThe default attribute we compare with is the last modification time.",
                        "enum": [
                           "atime",
                           "ctime",
                           "mtime"
                        ]
                     },
                     "checksum_algorithm": {
                        "type": "string",
                        "description": "Default: sha1\n\nAlgorithm to determine the checksum of a file.\nWill throw an error if the host is unable to use specified algorithm.",
                        "enum": [
                           "md5",
                           "sha1",
                           "sha256",
                           "sha384",
                           "sha512"
                        ]
                     },
                     "file_type": {
                        "type": "string",
                        "description": "Default: file\n\nType of file to search for.",
                        "enum": [
                           "directory",
                           "file"
                        ]
                     },
                     "follow": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Set this to C(yes) to follow symlinks in the path.\nThis needs to be used in conjunction with C(recurse)."
                     },
                     "get_checksum": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nWhether to return a checksum of the file in the return info (default sha1), use C(checksum_algorithm) to change from the default."
                     },
                     "hidden": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Set this to include hidden files or folders."
                     },
                     "paths": {
                        "type": "array",
                        "description": "List of paths of directories to search for files or folders in.\nThis can be supplied as a single path or a list of paths."
                     },
                     "patterns": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "One or more (powershell or regex) patterns to compare filenames with.\nThe type of pattern matching is controlled by C(use_regex) option.\nThe patterns restrict the list of files or folders to be returned based on the filenames.\nFor a file to be matched it only has to match with one pattern in a list provided."
                     },
                     "regex": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "One or more (powershell or regex) patterns to compare filenames with.\nThe type of pattern matching is controlled by C(use_regex) option.\nThe patterns restrict the list of files or folders to be returned based on the filenames.\nFor a file to be matched it only has to match with one pattern in a list provided."
                     },
                     "regexp": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "One or more (powershell or regex) patterns to compare filenames with.\nThe type of pattern matching is controlled by C(use_regex) option.\nThe patterns restrict the list of files or folders to be returned based on the filenames.\nFor a file to be matched it only has to match with one pattern in a list provided."
                     },
                     "recurse": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Will recursively descend into the directory looking for files or folders."
                     },
                     "size": {
                        "type": "string",
                        "description": "Select files or folders whose size is equal to or greater than the specified size.\nUse a negative value to find files equal to or less than the specified size.\nYou can specify the size with a suffix of the byte type i.e. kilo = k, mega = m...\nSize is not evaluated for symbolic links."
                     },
                     "use_regex": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Will set patterns to run as a regex check if set to C(yes)."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "patterns",
                                    "regex",
                                    "regexp"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "win_file_version": {
                  "type": "object",
                  "description": "Get DLL or EXE file build version.",
                  "properties": {
                     "path": {
                        "type": "string",
                        "description": "File to get version.\nAlways provide absolute path."
                     }
                  },
                  "required": [
                     "path"
                  ]
               },
               "win_file": {
                  "type": "object",
                  "description": "Creates (empty) files, updates file modification stamps of existing files, and can create or remove directories.\nUnlike M(file), does not modify ownership, permissions or manipulate links.\nFor non-Windows targets, use the M(file) module instead.",
                  "properties": {
                     "path": {
                        "type": "string",
                        "description": "Path to the file being managed."
                     },
                     "dest": {
                        "type": "string",
                        "description": "Path to the file being managed."
                     },
                     "name": {
                        "type": "string",
                        "description": "Path to the file being managed."
                     },
                     "state": {
                        "type": "string",
                        "description": "If C(directory), all immediate subdirectories will be created if they do not exist.\nIf C(file), the file will NOT be created if it does not exist, see the M(copy) or M(template) module if you want that behavior.  If C(absent), directories will be recursively deleted, and files will be removed.\nIf C(touch), an empty file will be created if the C(path) does not exist, while an existing file or directory will receive updated file access and modification times (similar to the way C(touch) works from the command line).",
                        "enum": [
                           "absent",
                           "directory",
                           "file",
                           "touch"
                        ]
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "path",
                                    "dest",
                                    "name"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "path"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "dest"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "win_feature": {
                  "type": "object",
                  "description": "Installs or uninstalls Windows Roles or Features on Windows Server.\nThis module uses the Add/Remove-WindowsFeature Cmdlets on Windows 2008 R2 and Install/Uninstall-WindowsFeature Cmdlets on Windows 2012, which are not available on client os machines.",
                  "properties": {
                     "name": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Names of roles or features to install as a single feature or a comma-separated list of features.\nTo list all available features use the PowerShell command C(Get-WindowsFeature)."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nState of the features or roles on the system.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "include_sub_features": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Adds all subfeatures of the specified feature."
                     },
                     "include_management_tools": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Adds the corresponding management tools to the specified feature.\nNot supported in Windows 2008 R2 and will be ignored."
                     },
                     "source": {
                        "type": "string",
                        "description": "Specify a source to install the feature from.\nNot supported in Windows 2008 R2 and will be ignored.\nCan either be C({driveletter}:\\sources\\sxs) or C(\\\\{IP}\\share\\sources\\sxs)."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "win_eventlog_entry": {
                  "type": "object",
                  "description": "Write log entries to a given event log from a specified source.",
                  "properties": {
                     "log": {
                        "type": "string",
                        "description": "Name of the event log to write an entry to."
                     },
                     "source": {
                        "type": "string",
                        "description": "Name of the log source to indicate where the entry is from."
                     },
                     "event_id": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "The numeric event identifier for the entry.\nValue must be between 0 and 65535."
                     },
                     "message": {
                        "type": "string",
                        "description": "The message for the given log entry."
                     },
                     "entry_type": {
                        "type": "string",
                        "description": "Indicates the entry being written to the log is of a specific type.",
                        "enum": [
                           "Error",
                           "FailureAudit",
                           "Information",
                           "SuccessAudit",
                           "Warning"
                        ]
                     },
                     "category": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "A numeric task category associated with the category message file for the log source."
                     },
                     "raw_data": {
                        "type": "string",
                        "description": "Binary data associated with the log entry.\nValue must be a comma-separated array of 8-bit unsigned integers (0 to 255)."
                     }
                  },
                  "required": [
                     "log",
                     "source",
                     "event_id",
                     "message"
                  ]
               },
               "win_eventlog": {
                  "type": "object",
                  "description": "Allows the addition, clearing and removal of local Windows event logs, and the creation and removal of sources from a given event log.  Also allows the specification of settings per log and source.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the event log to manage."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDesired state of the log and/or sources.\nWhen C(sources) is populated, state is checked for sources.\nWhen C(sources) is not populated, state is checked for the specified log itself.\nIf C(state) is C(clear), event log entries are cleared for the target log.",
                        "enum": [
                           "absent",
                           "clear",
                           "present"
                        ]
                     },
                     "sources": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "A list of one or more sources to ensure are present/absent in the log.\nWhen C(category_file), C(message_file) and/or C(parameter_file) are specified, these values are applied across all sources."
                     },
                     "category_file": {
                        "type": "string",
                        "description": "For one or more sources specified, the path to a custom category resource file."
                     },
                     "message_file": {
                        "type": "string",
                        "description": "For one or more sources specified, the path to a custom event message resource file."
                     },
                     "parameter_file": {
                        "type": "string",
                        "description": "For one or more sources specified, the path to a custom parameter resource file."
                     },
                     "maximum_size": {
                        "type": "string",
                        "description": "The maximum size of the event log.\nValue must be between 64KB and 4GB, and divisible by 64KB.\nSize can be specified in KB, MB or GB (e.g. 128KB, 16MB, 2.5GB)."
                     },
                     "overflow_action": {
                        "type": "string",
                        "description": "The action for the log to take once it reaches its maximum size.\nFor C(DoNotOverwrite), all existing entries are kept and new entries are not retained.\nFor C(OverwriteAsNeeded), each new entry overwrites the oldest entry.\nFor C(OverwriteOlder), new log entries overwrite those older than the C(retention_days) value.",
                        "enum": [
                           "DoNotOverwrite",
                           "OverwriteAsNeeded",
                           "OverwriteOlder"
                        ]
                     },
                     "retention_days": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "The minimum number of days event entries must remain in the log.\nThis option is only used when C(overflow_action) is C(OverwriteOlder)."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "win_environment": {
                  "type": "object",
                  "description": "Uses .net Environment to set or remove environment variables and can set at User, Machine or Process level.\nUser level environment variables will be set, but not available until the user has logged off and on again.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nSet to C(present) to ensure environment variable is set.\nSet to C(absent) to ensure it is removed.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the environment variable."
                     },
                     "value": {
                        "type": "string",
                        "description": "The value to store in the environment variable.\nMust be set when C(state=present) and cannot be an empty string.\nCan be omitted for C(state=absent)."
                     },
                     "level": {
                        "type": "string",
                        "description": "The level at which to set the environment variable.\nUse C(machine) to set for all users.\nUse C(user) to set for the current user that ansible is connected as.\nUse C(process) to set for the current process.  Probably not that useful.",
                        "enum": [
                           "machine",
                           "process",
                           "user"
                        ]
                     }
                  },
                  "required": [
                     "name",
                     "level"
                  ]
               },
               "win_dotnet_ngen": {
                  "type": "object",
                  "description": "After .NET framework is installed/updated, Windows will probably want to recompile things to optimise for the host.\nThis happens via scheduled task, usually at some inopportune time.\nThis module allows you to run this task on your own schedule, so you incur the CPU hit at some more convenient and controlled time.\nU(https://docs.microsoft.com/en-us/dotnet/framework/tools/ngen-exe-native-image-generator#native-image-service)\nU(http://blogs.msdn.com/b/dotnet/archive/2013/08/06/wondering-why-mscorsvw-exe-has-high-cpu-usage-you-can-speed-it-up.aspx)",
                  "properties": {}
               },
               "win_domain_user": {
                  "type": "object",
                  "description": "Manages Windows Active Directory user accounts.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the user to create, remove or modify."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhen C(present), creates or updates the user account.\nWhen C(absent), removes the user account if it exists.\nWhen C(query), retrieves the user account details without making any changes.",
                        "enum": [
                           "absent",
                           "present",
                           "query"
                        ]
                     },
                     "enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nC(yes) will enable the user account.\nC(no) will disable the account."
                     },
                     "account_locked": {
                        "type": "string",
                        "description": "C(no) will unlock the user account if locked.\nNote that there is not a way to lock an account as an administrator.\nAccounts are locked due to user actions; as an admin, you may only unlock a locked account.\nIf you wish to administratively disable an account, set I(enabled) to C(no).",
                        "enum": [
                           false
                        ]
                     },
                     "description": {
                        "type": "string",
                        "description": "Description of the user"
                     },
                     "groups": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Adds or removes the user from this list of groups, depending on the value of I(groups_action).\nTo remove all but the Principal Group, set C(groups=<principal group name>) and I(groups_action=replace).\nNote that users cannot be removed from their principal group (for example, \"Domain Users\")."
                     },
                     "groups_action": {
                        "type": "string",
                        "description": "Default: replace\n\nIf C(add), the user is added to each group in I(groups) where not already a member.\nIf C(remove), the user is removed from each group in I(groups).\nIf C(replace), the user is added as a member of each group in I(groups) and removed from any other groups.",
                        "enum": [
                           "add",
                           "remove",
                           "replace"
                        ]
                     },
                     "password": {
                        "type": "string",
                        "description": "Optionally set the user's password to this (plain text) value.\nTo enable an account - I(enabled) - a password must already be configured on the account, or you must provide a password here."
                     },
                     "update_password": {
                        "type": "string",
                        "description": "Default: always\n\nC(always) will always update passwords.\nC(on_create) will only set the password for newly created users.\nC(when_changed) will only set the password when changed (added in ansible 2.9).",
                        "enum": [
                           "always",
                           "on_create",
                           "when_changed"
                        ]
                     },
                     "password_expired": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "C(yes) will require the user to change their password at next login.\nC(no) will clear the expired password flag.\nThis is mutually exclusive with I(password_never_expires)."
                     },
                     "password_never_expires": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "C(yes) will set the password to never expire.\nC(no) will allow the password to expire.\nThis is mutually exclusive with I(password_expired)."
                     },
                     "user_cannot_change_password": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "C(yes) will prevent the user from changing their password.\nC(no) will allow the user to change their password."
                     },
                     "firstname": {
                        "type": "string",
                        "description": "Configures the user's first name (given name)."
                     },
                     "surname": {
                        "type": "string",
                        "description": "Configures the user's last name (surname)."
                     },
                     "company": {
                        "type": "string",
                        "description": "Configures the user's company name."
                     },
                     "upn": {
                        "type": "string",
                        "description": "Configures the User Principal Name (UPN) for the account.\nThis is not required, but is best practice to configure for modern versions of Active Directory.\nThe format is C(<username>@<domain>)."
                     },
                     "email": {
                        "type": "string",
                        "description": "Configures the user's email address.\nThis is a record in AD and does not do anything to configure any email servers or systems."
                     },
                     "street": {
                        "type": "string",
                        "description": "Configures the user's street address."
                     },
                     "city": {
                        "type": "string",
                        "description": "Configures the user's city."
                     },
                     "state_province": {
                        "type": "string",
                        "description": "Configures the user's state or province."
                     },
                     "postal_code": {
                        "type": "string",
                        "description": "Configures the user's postal code / zip code."
                     },
                     "country": {
                        "type": "string",
                        "description": "Configures the user's country code.\nNote that this is a two-character ISO 3166 code."
                     },
                     "path": {
                        "type": "string",
                        "description": "Container or OU for the new user; if you do not specify this, the user will be placed in the default container for users in the domain.\nSetting the path is only available when a new user is created; if you specify a path on an existing user, the user's path will not be updated - you must delete (e.g., C(state=absent)) the user and then re-add the user with the appropriate path."
                     },
                     "attributes": {
                        "type": "string",
                        "description": "A dict of custom LDAP attributes to set on the user.\nThis can be used to set custom attributes that are not exposed as module parameters, e.g. C(telephoneNumber).\nSee the examples on how to format this parameter."
                     },
                     "domain_username": {
                        "type": "string",
                        "description": "The username to use when interacting with AD.\nIf this is not set then the user Ansible used to log in with will be used instead when using CredSSP or Kerberos with credential delegation."
                     },
                     "domain_password": {
                        "type": "string",
                        "description": "The password for I(username)."
                     },
                     "domain_server": {
                        "type": "string",
                        "description": "Specifies the Active Directory Domain Services instance to connect to.\nCan be in the form of an FQDN or NetBIOS name.\nIf not specified then the value is based on the domain of the computer running PowerShell."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "win_domain_membership": {
                  "type": "object",
                  "description": "Manages domain membership or workgroup membership for a Windows host. Also supports hostname changes.\nThis module may require subsequent use of the M(win_reboot) action if changes are made.",
                  "properties": {
                     "dns_domain_name": {
                        "type": "string",
                        "description": "When C(state) is C(domain), the DNS name of the domain to which the targeted Windows host should be joined."
                     },
                     "domain_admin_user": {
                        "type": "string",
                        "description": "Username of a domain admin for the target domain (required to join or leave the domain)."
                     },
                     "domain_admin_password": {
                        "type": "string",
                        "description": "Password for the specified C(domain_admin_user)."
                     },
                     "hostname": {
                        "type": "string",
                        "description": "The desired hostname for the Windows host."
                     },
                     "domain_ou_path": {
                        "type": "string",
                        "description": "The desired OU path for adding the computer object.\nThis is only used when adding the target host to a domain, if it is already a member then it is ignored."
                     },
                     "state": {
                        "type": "string",
                        "description": "Whether the target host should be a member of a domain or workgroup.",
                        "enum": [
                           "domain",
                           "workgroup"
                        ]
                     },
                     "workgroup_name": {
                        "type": "string",
                        "description": "When C(state) is C(workgroup), the name of the workgroup that the Windows host should be in."
                     }
                  },
                  "required": [
                     "domain_admin_user"
                  ]
               },
               "win_domain_group_membership": {
                  "type": "object",
                  "description": "Allows the addition and removal of domain users and domain groups from/to a domain group.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the domain group to manage membership on."
                     },
                     "members": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "A list of members to ensure are present/absent from the group.\nThe given names must be a SamAccountName of a user, group, service account, or computer.\nFor computers, you must add \"$\" after the name; for example, to add \"Mycomputer\" to a group, use \"Mycomputer$\" as the member."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDesired state of the members in the group.\nWhen C(state) is C(pure), only the members specified will exist, and all other existing members not specified are removed.",
                        "enum": [
                           "absent",
                           "present",
                           "pure"
                        ]
                     },
                     "domain_username": {
                        "type": "string",
                        "description": "The username to use when interacting with AD.\nIf this is not set then the user Ansible used to log in with will be used instead when using CredSSP or Kerberos with credential delegation."
                     },
                     "domain_password": {
                        "type": "string",
                        "description": "The password for I(username)."
                     },
                     "domain_server": {
                        "type": "string",
                        "description": "Specifies the Active Directory Domain Services instance to connect to.\nCan be in the form of an FQDN or NetBIOS name.\nIf not specified then the value is based on the domain of the computer running PowerShell."
                     }
                  },
                  "required": [
                     "name",
                     "members"
                  ]
               },
               "win_domain_group": {
                  "type": "object",
                  "description": "Creates, modifies or removes groups in Active Directory.\nFor local groups, use the M(win_group) module instead.",
                  "properties": {
                     "attributes": {
                        "type": "object",
                        "description": "A dict of custom LDAP attributes to set on the group.\nThis can be used to set custom attributes that are not exposed as module parameters, e.g. C(mail).\nSee the examples on how to format this parameter."
                     },
                     "category": {
                        "type": "string",
                        "description": "The category of the group, this is the value to assign to the LDAP C(groupType) attribute.\nIf a new group is created then C(security) will be used by default.",
                        "enum": [
                           "distribution",
                           "security"
                        ]
                     },
                     "description": {
                        "type": "string",
                        "description": "The value to be assigned to the LDAP C(description) attribute."
                     },
                     "display_name": {
                        "type": "string",
                        "description": "The value to assign to the LDAP C(displayName) attribute."
                     },
                     "domain_username": {
                        "type": "string",
                        "description": "The username to use when interacting with AD.\nIf this is not set then the user Ansible used to log in with will be used instead."
                     },
                     "domain_password": {
                        "type": "string",
                        "description": "The password for C(username)."
                     },
                     "domain_server": {
                        "type": "string",
                        "description": "Specifies the Active Directory Domain Services instance to connect to.\nCan be in the form of an FQDN or NetBIOS name.\nIf not specified then the value is based on the domain of the computer running PowerShell."
                     },
                     "ignore_protection": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Will ignore the C(ProtectedFromAccidentalDeletion) flag when deleting or moving a group.\nThe module will fail if one of these actions need to occur and this value is set to C(no)."
                     },
                     "managed_by": {
                        "type": "string",
                        "description": "The value to be assigned to the LDAP C(managedBy) attribute.\nThis value can be in the forms C(Distinguished Name), C(objectGUID), C(objectSid) or C(sAMAccountName), see examples for more details."
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the group to create, modify or remove.\nThis value can be in the forms C(Distinguished Name), C(objectGUID), C(objectSid) or C(sAMAccountName), see examples for more details."
                     },
                     "organizational_unit": {
                        "type": "string",
                        "description": "The full LDAP path to create or move the group to.\nThis should be the path to the parent object to create or move the group to.\nSee examples for details of how this path is formed."
                     },
                     "ou": {
                        "type": "string",
                        "description": "The full LDAP path to create or move the group to.\nThis should be the path to the parent object to create or move the group to.\nSee examples for details of how this path is formed."
                     },
                     "path": {
                        "type": "string",
                        "description": "The full LDAP path to create or move the group to.\nThis should be the path to the parent object to create or move the group to.\nSee examples for details of how this path is formed."
                     },
                     "protect": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Will set the C(ProtectedFromAccidentalDeletion) flag based on this value.\nThis flag stops a user from deleting or moving a group to a different path."
                     },
                     "scope": {
                        "type": "string",
                        "description": "The scope of the group.\nIf C(state=present) and the group doesn't exist then this must be set.",
                        "enum": [
                           "domainlocal",
                           "global",
                           "universal"
                        ]
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIf C(state=present) this module will ensure the group is created and is configured accordingly.\nIf C(state=absent) this module will delete the group if it exists",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "organizational_unit",
                                    "ou",
                                    "path"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "win_domain_controller": {
                  "type": "object",
                  "description": "Ensure that a Windows Server 2012+ host is configured as a domain controller or demoted to member server.\nThis module may require subsequent use of the M(win_reboot) action if changes are made.",
                  "properties": {
                     "dns_domain_name": {
                        "type": "string",
                        "description": "When C(state) is C(domain_controller), the DNS name of the domain for which the targeted Windows host should be a DC."
                     },
                     "domain_admin_user": {
                        "type": "string",
                        "description": "Username of a domain admin for the target domain (necessary to promote or demote a domain controller)."
                     },
                     "domain_admin_password": {
                        "type": "string",
                        "description": "Password for the specified C(domain_admin_user)."
                     },
                     "safe_mode_password": {
                        "type": "string",
                        "description": "Safe mode password for the domain controller (required when C(state) is C(domain_controller))."
                     },
                     "local_admin_password": {
                        "type": "string",
                        "description": "Password to be assigned to the local C(Administrator) user (required when C(state) is C(member_server))."
                     },
                     "read_only": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether to install the domain controller as a read only replica for an existing domain."
                     },
                     "site_name": {
                        "type": "string",
                        "description": "Specifies the name of an existing site where you can place the new domain controller.\nThis option is required when I(read_only) is C(yes)."
                     },
                     "state": {
                        "type": "string",
                        "description": "Whether the target host should be a domain controller or a member server.",
                        "enum": [
                           "domain_controller",
                           "member_server"
                        ]
                     },
                     "database_path": {
                        "type": "string",
                        "description": "The path to a directory on a fixed disk of the Windows host where the domain database will be created..\nIf not set then the default path is C(%SYSTEMROOT%\\NTDS)."
                     },
                     "sysvol_path": {
                        "type": "string",
                        "description": "The path to a directory on a fixed disk of the Windows host where the Sysvol folder will be created.\nIf not set then the default path is C(%SYSTEMROOT%\\SYSVOL)."
                     }
                  },
                  "required": [
                     "domain_admin_user",
                     "domain_admin_password"
                  ]
               },
               "win_domain_computer": {
                  "type": "object",
                  "description": "Create, read, update and delete computers in Active Directory using a windows bridge computer to launch New-ADComputer, Get-ADComputer, Set-ADComputer, Remove-ADComputer and Move-ADObject powershell commands.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Specifies the name of the object.\nThis parameter sets the Name property of the Active Directory object.\nThe LDAP display name (ldapDisplayName) of this property is name."
                     },
                     "sam_account_name": {
                        "type": "string",
                        "description": "Specifies the Security Account Manager (SAM) account name of the computer.\nIt maximum is 256 characters, 15 is advised for older operating systems compatibility.\nThe LDAP display name (ldapDisplayName) for this property is sAMAccountName.\nIf ommitted the value is the same as C(name).\nNote that all computer SAMAccountNames need to end with a $."
                     },
                     "enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nSpecifies if an account is enabled.\nAn enabled account requires a password.\nThis parameter sets the Enabled property for an account object.\nThis parameter also sets the ADS_UF_ACCOUNTDISABLE flag of the Active Directory User Account Control (UAC) attribute."
                     },
                     "ou": {
                        "type": "string",
                        "description": "Specifies the X.500 path of the Organizational Unit (OU) or container where the new object is created. Required when I(state=present)."
                     },
                     "description": {
                        "type": "string",
                        "description": "Specifies a description of the object.\nThis parameter sets the value of the Description property for the object.\nThe LDAP display name (ldapDisplayName) for this property is description."
                     },
                     "dns_hostname": {
                        "type": "string",
                        "description": "Specifies the fully qualified domain name (FQDN) of the computer.\nThis parameter sets the DNSHostName property for a computer object.\nThe LDAP display name for this property is dNSHostName.\nRequired when I(state=present)."
                     },
                     "domain_username": {
                        "type": "string",
                        "description": "The username to use when interacting with AD.\nIf this is not set then the user Ansible used to log in with will be used instead when using CredSSP or Kerberos with credential delegation."
                     },
                     "domain_password": {
                        "type": "string",
                        "description": "The password for I(username)."
                     },
                     "domain_server": {
                        "type": "string",
                        "description": "Specifies the Active Directory Domain Services instance to connect to.\nCan be in the form of an FQDN or NetBIOS name.\nIf not specified then the value is based on the domain of the computer running PowerShell."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nSpecified whether the computer should be C(present) or C(absent) in Active Directory.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "win_domain": {
                  "type": "object",
                  "description": "Ensure that the domain named by C(dns_domain_name) exists and is reachable.\nIf the domain is not reachable, the domain is created in a new forest on the target Windows Server 2012R2+ host.\nThis module may require subsequent use of the M(win_reboot) action if changes are made.",
                  "properties": {
                     "dns_domain_name": {
                        "type": "string",
                        "description": "The DNS name of the domain which should exist and be reachable or reside on the target Windows host."
                     },
                     "domain_netbios_name": {
                        "type": "string",
                        "description": "The NetBIOS name for the root domain in the new forest.\nFor NetBIOS names to be valid for use with this parameter they must be single label names of 15 characters or less, if not it will fail.\nIf this parameter is not set, then the default is automatically computed from the value of the I(domain_name) parameter."
                     },
                     "safe_mode_password": {
                        "type": "string",
                        "description": "Safe mode password for the domain controller."
                     },
                     "database_path": {
                        "type": "string",
                        "description": "The path to a directory on a fixed disk of the Windows host where the domain database will be created.\nIf not set then the default path is C(%SYSTEMROOT%\\NTDS)."
                     },
                     "sysvol_path": {
                        "type": "string",
                        "description": "The path to a directory on a fixed disk of the Windows host where the Sysvol file will be created.\nIf not set then the default path is C(%SYSTEMROOT%\\SYSVOL)."
                     },
                     "create_dns_delegation": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether to create a DNS delegation that references the new DNS server that you install along with the domain controller.\nValid for Active Directory-integrated DNS only.\nThe default is computed automatically based on the environment."
                     },
                     "domain_mode": {
                        "type": "string",
                        "description": "Specifies the domain functional level of the first domain in the creation of a new forest.\nThe domain functional level cannot be lower than the forest functional level, but it can be higher.\nThe default is automatically computed and set.",
                        "enum": [
                           "Win2003",
                           "Win2008",
                           "Win2008R2",
                           "Win2012",
                           "Win2012R2",
                           "WinThreshold"
                        ]
                     },
                     "forest_mode": {
                        "type": "string",
                        "description": "Specifies the forest functional level for the new forest.\nThe default forest functional level in Windows Server is typically the same as the version you are running.",
                        "enum": [
                           "Win2003",
                           "Win2008",
                           "Win2008R2",
                           "Win2012",
                           "Win2012R2",
                           "WinThreshold"
                        ]
                     }
                  },
                  "required": [
                     "dns_domain_name",
                     "safe_mode_password"
                  ]
               },
               "win_dns_record": {
                  "type": "object",
                  "description": "Manage DNS records within an existing Windows Server DNS zone.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name of the record."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the record should exist or not.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "ttl": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 3600\n\nThe \"time to live\" of the record, in seconds.\nIgnored when C(state=absent).\nValid range is 1 - 31557600.\nNote that an Active Directory forest can specify a minimum TTL, and will dynamically \"round up\" other values to that minimum."
                     },
                     "type": {
                        "type": "string",
                        "description": "The type of DNS record to manage.",
                        "enum": [
                           "A",
                           "AAAA",
                           "CNAME",
                           "PTR"
                        ]
                     },
                     "value": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "The value(s) to specify. Required when C(state=present).\nWhen c(type=PTR) only the partial part of the IP should be given."
                     },
                     "values": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "The value(s) to specify. Required when C(state=present).\nWhen c(type=PTR) only the partial part of the IP should be given."
                     },
                     "zone": {
                        "type": "string",
                        "description": "The name of the zone to manage (eg C(example.com)).\nThe zone must already exist."
                     },
                     "computer_name": {
                        "type": "string",
                        "description": "Specifies a DNS server.\nYou can specify an IP address or any value that resolves to an IP address, such as a fully qualified domain name (FQDN), host name, or NETBIOS name."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "value",
                                    "values"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "win_dns_client": {
                  "type": "object",
                  "description": "The C(win_dns_client) module configures the DNS client on Windows network adapters.",
                  "properties": {
                     "adapter_names": {
                        "type": "string",
                        "description": "Adapter name or list of adapter names for which to manage DNS settings ('*' is supported as a wildcard value).\nThe adapter name used is the connection caption in the Network Control Panel or via C(Get-NetAdapter), eg C(Local Area Connection)."
                     },
                     "ipv4_addresses": {
                        "type": "string",
                        "description": "Single or ordered list of DNS server IPv4 addresses to configure for lookup. An empty list will configure the adapter to use the DHCP-assigned values on connections where DHCP is enabled, or disable DNS lookup on statically-configured connections."
                     }
                  },
                  "required": [
                     "adapter_names",
                     "ipv4_addresses"
                  ]
               },
               "win_disk_image": {
                  "type": "object",
                  "description": "Manages mount behavior for a specified ISO, VHD, or VHDX image on a Windows host. When C(state) is C(present), the image will be mounted under a system-assigned drive letter, which will be returned in the C(mount_path) value of the module result.\nRequires Windows 8+ or Windows Server 2012+.",
                  "properties": {
                     "image_path": {
                        "type": "string",
                        "description": "Path to an ISO, VHD, or VHDX image on the target Windows host (the file cannot reside on a network share)"
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the image should be present as a drive-letter mount or not.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     }
                  },
                  "required": [
                     "image_path"
                  ]
               },
               "win_disk_facts": {
                  "type": "object",
                  "description": "With the module you can retrieve and output detailed information about the attached disks of the target and its volumes and partitions if existent.",
                  "properties": {}
               },
               "win_defrag": {
                  "type": "object",
                  "description": "Locates and consolidates fragmented files on local volumes to improve system performance.\nMore information regarding C(win_defrag) is available from: U(https://technet.microsoft.com/en-us/library/cc731650(v=ws.11).aspx)",
                  "properties": {
                     "include_volumes": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "A list of drive letters or mount point paths of the volumes to be defragmented.\nIf this parameter is omitted, all volumes (not excluded) will be fragmented."
                     },
                     "exclude_volumes": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "A list of drive letters or mount point paths to exclude from defragmentation."
                     },
                     "freespace_consolidation": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Perform free space consolidation on the specified volumes."
                     },
                     "priority": {
                        "type": "string",
                        "description": "Default: low\n\nRun the operation at low or normal priority.",
                        "enum": [
                           "low",
                           "normal"
                        ]
                     },
                     "parallel": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Run the operation on each volume in parallel in the background."
                     }
                  }
               },
               "win_credential": {
                  "type": "object",
                  "description": "Used to create and remove Windows Credentials in the Credential Manager.\nThis module can manage both standard username/password credentials as well as certificate credentials.",
                  "properties": {
                     "alias": {
                        "type": "string",
                        "description": "Adds an alias for the credential.\nTypically this is the NetBIOS name of a host if I(name) is set to the DNS name."
                     },
                     "attributes": {
                        "type": "string",
                        "description": "A list of dicts that set application specific attributes for a credential.\nWhen set, existing attributes will be compared to the list as a whole, any differences means all attributes will be replaced."
                     },
                     "comment": {
                        "type": "string",
                        "description": "A user defined comment for the credential."
                     },
                     "name": {
                        "type": "string",
                        "description": "The target that identifies the server or servers that the credential is to be used for.\nIf the value can be a NetBIOS name, DNS server name, DNS host name suffix with a wildcard character (C(*)), a NetBIOS of DNS domain name that contains a wildcard character sequence, or an asterisk.\nSee C(TargetName) in U(https://docs.microsoft.com/en-us/windows/desktop/api/wincred/ns-wincred-_credentiala) for more details on what this value can be.\nThis is used with I(type) to produce a unique credential."
                     },
                     "persistence": {
                        "type": "string",
                        "description": "Default: local\n\nDefines the persistence of the credential.\nIf C(local), the credential will persist for all logons of the same user on the same host.\nC(enterprise) is the same as C(local) but the credential is visible to the same domain user when running on other hosts and not just localhost.",
                        "enum": [
                           "enterprise",
                           "local"
                        ]
                     },
                     "secret": {
                        "type": "string",
                        "description": "The secret for the credential.\nWhen omitted, then no secret is used for the credential if a new credentials is created.\nWhen I(type) is a password type, this is the password for I(username).\nWhen I(type) is a certificate type, this is the pin for the certificate."
                     },
                     "secret_format": {
                        "type": "string",
                        "description": "Default: text\n\nControls the input type for I(secret).\nIf C(text), I(secret) is a text string that is UTF-16LE encoded to bytes.\nIf C(base64), I(secret) is a base64 string that is base64 decoded to bytes.",
                        "enum": [
                           "base64",
                           "text"
                        ]
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhen C(absent), the credential specified by I(name) and I(type) is removed.\nWhen C(present), the credential specified by I(name) and I(type) is removed.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "type": {
                        "type": "string",
                        "description": "The type of credential to store.\nThis is used with I(name) to produce a unique credential.\nWhen the type is a C(domain) type, the credential is used by Microsoft authentication packages like Negotiate.\nWhen the type is a C(generic) type, the credential is not used by any particular authentication package.\nIt is recommended to use a C(domain) type as only authentication providers can access the secret.",
                        "enum": [
                           "domain_certificate",
                           "domain_password",
                           "generic_certificate",
                           "generic_password"
                        ]
                     },
                     "update_secret": {
                        "type": "string",
                        "description": "Default: always\n\nWhen C(always), the secret will always be updated if they differ.\nWhen C(on_create), the secret will only be checked/updated when it is first created.\nIf the secret cannot be retrieved and this is set to C(always), the module will always result in a change.",
                        "enum": [
                           "always",
                           "on_create"
                        ]
                     },
                     "username": {
                        "type": "string",
                        "description": "When I(type) is a password type, then this is the username to store for the credential.\nWhen I(type) is a credential type, then this is the thumbprint as a hex string of the certificate to use.\nWhen C(type=domain_password), this should be in the form of a Netlogon (DOMAIN\\Username) or a UPN (username@DOMAIN).\nIf using a certificate thumbprint, the certificate must exist in the C(CurrentUser\\My) certificate store for the executing user."
                     }
                  },
                  "required": [
                     "name",
                     "type"
                  ]
               },
               "win_copy": {
                  "type": "object",
                  "description": "The C(win_copy) module copies a file on the local box to remote windows locations.\nFor non-Windows targets, use the M(copy) module instead.",
                  "properties": {
                     "content": {
                        "type": "string",
                        "description": "When used instead of C(src), sets the contents of a file directly to the specified value.\nThis is for simple values, for anything complex or with formatting please switch to the M(template) module."
                     },
                     "decrypt": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nThis option controls the autodecryption of source files using vault."
                     },
                     "dest": {
                        "type": "string",
                        "description": "Remote absolute path where the file should be copied to.\nIf C(src) is a directory, this must be a directory too.\nUse \\ for path separators or \\\\ when in \"double quotes\".\nIf C(dest) ends with \\ then source or the contents of source will be copied to the directory without renaming.\nIf C(dest) is a nonexistent path, it will only be created if C(dest) ends with \"/\" or \"\\\", or C(src) is a directory.\nIf C(src) and C(dest) are files and if the parent directory of C(dest) doesn't exist, then the task will fail."
                     },
                     "backup": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Determine whether a backup should be created.\nWhen set to C(yes), create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly.\nNo backup is taken when C(remote_src=False) and multiple files are being copied."
                     },
                     "force": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nIf set to C(yes), the file will only be transferred if the content is different than destination.\nIf set to C(no), the file will only be transferred if the destination does not exist.\nIf set to C(no), no checksuming of the content is performed which can help improve performance on larger files."
                     },
                     "local_follow": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nThis flag indicates that filesystem links in the source tree, if they exist, should be followed."
                     },
                     "remote_src": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "If C(no), it will search for src at originating/master machine.\nIf C(yes), it will go to the remote/target machine for the src."
                     },
                     "src": {
                        "type": "string",
                        "description": "Local path to a file to copy to the remote server; can be absolute or relative.\nIf path is a directory, it is copied (including the source folder name) recursively to C(dest).\nIf path is a directory and ends with \"/\", only the inside contents of that directory are copied to the destination. Otherwise, if it does not end with \"/\", the directory itself with all contents is copied.\nIf path is a file and dest ends with \"\\\", the file is copied to the folder with the same filename.\nRequired unless using C(content)."
                     }
                  },
                  "required": [
                     "dest"
                  ]
               },
               "win_chocolatey_source": {
                  "type": "object",
                  "description": "Used to managed Chocolatey sources configured on the client.\nRequires Chocolatey to be already installed on the remote host.",
                  "properties": {
                     "admin_only": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Makes the source visible to Administrators only.\nRequires Chocolatey >= 0.10.8.\nWhen creating a new source, this defaults to C(no)."
                     },
                     "allow_self_service": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Allow the source to be used with self-service\nRequires Chocolatey >= 0.10.4.\nWhen creating a new source, this defaults to C(no)."
                     },
                     "bypass_proxy": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Bypass the proxy when using this source.\nRequires Chocolatey >= 0.10.4.\nWhen creating a new source, this defaults to C(no)."
                     },
                     "certificate": {
                        "type": "string",
                        "description": "The path to a .pfx file to use for X509 authenticated feeds.\nRequires Chocolatey >= 0.9.10."
                     },
                     "certificate_password": {
                        "type": "string",
                        "description": "The password for I(certificate) if required.\nRequires Chocolatey >= 0.9.10."
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the source to configure."
                     },
                     "priority": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "The priority order of this source compared to other sources, lower is better.\nAll priorities above C(0) will be evaluated first, then zero-based values will be evaluated in config file order.\nRequires Chocolatey >= 0.9.9.9.\nWhen creating a new source, this defaults to C(0)."
                     },
                     "source": {
                        "type": "string",
                        "description": "The file/folder/url of the source.\nRequired when I(state) is C(present) or C(disabled) and the source does not already exist."
                     },
                     "source_username": {
                        "type": "string",
                        "description": "The username used to access I(source)."
                     },
                     "source_password": {
                        "type": "string",
                        "description": "The password for I(source_username).\nRequired if I(source_username) is set."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhen C(absent), will remove the source.\nWhen C(disabled), will ensure the source exists but is disabled.\nWhen C(present), will ensure the source exists and is enabled.",
                        "enum": [
                           "absent",
                           "disabled",
                           "present"
                        ]
                     },
                     "update_password": {
                        "type": "string",
                        "description": "Default: always\n\nWhen C(always), the module will always set the password and report a change if I(certificate_password) or I(source_password) is set.\nWhen C(on_create), the module will only set the password if the source is being created.",
                        "enum": [
                           "always",
                           "on_create"
                        ]
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "win_chocolatey_feature": {
                  "type": "object",
                  "description": "Used to enable or disable features in Chocolatey.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name of the feature to manage.\nRun C(choco.exe feature list) to get a list of features that can be managed."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: enabled\n\nWhen C(disabled) then the feature will be disabled.\nWhen C(enabled) then the feature will be enabled.",
                        "enum": [
                           "disabled",
                           "enabled"
                        ]
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "win_chocolatey_facts": {
                  "type": "object",
                  "description": "This module shows information from Chocolatey, such as installed packages, configuration, feature and sources.",
                  "properties": {}
               },
               "win_chocolatey_config": {
                  "type": "object",
                  "description": "Used to manage Chocolatey config settings as well as unset the values.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name of the config setting to manage.\nSee U(https://chocolatey.org/docs/chocolatey-configuration) for a list of valid configuration settings that can be changed.\nAny config values that contain encrypted values like a password are not idempotent as the plaintext value cannot be read."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhen C(absent), it will ensure the setting is unset or blank.\nWhen C(present), it will ensure the setting is set to the value of I(value).",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "value": {
                        "type": "string",
                        "description": "Used when C(state=present) that contains the value to set for the config setting.\nCannot be null or an empty string, use C(state=absent) to unset a config value instead."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "win_chocolatey": {
                  "type": "object",
                  "description": "Manage packages using Chocolatey.\nIf Chocolatey is missing from the system, the module will install it.",
                  "properties": {
                     "allow_empty_checksums": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Allow empty checksums to be used for downloaded resource from non-secure locations.\nUse M(win_chocolatey_feature) with the name C(allowEmptyChecksums) to control this option globally."
                     },
                     "allow_multiple": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Allow the installation of multiple packages when I(version) is specified.\nHaving multiple packages at different versions can cause issues if the package doesn't support this. Use at your own risk."
                     },
                     "allow_prerelease": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Allow the installation of pre-release packages.\nIf I(state) is C(latest), the latest pre-release package will be installed."
                     },
                     "architecture": {
                        "type": "string",
                        "description": "Default: default\n\nForce Chocolatey to install the package of a specific process architecture.\nWhen setting C(x86), will ensure Chocolatey installs the x86 package even when on an x64 bit OS.",
                        "enum": [
                           "default",
                           "x86"
                        ]
                     },
                     "force": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Forces the install of a package, even if it already is installed.\nUsing I(force) will cause Ansible to always report that a change was made."
                     },
                     "install_args": {
                        "type": "string",
                        "description": "Arguments to pass to the native installer.\nThese are arguments that are passed directly to the installer the Chocolatey package runs, this is generally an advanced option."
                     },
                     "ignore_checksums": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Ignore the checksums provided by the package.\nUse M(win_chocolatey_feature) with the name C(checksumFiles) to control this option globally."
                     },
                     "ignore_dependencies": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Ignore dependencies, only install/upgrade the package itself."
                     },
                     "name": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Name of the package(s) to be installed.\nSet to C(all) to run the action on all the installed packages."
                     },
                     "package_params": {
                        "type": "string",
                        "description": "Parameters to pass to the package.\nThese are parameters specific to the Chocolatey package and are generally documented by the package itself.\nBefore Ansible 2.7, this option was just I(params)."
                     },
                     "params": {
                        "type": "string",
                        "description": "Parameters to pass to the package.\nThese are parameters specific to the Chocolatey package and are generally documented by the package itself.\nBefore Ansible 2.7, this option was just I(params)."
                     },
                     "pinned": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether to pin the Chocolatey package or not.\nIf omitted then no checks on package pins are done.\nWill pin/unpin the specific version if I(version) is set.\nWill pin the latest version of a package if C(yes), I(version) is not set and and no pin already exists.\nWill unpin all versions of a package if C(no) and I(version) is not set.\nThis is ignored when C(state=absent)."
                     },
                     "proxy_url": {
                        "type": "string",
                        "description": "Proxy URL used to install chocolatey and the package.\nUse M(win_chocolatey_config) with the name C(proxy) to control this option globally."
                     },
                     "proxy_username": {
                        "type": "string",
                        "description": "Proxy username used to install Chocolatey and the package.\nBefore Ansible 2.7, users with double quote characters C(\") would need to be escaped with C(\\) beforehand. This is no longer necessary.\nUse M(win_chocolatey_config) with the name C(proxyUser) to control this option globally."
                     },
                     "proxy_password": {
                        "type": "string",
                        "description": "Proxy password used to install Chocolatey and the package.\nThis value is exposed as a command argument and any privileged account can see this value when the module is running Chocolatey, define the password on the global config level with M(win_chocolatey_config) with name C(proxyPassword) to avoid this."
                     },
                     "skip_scripts": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Do not run I(chocolateyInstall.ps1) or I(chocolateyUninstall.ps1) scripts when installing a package."
                     },
                     "source": {
                        "type": "string",
                        "description": "Specify the source to retrieve the package from.\nUse M(win_chocolatey_source) to manage global sources.\nThis value can either be the URL to a Chocolatey feed, a path to a folder containing C(.nupkg) packages or the name of a source defined by M(win_chocolatey_source).\nThis value is also used when Chocolatey is not installed as the location of the install.ps1 script and only supports URLs for this case."
                     },
                     "source_username": {
                        "type": "string",
                        "description": "A username to use with I(source) when accessing a feed that requires authentication.\nIt is recommended you define the credentials on a source with M(win_chocolatey_source) instead of passing it per task."
                     },
                     "source_password": {
                        "type": "string",
                        "description": "The password for I(source_username).\nThis value is exposed as a command argument and any privileged account can see this value when the module is running Chocolatey, define the credentials with a source with M(win_chocolatey_source) to avoid this."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nState of the package on the system.\nWhen C(absent), will ensure the package is not installed.\nWhen C(present), will ensure the package is installed.\nWhen C(downgrade), will allow Chocolatey to downgrade a package if I(version) is older than the installed version.\nWhen C(latest), will ensure the package is installed to the latest available version.\nWhen C(reinstalled), will uninstall and reinstall the package.",
                        "enum": [
                           "absent",
                           "downgrade",
                           "latest",
                           "present",
                           "reinstalled"
                        ]
                     },
                     "timeout": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 2700\n\nThe time to allow chocolatey to finish before timing out."
                     },
                     "execution_timeout": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 2700\n\nThe time to allow chocolatey to finish before timing out."
                     },
                     "validate_certs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nUsed when downloading the Chocolatey install script if Chocolatey is not already installed, this does not affect the Chocolatey package install process.\nWhen C(no), no SSL certificates will be validated.\nThis should only be used on personally controlled sites using self-signed certificate."
                     },
                     "version": {
                        "type": "string",
                        "description": "Specific version of the package to be installed.\nWhen I(state) is set to C(absent), will uninstall the specific version otherwise all versions of that package will be removed.\nIf a different version of package is installed, I(state) must be C(latest) or I(force) set to C(yes) to install the desired version.\nProvide as a string (e.g. C('6.1')), otherwise it is considered to be a floating-point number and depending on the locale could become C(6,1), which will cause a failure.\nIf I(name) is set to C(chocolatey) and Chocolatey is not installed on the host, this will be the version of Chocolatey that is installed. You can also set the C(chocolateyVersion) environment var."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "package_params",
                                    "params"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "timeout",
                                    "execution_timeout"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "win_certificate_store": {
                  "type": "object",
                  "description": "Used to import/export and remove certificates and keys from the local certificate store.\nThis module is not used to create certificates and will only manage existing certs as a file or in the store.\nIt can be used to import PEM, DER, P7B, PKCS12 (PFX) certificates and export PEM, DER and PKCS12 certificates.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIf C(present), will ensure that the certificate at I(path) is imported into the certificate store specified.\nIf C(absent), will ensure that the certificate specified by I(thumbprint) or the thumbprint of the cert at I(path) is removed from the store specified.\nIf C(exported), will ensure the file at I(path) is a certificate specified by I(thumbprint).\nWhen exporting a certificate, if I(path) is a directory then the module will fail, otherwise the file will be replaced if needed.",
                        "enum": [
                           "absent",
                           "exported",
                           "present"
                        ]
                     },
                     "path": {
                        "type": "string",
                        "description": "The path to a certificate file.\nThis is required when I(state) is C(present) or C(exported).\nWhen I(state) is C(absent) and I(thumbprint) is not specified, the thumbprint is derived from the certificate at this path."
                     },
                     "thumbprint": {
                        "type": "string",
                        "description": "The thumbprint as a hex string to either export or remove.\nSee the examples for how to specify the thumbprint."
                     },
                     "store_name": {
                        "type": "string",
                        "description": "Default: My\n\nThe store name to use when importing a certificate or searching for a certificate.\nC(AddressBook): The X.509 certificate store for other users\nC(AuthRoot): The X.509 certificate store for third-party certificate authorities (CAs)\nC(CertificateAuthority): The X.509 certificate store for intermediate certificate authorities (CAs)\nC(Disallowed): The X.509 certificate store for revoked certificates\nC(My): The X.509 certificate store for personal certificates\nC(Root): The X.509 certificate store for trusted root certificate authorities (CAs)\nC(TrustedPeople): The X.509 certificate store for directly trusted people and resources\nC(TrustedPublisher): The X.509 certificate store for directly trusted publishers",
                        "enum": [
                           "AddressBook",
                           "AuthRoot",
                           "CertificateAuthority",
                           "Disallowed",
                           "My",
                           "Root",
                           "TrustedPeople",
                           "TrustedPublisher"
                        ]
                     },
                     "store_location": {
                        "type": "string",
                        "description": "Default: LocalMachine\n\nThe store location to use when importing a certificate or searching for a certificate.",
                        "enum": [
                           "CurrentUser",
                           "LocalMachine"
                        ]
                     },
                     "password": {
                        "type": "string",
                        "description": "The password of the pkcs12 certificate key.\nThis is used when reading a pkcs12 certificate file or the password to set when C(state=exported) and C(file_type=pkcs12).\nIf the pkcs12 file has no password set or no password should be set on the exported file, do not set this option."
                     },
                     "key_exportable": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nWhether to allow the private key to be exported.\nIf C(no), then this module and other process will only be able to export the certificate and the private key cannot be exported.\nUsed when C(state=present) only."
                     },
                     "key_storage": {
                        "type": "string",
                        "description": "Default: default\n\nSpecifies where Windows will store the private key when it is imported.\nWhen set to C(default), the default option as set by Windows is used, typically C(user).\nWhen set to C(machine), the key is stored in a path accessible by various users.\nWhen set to C(user), the key is stored in a path only accessible by the current user.\nUsed when C(state=present) only and cannot be changed once imported.\nSee U(https://msdn.microsoft.com/en-us/library/system.security.cryptography.x509certificates.x509keystorageflags.aspx) for more details.",
                        "enum": [
                           "default",
                           "machine",
                           "user"
                        ]
                     },
                     "file_type": {
                        "type": "string",
                        "description": "Default: der\n\nThe file type to export the certificate as when C(state=exported).\nC(der) is a binary ASN.1 encoded file.\nC(pem) is a base64 encoded file of a der file in the OpenSSL form.\nC(pkcs12) (also known as pfx) is a binary container that contains both the certificate and private key unlike the other options.\nWhen C(pkcs12) is set and the private key is not exportable or accessible by the current user, it will throw an exception.",
                        "enum": [
                           "der",
                           "pem",
                           "pkcs12"
                        ]
                     }
                  }
               },
               "win_audit_rule": {
                  "type": "object",
                  "description": "Used to apply audit rules to files, folders or registry keys.\nOnce applied, it will begin recording the user who performed the operation defined into the Security Log in the Event viewer.\nThe behavior is designed to ignore inherited rules since those cannot be adjusted without first disabling the inheritance behavior. It will still print inherited rules in the output though for debugging purposes.",
                  "properties": {
                     "path": {
                        "type": "string",
                        "description": "Path to the file, folder, or registry key.\nRegistry paths should be in Powershell format, beginning with an abbreviation for the root such as, C(HKLM:\\Software)."
                     },
                     "dest": {
                        "type": "string",
                        "description": "Path to the file, folder, or registry key.\nRegistry paths should be in Powershell format, beginning with an abbreviation for the root such as, C(HKLM:\\Software)."
                     },
                     "destination": {
                        "type": "string",
                        "description": "Path to the file, folder, or registry key.\nRegistry paths should be in Powershell format, beginning with an abbreviation for the root such as, C(HKLM:\\Software)."
                     },
                     "user": {
                        "type": "string",
                        "description": "The user or group to adjust rules for."
                     },
                     "rights": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Comma separated list of the rights desired. Only required for adding a rule.\nIf I(path) is a file or directory, rights can be any right under MSDN FileSystemRights U(https://msdn.microsoft.com/en-us/library/system.security.accesscontrol.filesystemrights.aspx).\nIf I(path) is a registry key, rights can be any right under MSDN RegistryRights U(https://msdn.microsoft.com/en-us/library/system.security.accesscontrol.registryrights.aspx)."
                     },
                     "inheritance_flags": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Default: ContainerInherit,ObjectInherit\n\nDefines what objects inside of a folder or registry key will inherit the settings.\nIf you are setting a rule on a file, this value has to be changed to C(none).\nFor more information on the choices see MSDN PropagationFlags enumeration at U(https://msdn.microsoft.com/en-us/library/system.security.accesscontrol.inheritanceflags.aspx)."
                     },
                     "propagation_flags": {
                        "type": "string",
                        "description": "Default: None\n\nPropagation flag on the audit rules.\nThis value is ignored when the path type is a file.\nFor more information on the choices see MSDN PropagationFlags enumeration at U(https://msdn.microsoft.com/en-us/library/system.security.accesscontrol.propagationflags.aspx).",
                        "enum": [
                           "None",
                           "InherityOnly",
                           "NoPropagateInherit"
                        ]
                     },
                     "audit_flags": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Defines whether to log on failure, success, or both.\nTo log both define as comma separated list \"Success, Failure\"."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the rule should be C(present) or C(absent).\nFor absent, only I(path), I(user), and I(state) are required.\nSpecifying C(absent) will remove all rules matching the defined I(user).",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "path",
                                    "dest",
                                    "destination"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "path"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "dest"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "destination"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "win_audit_policy_system": {
                  "type": "object",
                  "description": "Used to make changes to the system wide Audit Policy.",
                  "properties": {
                     "category": {
                        "type": "string",
                        "description": "Single string value for the category you would like to adjust the policy on.\nCannot be used with I(subcategory). You must define one or the other.\nChanging this setting causes all subcategories to be adjusted to the defined I(audit_type)."
                     },
                     "subcategory": {
                        "type": "string",
                        "description": "Single string value for the subcategory you would like to adjust the policy on.\nCannot be used with I(category). You must define one or the other."
                     },
                     "audit_type": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "The type of event you would like to audit for.\nAccepts a list. See examples."
                     }
                  },
                  "required": [
                     "audit_type"
                  ]
               },
               "win_acl_inheritance": {
                  "type": "object",
                  "description": "Change ACL (Access Control List) inheritance and optionally copy inherited ACE's (Access Control Entry) to dedicated ACE's or vice versa.",
                  "properties": {
                     "path": {
                        "type": "string",
                        "description": "Path to be used for changing inheritance"
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: absent\n\nSpecify whether to enable I(present) or disable I(absent) ACL inheritance.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "reorganize": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "For P(state) = I(absent), indicates if the inherited ACE's should be copied from the parent directory. This is necessary (in combination with removal) for a simple ACL instead of using multiple ACE deny entries.\nFor P(state) = I(present), indicates if the inherited ACE's should be deduplicated compared to the parent directory. This removes complexity of the ACL structure."
                     }
                  },
                  "required": [
                     "path"
                  ]
               },
               "win_acl": {
                  "type": "object",
                  "description": "Add or remove rights/permissions for a given user or group for the specified file, folder, registry key or AppPool identifies.",
                  "properties": {
                     "path": {
                        "type": "string",
                        "description": "The path to the file or directory."
                     },
                     "user": {
                        "type": "string",
                        "description": "User or Group to add specified rights to act on src file/folder or registry key."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nSpecify whether to add C(present) or remove C(absent) the specified access rule.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "type": {
                        "type": "string",
                        "description": "Specify whether to allow or deny the rights specified.",
                        "enum": [
                           "allow",
                           "deny"
                        ]
                     },
                     "rights": {
                        "type": "string",
                        "description": "The rights/permissions that are to be allowed/denied for the specified user or group for the item at C(path).\nIf C(path) is a file or directory, rights can be any right under MSDN FileSystemRights U(https://msdn.microsoft.com/en-us/library/system.security.accesscontrol.filesystemrights.aspx).\nIf C(path) is a registry key, rights can be any right under MSDN RegistryRights U(https://msdn.microsoft.com/en-us/library/system.security.accesscontrol.registryrights.aspx)."
                     },
                     "inherit": {
                        "type": "string",
                        "description": "Inherit flags on the ACL rules.\nCan be specified as a comma separated list, e.g. C(ContainerInherit), C(ObjectInherit).\nFor more information on the choices see MSDN InheritanceFlags enumeration at U(https://msdn.microsoft.com/en-us/library/system.security.accesscontrol.inheritanceflags.aspx).\nDefaults to C(ContainerInherit, ObjectInherit) for Directories.",
                        "enum": [
                           "ContainerInherit",
                           "ObjectInherit"
                        ]
                     },
                     "propagation": {
                        "type": "string",
                        "description": "Default: None\n\nPropagation flag on the ACL rules.\nFor more information on the choices see MSDN PropagationFlags enumeration at U(https://msdn.microsoft.com/en-us/library/system.security.accesscontrol.propagationflags.aspx).",
                        "enum": [
                           "InheritOnly",
                           "None",
                           "NoPropagateInherit"
                        ]
                     }
                  },
                  "required": [
                     "path",
                     "user",
                     "type",
                     "rights"
                  ]
               },
               "taiga_issue": {
                  "type": "object",
                  "description": "Creates/deletes an issue in a Taiga Project Management Platform (U(https://taiga.io)).\nAn issue is identified by the combination of project, issue subject and issue type.\nThis module implements the creation or deletion of issues (not the update).",
                  "properties": {
                     "taiga_host": {
                        "type": "string",
                        "description": "Default: https://api.taiga.io\n\nThe hostname of the Taiga instance."
                     },
                     "project": {
                        "type": "string",
                        "description": "Name of the project containing the issue. Must exist previously."
                     },
                     "subject": {
                        "type": "string",
                        "description": "The issue subject."
                     },
                     "issue_type": {
                        "type": "string",
                        "description": "The issue type. Must exist previously."
                     },
                     "priority": {
                        "type": "string",
                        "description": "Default: Normal\n\nThe issue priority. Must exist previously."
                     },
                     "status": {
                        "type": "string",
                        "description": "Default: New\n\nThe issue status. Must exist previously."
                     },
                     "severity": {
                        "type": "string",
                        "description": "Default: Normal\n\nThe issue severity. Must exist previously."
                     },
                     "description": {
                        "type": "string",
                        "description": "The issue description."
                     },
                     "attachment": {
                        "type": "string",
                        "description": "Path to a file to be attached to the issue."
                     },
                     "attachment_description": {
                        "type": "string",
                        "description": "A string describing the file to be attached to the issue."
                     },
                     "tags": {
                        "type": "string",
                        "description": "A lists of tags to be assigned to the issue."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the issue should be present or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     }
                  },
                  "required": [
                     "project",
                     "subject",
                     "issue_type"
                  ]
               },
               "supervisorctl": {
                  "type": "object",
                  "description": "Manage the state of a program or group of programs running via supervisord",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name of the supervisord program or group to manage.\nThe name will be taken as group name when it ends with a colon I(:)\nGroup support is only available in Ansible version 1.6 or later."
                     },
                     "config": {
                        "type": "string",
                        "description": "The supervisor configuration file path"
                     },
                     "server_url": {
                        "type": "string",
                        "description": "URL on which supervisord server is listening"
                     },
                     "username": {
                        "type": "string",
                        "description": "username to use for authentication"
                     },
                     "password": {
                        "type": "string",
                        "description": "password to use for authentication"
                     },
                     "state": {
                        "type": "string",
                        "description": "The desired state of program/group.",
                        "enum": [
                           "present",
                           "started",
                           "stopped",
                           "restarted",
                           "absent",
                           "signalled"
                        ]
                     },
                     "signal": {
                        "type": "string",
                        "description": "The signal to send to the program/group, when combined with the 'signalled' state. Required when l(state=signalled)."
                     },
                     "supervisorctl_path": {
                        "type": "string",
                        "description": "path to supervisorctl executable"
                     }
                  },
                  "required": [
                     "name",
                     "state"
                  ]
               },
               "rundeck_project": {
                  "type": "object",
                  "description": "Create and remove Rundeck projects through HTTP API.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nCreate or remove Rundeck project.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "Sets the project name."
                     },
                     "url": {
                        "type": "string",
                        "description": "Sets the rundeck instance URL."
                     },
                     "api_version": {
                        "type": "string",
                        "description": "Default: 14\n\nSets the API version used by module.\nAPI version must be at least 14."
                     },
                     "token": {
                        "type": "string",
                        "description": "Sets the token to authenticate against Rundeck API."
                     }
                  },
                  "required": [
                     "name",
                     "url",
                     "token"
                  ]
               },
               "rundeck_acl_policy": {
                  "type": "object",
                  "description": "Create, update and remove Rundeck ACL policies through HTTP API.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nCreate or remove Rundeck project.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "Sets the project name."
                     },
                     "url": {
                        "type": "string",
                        "description": "Sets the rundeck instance URL."
                     },
                     "api_version": {
                        "type": "string",
                        "description": "Default: 14\n\nSets the API version used by module.\nAPI version must be at least 14."
                     },
                     "token": {
                        "type": "string",
                        "description": "Sets the token to authenticate against Rundeck API."
                     },
                     "project": {
                        "type": "string",
                        "description": "Sets the project which receive the ACL policy.\nIf unset, it's a system ACL policy."
                     },
                     "policy": {
                        "type": "string",
                        "description": "Sets the ACL policy content.\nACL policy content is a YAML object as described in http://rundeck.org/docs/man5/aclpolicy.html.\nIt can be a YAML string or a pure Ansible inventory YAML object."
                     }
                  },
                  "required": [
                     "name",
                     "url",
                     "token"
                  ]
               },
               "nginx_status_info": {
                  "type": "object",
                  "description": "Gathers information from nginx from an URL having C(stub_status) enabled.",
                  "properties": {
                     "url": {
                        "type": "string",
                        "description": "URL of the nginx status."
                     },
                     "timeout": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 10\n\nHTTP connection timeout in seconds."
                     }
                  },
                  "required": [
                     "url"
                  ]
               },
               "jira": {
                  "type": "object",
                  "description": "Create and modify issues in a JIRA instance.",
                  "properties": {
                     "uri": {
                        "type": "string",
                        "description": "Base URI for the JIRA instance."
                     },
                     "operation": {
                        "type": "string",
                        "description": "The operation to perform.",
                        "enum": [
                           "create",
                           "comment",
                           "edit",
                           "fetch",
                           "transition",
                           "link"
                        ]
                     },
                     "command": {
                        "type": "string",
                        "description": "The operation to perform.",
                        "enum": [
                           "create",
                           "comment",
                           "edit",
                           "fetch",
                           "transition",
                           "link"
                        ]
                     },
                     "username": {
                        "type": "string",
                        "description": "The username to log-in with."
                     },
                     "password": {
                        "type": "string",
                        "description": "The password to log-in with."
                     },
                     "project": {
                        "type": "string",
                        "description": "The project for this operation. Required for issue creation."
                     },
                     "summary": {
                        "type": "string",
                        "description": "The issue summary, where appropriate."
                     },
                     "description": {
                        "type": "string",
                        "description": "The issue description, where appropriate."
                     },
                     "issuetype": {
                        "type": "string",
                        "description": "The issue type, for issue creation."
                     },
                     "issue": {
                        "type": "string",
                        "description": "An existing issue key to operate on."
                     },
                     "comment": {
                        "type": "string",
                        "description": "The comment text to add."
                     },
                     "status": {
                        "type": "string",
                        "description": "The desired status; only relevant for the transition operation."
                     },
                     "assignee": {
                        "type": "string",
                        "description": "Sets the assignee on create or transition operations. Note not all transitions will allow this."
                     },
                     "linktype": {
                        "type": "string",
                        "description": "Set type of link, when action 'link' selected."
                     },
                     "inwardissue": {
                        "type": "string",
                        "description": "Set issue from which link will be created."
                     },
                     "outwardissue": {
                        "type": "string",
                        "description": "Set issue to which link will be created."
                     },
                     "fields": {
                        "type": "string",
                        "description": "This is a free-form data structure that can contain arbitrary data. This is passed directly to the JIRA REST API (possibly after merging with other required data, as when passed to create). See examples for more information, and the JIRA REST API for the structure required for various fields."
                     },
                     "timeout": {
                        "type": "string",
                        "description": "Default: 10\n\nSet timeout, in seconds, on requests to JIRA API."
                     },
                     "validate_certs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nRequire valid SSL certificates (set to `false` if you'd like to use self-signed certificates)"
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "operation",
                                    "command"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "operation"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "command"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "jenkins_script": {
                  "type": "object",
                  "description": "The C(jenkins_script) module takes a script plus a dict of values to use within the script and returns the result of the script being run.",
                  "properties": {
                     "script": {
                        "type": "string",
                        "description": "The groovy script to be executed. This gets passed as a string Template if args is defined."
                     },
                     "url": {
                        "type": "string",
                        "description": "Default: http://localhost:8080\n\nThe jenkins server to execute the script against. The default is a local jenkins instance that is not being proxied through a webserver."
                     },
                     "validate_certs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nIf set to C(no), the SSL certificates will not be validated. This should only set to C(no) used on personally controlled sites using self-signed certificates as it avoids verifying the source site."
                     },
                     "user": {
                        "type": "string",
                        "description": "The username to connect to the jenkins server with."
                     },
                     "password": {
                        "type": "string",
                        "description": "The password to connect to the jenkins server with."
                     },
                     "timeout": {
                        "type": "string",
                        "description": "Default: 10\n\nThe request timeout in seconds"
                     },
                     "args": {
                        "type": "string",
                        "description": "A dict of key-value pairs used in formatting the script using string.Template (see https://docs.python.org/2/library/string.html#template-strings)."
                     }
                  },
                  "required": [
                     "script"
                  ]
               },
               "jenkins_plugin": {
                  "type": "object",
                  "description": "Ansible module which helps to manage Jenkins plugins.",
                  "properties": {
                     "group": {
                        "type": "string",
                        "description": "Default: jenkins\n\nName of the Jenkins group on the OS."
                     },
                     "jenkins_home": {
                        "type": "string",
                        "description": "Default: /var/lib/jenkins\n\nHome directory of the Jenkins user."
                     },
                     "mode": {
                        "type": "string",
                        "description": "Default: 0644\n\nFile mode applied on versioned plugins."
                     },
                     "name": {
                        "type": "string",
                        "description": "Plugin name."
                     },
                     "owner": {
                        "type": "string",
                        "description": "Default: jenkins\n\nName of the Jenkins user on the OS."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDesired plugin state.\nIf the C(latest) is set, the check for new version will be performed every time. This is suitable to keep the plugin up-to-date.",
                        "enum": [
                           "absent",
                           "present",
                           "pinned",
                           "unpinned",
                           "enabled",
                           "disabled",
                           "latest"
                        ]
                     },
                     "timeout": {
                        "type": "string",
                        "description": "Default: 30\n\nServer connection timeout in secs."
                     },
                     "updates_expiration": {
                        "type": "string",
                        "description": "Default: 86400\n\nNumber of seconds after which a new copy of the I(update-center.json) file is downloaded. This is used to avoid the need to download the plugin to calculate its checksum when C(latest) is specified.\nSet it to C(0) if no cache file should be used. In that case, the plugin file will always be downloaded to calculate its checksum when C(latest) is specified."
                     },
                     "updates_url": {
                        "type": "string",
                        "description": "Default: https://updates.jenkins.io\n\nURL of the Update Centre.\nUsed as the base URL to download the plugins and the I(update-center.json) JSON file."
                     },
                     "url": {
                        "type": "string",
                        "description": "Default: http://localhost:8080\n\nURL of the Jenkins server."
                     },
                     "version": {
                        "type": "string",
                        "description": "Plugin version number.\nIf this option is specified, all plugin dependencies must be installed manually.\nIt might take longer to verify that the correct version is installed. This is especially true if a specific version number is specified.\nQuote the version to prevent the value to be interpreted as float. For example if C(1.20) would be unquoted, it would become C(1.2)."
                     },
                     "with_dependencies": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nDefines whether to install plugin dependencies.\nThis option takes effect only if the I(version) is not defined."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "jenkins_job_info": {
                  "type": "object",
                  "description": "This module can be used to query information about which Jenkins jobs which already exists.\nThis module was called C(jenkins_job_info) before Ansible 2.9. The usage did not change.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Exact name of the Jenkins job to fetch information about."
                     },
                     "glob": {
                        "type": "string",
                        "description": "A shell glob of Jenkins job names to fetch information about."
                     },
                     "color": {
                        "type": "string",
                        "description": "Only fetch jobs with the given status color."
                     },
                     "password": {
                        "type": "string",
                        "description": "Password to authenticate with the Jenkins server.\nThis is a required parameter, if C(token) is not provided."
                     },
                     "token": {
                        "type": "string",
                        "description": "API token used to authenticate with the Jenkins server.\nThis is a required parameter, if C(password) is not provided."
                     },
                     "url": {
                        "type": "string",
                        "description": "Default: http://localhost:8080\n\nURL where the Jenkins server is accessible."
                     },
                     "user": {
                        "type": "string",
                        "description": "User to authenticate with the Jenkins server."
                     },
                     "validate_certs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nIf set to C(False), the SSL certificates will not be validated.\nThis should only set to C(False) used on personally controlled sites using self-signed certificates."
                     }
                  }
               },
               "jenkins_job": {
                  "type": "object",
                  "description": "Manage Jenkins jobs by using Jenkins REST API.",
                  "properties": {
                     "config": {
                        "type": "string",
                        "description": "config in XML format.\nRequired if job does not yet exist.\nMutually exclusive with C(enabled).\nConsidered if C(state=present)."
                     },
                     "enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether the job should be enabled or disabled.\nMutually exclusive with C(config).\nConsidered if C(state=present)."
                     },
                     "name": {
                        "type": "string",
                        "description": "Name of the Jenkins job."
                     },
                     "password": {
                        "type": "string",
                        "description": "Password to authenticate with the Jenkins server."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nAttribute that specifies if the job has to be created or deleted.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "token": {
                        "type": "string",
                        "description": "API token used to authenticate alternatively to password."
                     },
                     "url": {
                        "type": "string",
                        "description": "Default: http://localhost:8080\n\nURL where the Jenkins server is accessible."
                     },
                     "user": {
                        "type": "string",
                        "description": "User to authenticate with the Jenkins server."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "jboss": {
                  "type": "object",
                  "description": "Deploy applications to JBoss standalone using the filesystem.",
                  "properties": {
                     "deployment": {
                        "type": "string",
                        "description": "The name of the deployment."
                     },
                     "src": {
                        "type": "string",
                        "description": "The remote path of the application ear or war to deploy.\nRequired when I(state=present).\nIgnored when I(state=absent)."
                     },
                     "deploy_path": {
                        "type": "string",
                        "description": "Default: /var/lib/jbossas/standalone/deployments\n\nThe location in the filesystem where the deployment scanner listens."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the application should be deployed or undeployed.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     }
                  },
                  "required": [
                     "deployment"
                  ]
               },
               "htpasswd": {
                  "type": "object",
                  "description": "Add and remove username/password entries in a password file using htpasswd.\nThis is used by web servers such as Apache and Nginx for basic authentication.",
                  "properties": {
                     "path": {
                        "type": "string",
                        "description": "Path to the file that contains the usernames and passwords"
                     },
                     "dest": {
                        "type": "string",
                        "description": "Path to the file that contains the usernames and passwords"
                     },
                     "destfile": {
                        "type": "string",
                        "description": "Path to the file that contains the usernames and passwords"
                     },
                     "name": {
                        "type": "string",
                        "description": "User name to add or remove"
                     },
                     "username": {
                        "type": "string",
                        "description": "User name to add or remove"
                     },
                     "password": {
                        "type": "string",
                        "description": "Password associated with user.\nMust be specified if user does not exist yet."
                     },
                     "crypt_scheme": {
                        "type": "string",
                        "description": "Default: apr_md5_crypt\n\nEncryption scheme to be used.  As well as the four choices listed here, you can also use any other hash supported by passlib, such as md5_crypt and sha256_crypt, which are linux passwd hashes.  If you do so the password file will not be compatible with Apache or Nginx",
                        "enum": [
                           "apr_md5_crypt",
                           "des_crypt",
                           "ldap_sha1",
                           "plaintext"
                        ]
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the user entry should be present or not",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "create": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nUsed with C(state=present). If specified, the file will be created if it does not already exist. If set to \"no\", will fail if the file does not exist"
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "path",
                                    "dest",
                                    "destfile"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "path"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "dest"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "destfile"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "username"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "username"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "gunicorn": {
                  "type": "object",
                  "description": "Starts gunicorn with the parameters specified. Common settings for gunicorn configuration are supported. For additional configuration use a config file See U(https://gunicorn-docs.readthedocs.io/en/latest/settings.html) for more options. It's recommended to always use the chdir option to avoid problems with the location of the app.",
                  "properties": {
                     "app": {
                        "type": "string",
                        "description": "The app module. A name refers to a WSGI callable that should be found in the specified module."
                     },
                     "name": {
                        "type": "string",
                        "description": "The app module. A name refers to a WSGI callable that should be found in the specified module."
                     },
                     "venv": {
                        "type": "string",
                        "description": "Path to the virtualenv directory."
                     },
                     "virtualenv": {
                        "type": "string",
                        "description": "Path to the virtualenv directory."
                     },
                     "config": {
                        "type": "string",
                        "description": "Path to the gunicorn configuration file."
                     },
                     "chdir": {
                        "type": "string",
                        "description": "Chdir to specified directory before apps loading."
                     },
                     "pid": {
                        "type": "string",
                        "description": "A filename to use for the PID file. If not set and not found on the configuration file a tmp pid file will be created to check a successful run of gunicorn."
                     },
                     "worker": {
                        "type": "string",
                        "description": "The type of workers to use. The default class (sync) should handle most \"normal\" types of workloads.\n\nPossible choices:\nsync\neventlet\ngevent\ntornado \ngthread\ngaiohttp"
                     },
                     "user": {
                        "type": "string",
                        "description": "Switch worker processes to run as this user."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "app",
                                    "name"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "app"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "venv",
                                    "virtualenv"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "ejabberd_user": {
                  "type": "object",
                  "description": "This module provides user management for ejabberd servers",
                  "properties": {
                     "username": {
                        "type": "string",
                        "description": "the name of the user to manage"
                     },
                     "host": {
                        "type": "string",
                        "description": "the ejabberd host associated with this username"
                     },
                     "password": {
                        "type": "string",
                        "description": "the password to assign to the username"
                     },
                     "logging": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "enables or disables the local syslog facility for this module"
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\ndescribe the desired state of the user to be managed",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     }
                  },
                  "required": [
                     "username",
                     "host"
                  ]
               },
               "deploy_helper": {
                  "type": "object",
                  "description": "The Deploy Helper manages some of the steps common in deploying software. It creates a folder structure, manages a symlink for the current release and cleans up old releases.\nRunning it with the C(state=query) or C(state=present) will return the C(deploy_helper) fact. C(project_path), whatever you set in the path parameter, C(current_path), the path to the symlink that points to the active release, C(releases_path), the path to the folder to keep releases in, C(shared_path), the path to the folder to keep shared resources in, C(unfinished_filename), the file to check for to recognize unfinished builds, C(previous_release), the release the 'current' symlink is pointing to, C(previous_release_path), the full path to the 'current' symlink target, C(new_release), either the 'release' parameter or a generated timestamp, C(new_release_path), the path to the new release folder (not created by the module).",
                  "properties": {
                     "path": {
                        "type": "string",
                        "description": "the root path of the project. Alias I(dest). Returned in the C(deploy_helper.project_path) fact."
                     },
                     "dest": {
                        "type": "string",
                        "description": "the root path of the project. Alias I(dest). Returned in the C(deploy_helper.project_path) fact."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nthe state of the project. C(query) will only gather facts, C(present) will create the project I(root) folder, and in it the I(releases) and I(shared) folders, C(finalize) will remove the unfinished_filename file, create a symlink to the newly deployed release and optionally clean old releases, C(clean) will remove failed & old releases, C(absent) will remove the project folder (synonymous to the M(file) module with C(state=absent))",
                        "enum": [
                           "present",
                           "finalize",
                           "absent",
                           "clean",
                           "query"
                        ]
                     },
                     "release": {
                        "type": "string",
                        "description": "the release version that is being deployed. Defaults to a timestamp format %Y%m%d%H%M%S (i.e. '20141119223359'). This parameter is optional during C(state=present), but needs to be set explicitly for C(state=finalize). You can use the generated fact C(release={{ deploy_helper.new_release }})."
                     },
                     "releases_path": {
                        "type": "string",
                        "description": "Default: releases\n\nthe name of the folder that will hold the releases. This can be relative to C(path) or absolute. Returned in the C(deploy_helper.releases_path) fact."
                     },
                     "shared_path": {
                        "type": "string",
                        "description": "Default: shared\n\nthe name of the folder that will hold the shared resources. This can be relative to C(path) or absolute. If this is set to an empty string, no shared folder will be created. Returned in the C(deploy_helper.shared_path) fact."
                     },
                     "current_path": {
                        "type": "string",
                        "description": "Default: current\n\nthe name of the symlink that is created when the deploy is finalized. Used in C(finalize) and C(clean). Returned in the C(deploy_helper.current_path) fact."
                     },
                     "unfinished_filename": {
                        "type": "string",
                        "description": "Default: DEPLOY_UNFINISHED\n\nthe name of the file that indicates a deploy has not finished. All folders in the releases_path that contain this file will be deleted on C(state=finalize) with clean=True, or C(state=clean). This file is automatically deleted from the I(new_release_path) during C(state=finalize)."
                     },
                     "clean": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nWhether to run the clean procedure in case of C(state=finalize)."
                     },
                     "keep_releases": {
                        "type": "string",
                        "description": "Default: 5\n\nthe number of old releases to keep when cleaning. Used in C(finalize) and C(clean). Any unfinished builds will be deleted first, so only correct releases will count. The current version will not count."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "path",
                                    "dest"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "path"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "dest"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "apache2_module": {
                  "type": "object",
                  "description": "Enables or disables a specified module of the Apache2 webserver.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the module to enable/disable as given to C(a2enmod/a2dismod)."
                     },
                     "identifier": {
                        "type": "string",
                        "description": "Identifier of the module as listed by C(apache2ctl -M). This is optional and usually determined automatically by the common convention of appending C(_module) to I(name) as well as custom exception for popular modules."
                     },
                     "force": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Force disabling of default modules and override Debian warnings."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDesired state of the module.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "ignore_configcheck": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Ignore configuration checks about inconsistent module configuration. Especially for mpm_* modules."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "apache2_mod_proxy": {
                  "type": "object",
                  "description": "Set and/or get members' attributes of an Apache httpd 2.4 mod_proxy balancer pool, using HTTP POST and GET requests. The httpd mod_proxy balancer-member status page has to be enabled and accessible, as this module relies on parsing this page. This module supports ansible check_mode, and requires BeautifulSoup python module.",
                  "properties": {
                     "balancer_url_suffix": {
                        "type": "string",
                        "description": "Default: /balancer-manager/\n\nSuffix of the balancer pool url required to access the balancer pool status page (e.g. balancer_vhost[:port]/balancer_url_suffix)."
                     },
                     "balancer_vhost": {
                        "type": "string",
                        "description": "(ipv4|ipv6|fqdn):port of the Apache httpd 2.4 mod_proxy balancer pool."
                     },
                     "member_host": {
                        "type": "string",
                        "description": "(ipv4|ipv6|fqdn) of the balancer member to get or to set attributes to. Port number is autodetected and should not be specified here. If undefined, apache2_mod_proxy module will return a members list of dictionaries of all the current balancer pool members' attributes."
                     },
                     "state": {
                        "type": "string",
                        "description": "Desired state of the member host. (absent|disabled),drained,hot_standby,ignore_errors can be simultaneously invoked by separating them with a comma (e.g. state=drained,ignore_errors).",
                        "enum": [
                           "present",
                           "absent",
                           "enabled",
                           "disabled",
                           "drained",
                           "hot_standby",
                           "ignore_errors"
                        ]
                     },
                     "tls": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nUse https to access balancer management page."
                     },
                     "validate_certs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nValidate ssl/tls certificates."
                     }
                  },
                  "required": [
                     "balancer_vhost"
                  ]
               },
               "nginx_status_facts": {
                  "type": "object",
                  "description": "Gathers facts from nginx from an URL having C(stub_status) enabled.",
                  "properties": {
                     "url": {
                        "type": "string",
                        "description": "URL of the nginx status."
                     },
                     "timeout": {
                        "type": "string",
                        "description": "Default: 10\n\nHTTP connection timeout in seconds."
                     }
                  },
                  "required": [
                     "url"
                  ]
               },
               "utm_proxy_location_info": {
                  "type": "object",
                  "description": "Create, update or destroy a reverse_proxy location entry in SOPHOS UTM.\nThis module needs to have the REST Ability of the UTM to be activated.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name of the object. Will be used to identify the entry"
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "utm_proxy_location": {
                  "type": "object",
                  "description": "Create, update or destroy a reverse_proxy location entry in SOPHOS UTM.\nThis module needs to have the REST Ability of the UTM to be activated.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name of the object. Will be used to identify the entry"
                     },
                     "access_control": {
                        "type": "string",
                        "description": "Default: 0\n\nwhether to activate the access control for the location",
                        "enum": [
                           "0",
                           "1"
                        ]
                     },
                     "allowed_networks": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Default: REF_NetworkAny\n\nA list of allowed networks"
                     },
                     "auth_profile": {
                        "type": "string",
                        "description": "The reference name of the auth profile"
                     },
                     "backend": {
                        "type": "string",
                        "description": "A list of backends that are connected with this location declaration"
                     },
                     "be_path": {
                        "type": "string",
                        "description": "The path of the backend"
                     },
                     "comment": {
                        "type": "string",
                        "description": "The optional comment string"
                     },
                     "denied_networks": {
                        "type": "string",
                        "description": "A list of denied network references"
                     },
                     "hot_standby": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Activate hot standby mode"
                     },
                     "path": {
                        "type": "string",
                        "description": "Default: /\n\nThe path of the location"
                     },
                     "status": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nWhether the location is active or not"
                     },
                     "stickysession_id": {
                        "type": "string",
                        "description": "Default: ROUTEID\n\nThe stickysession id"
                     },
                     "stickysession_status": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Enable the stickysession"
                     },
                     "websocket_passthrough": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Enable the websocket passthrough"
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "utm_proxy_frontend_info": {
                  "type": "object",
                  "description": "Create, update or destroy a reverse_proxy frontend entry in SOPHOS UTM.\nThis module needs to have the REST Ability of the UTM to be activated.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name of the object. Will be used to identify the entry"
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "utm_proxy_frontend": {
                  "type": "object",
                  "description": "Create, update or destroy a reverse_proxy frontend entry in Sophos UTM.\nThis module needs to have the REST Ability of the UTM to be activated.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name of the object. Will be used to identify the entry"
                     },
                     "add_content_type_header": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether to add the content type header or not"
                     },
                     "address": {
                        "type": "string",
                        "description": "Default: REF_DefaultInternalAddress\n\nThe reference name of the network/interface_address object."
                     },
                     "allowed_networks": {
                        "type": "string",
                        "description": "Default: ['REF_NetworkAny']\n\nA list of reference names for the allowed networks."
                     },
                     "certificate": {
                        "type": "string",
                        "description": "The reference name of the ca/host_key_cert object."
                     },
                     "comment": {
                        "type": "string",
                        "description": "An optional comment to add to the object"
                     },
                     "disable_compression": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether to enable the compression"
                     },
                     "domain": {
                        "type": "string",
                        "description": "A list of domain names for the frontend object"
                     },
                     "exceptions": {
                        "type": "string",
                        "description": "A list of exception ref names (reverse_proxy/exception)"
                     },
                     "htmlrewrite": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether to enable html rewrite or not"
                     },
                     "htmlrewrite_cookies": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether to enable html rewrite cookie or not"
                     },
                     "implicitredirect": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether to enable implicit redirection or not"
                     },
                     "lbmethod": {
                        "type": "string",
                        "description": "Default: bybusyness\n\nWhich loadbalancer method should be used",
                        "enum": [
                           "",
                           "bybusyness",
                           "bytraffic",
                           "byrequests"
                        ]
                     },
                     "locations": {
                        "type": "string",
                        "description": "A list of location ref names (reverse_proxy/location)"
                     },
                     "port": {
                        "type": "string",
                        "description": "Default: 80\n\nThe frontend http port"
                     },
                     "preservehost": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether to preserve host header"
                     },
                     "profile": {
                        "type": "string",
                        "description": "The reference string of the reverse_proxy/profile"
                     },
                     "status": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nWhether to activate the frontend entry or not"
                     },
                     "type": {
                        "type": "string",
                        "description": "Default: http\n\nWhich protocol should be used",
                        "enum": [
                           "http",
                           "https"
                        ]
                     },
                     "xheaders": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether to pass the host header or not"
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "utm_proxy_exception": {
                  "type": "object",
                  "description": "Create, update or destroy a reverse_proxy exception entry in SOPHOS UTM.\nThis module needs to have the REST Ability of the UTM to be activated.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name of the object. Will be used to identify the entry"
                     },
                     "op": {
                        "type": "string",
                        "description": "Default: AND\n\nThe operand to be used with the entries of the path parameter",
                        "enum": [
                           "AND",
                           "OR"
                        ]
                     },
                     "path": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "The paths the exception in the reverse proxy is defined for"
                     },
                     "skip_custom_threats_filters": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "A list of threats to be skipped"
                     },
                     "skip_threats_filter_categories": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Define which categories of threats are skipped"
                     },
                     "skipav": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Skip the Antivirus Scanning"
                     },
                     "skipbadclients": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Block clients with bad reputation"
                     },
                     "skipcookie": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Skip the Cookie Signing check"
                     },
                     "skipform": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Enable form hardening"
                     },
                     "skipform_missingtoken": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Enable form hardening with missing tokens"
                     },
                     "skiphtmlrewrite": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Protection against SQL"
                     },
                     "skiptft": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Enable true file type control"
                     },
                     "skipurl": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Enable static URL hardening"
                     },
                     "source": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Define which categories of threats are skipped"
                     },
                     "status": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nStatus of the exception rule set"
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "utm_proxy_auth_profile": {
                  "type": "object",
                  "description": "Create, update or destroy a reverse_proxy auth_profile entry in SOPHOS UTM.\nThis module needs to have the REST Ability of the UTM to be activated.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name of the object. Will be used to identify the entry"
                     },
                     "aaa": {
                        "type": "array",
                        "description": "List of references to utm_aaa objects (allowed users or groups)"
                     },
                     "basic_prompt": {
                        "type": "string",
                        "description": "The message in the basic authentication prompt"
                     },
                     "backend_mode": {
                        "type": "string",
                        "description": "Default: None\n\nSpecifies if the backend server needs authentication ([Basic|None])",
                        "enum": [
                           "Basic",
                           "None"
                        ]
                     },
                     "backend_strip_basic_auth": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nShould the login data be stripped when proxying the request to the backend host"
                     },
                     "backend_user_prefix": {
                        "type": "string",
                        "description": "Prefix string to prepend to the username for backend authentication"
                     },
                     "backend_user_suffix": {
                        "type": "string",
                        "description": "Suffix string to append to the username for backend authentication"
                     },
                     "comment": {
                        "type": "string",
                        "description": "Optional comment string"
                     },
                     "frontend_cookie": {
                        "type": "string",
                        "description": "Frontend cookie name"
                     },
                     "frontend_cookie_secret": {
                        "type": "string",
                        "description": "Frontend cookie secret"
                     },
                     "frontend_form": {
                        "type": "string",
                        "description": "Frontend authentication form name"
                     },
                     "frontend_form_template": {
                        "type": "string",
                        "description": "Frontend authentication form template"
                     },
                     "frontend_login": {
                        "type": "string",
                        "description": "Frontend login name"
                     },
                     "frontend_logout": {
                        "type": "string",
                        "description": "Frontend logout name"
                     },
                     "frontend_mode": {
                        "type": "string",
                        "description": "Default: Basic\n\nFrontend authentication mode (Form|Basic)",
                        "enum": [
                           "Basic",
                           "Form"
                        ]
                     },
                     "frontend_realm": {
                        "type": "string",
                        "description": "Frontend authentication realm"
                     },
                     "frontend_session_allow_persistency": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Allow session persistency"
                     },
                     "frontend_session_lifetime": {
                        "type": "string",
                        "description": "session lifetime"
                     },
                     "frontend_session_lifetime_limited": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nSpecifies if limitation of session lifetime is active"
                     },
                     "frontend_session_lifetime_scope": {
                        "type": "string",
                        "description": "Default: hours\n\nscope for frontend_session_lifetime (days|hours|minutes)",
                        "enum": [
                           "days",
                           "hours",
                           "minutes"
                        ]
                     },
                     "frontend_session_timeout": {
                        "type": "string",
                        "description": "session timeout"
                     },
                     "frontend_session_timeout_enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nSpecifies if session timeout is active"
                     },
                     "frontend_session_timeout_scope": {
                        "type": "string",
                        "description": "Default: minutes\n\nscope for frontend_session_timeout (days|hours|minutes)",
                        "enum": [
                           "days",
                           "hours",
                           "minutes"
                        ]
                     },
                     "logout_delegation_urls": {
                        "type": "array",
                        "description": "List of logout URLs that logouts are delegated to"
                     },
                     "logout_mode": {
                        "type": "string",
                        "description": "Default: None\n\nMode of logout (None|Delegation)",
                        "enum": [
                           "None",
                           "Delegation"
                        ]
                     },
                     "redirect_to_requested_url": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Should a redirect to the requested URL be made"
                     }
                  },
                  "required": [
                     "name",
                     "aaa",
                     "basic_prompt",
                     "frontend_session_lifetime",
                     "frontend_session_timeout"
                  ]
               },
               "utm_network_interface_address_info": {
                  "type": "object",
                  "description": "Get info for a network/interface_address object in SOPHOS UTM.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name of the object. Will be used to identify the entry"
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "utm_network_interface_address": {
                  "type": "object",
                  "description": "Create, update or destroy a network/interface_address object in SOPHOS UTM.\nThis module needs to have the REST Ability of the UTM to be activated.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name of the object. Will be used to identify the entry"
                     },
                     "address": {
                        "type": "string",
                        "description": "The ip4 address of the network/interface_address object."
                     },
                     "address6": {
                        "type": "string",
                        "description": "The ip6 address of the network/interface_address object."
                     },
                     "comment": {
                        "type": "string",
                        "description": "An optional comment to add to the object"
                     },
                     "resolved": {
                        "type": "string",
                        "description": "Whether or not the object is resolved"
                     },
                     "resolved6": {
                        "type": "string",
                        "description": "Whether or not the object is resolved"
                     }
                  },
                  "required": [
                     "name",
                     "address"
                  ]
               },
               "utm_dns_host": {
                  "type": "object",
                  "description": "Create, update or destroy a dns entry in SOPHOS UTM.\nThis module needs to have the REST Ability of the UTM to be activated.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name of the object. Will be used to identify the entry"
                     },
                     "address": {
                        "type": "string",
                        "description": "Default: 0.0.0.0\n\nThe IPV4 Address of the entry. Can be left empty for automatic resolving."
                     },
                     "address6": {
                        "type": "string",
                        "description": "Default: ::\n\nThe IPV6 Address of the entry. Can be left empty for automatic resolving."
                     },
                     "comment": {
                        "type": "string",
                        "description": "An optional comment to add to the dns host object"
                     },
                     "hostname": {
                        "type": "string",
                        "description": "The hostname for the dns host object"
                     },
                     "interface": {
                        "type": "string",
                        "description": "The reference name of the interface to use. If not provided the default interface will be used"
                     },
                     "resolved": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "whether the hostname's ipv4 address is already resolved or not"
                     },
                     "resolved6": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "whether the hostname's ipv6 address is already resolved or not"
                     },
                     "timeout": {
                        "type": "string",
                        "description": "the timeout for the utm to resolve the ip address for the hostname again"
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "utm_ca_host_key_cert_info": {
                  "type": "object",
                  "description": "Get info for a ca host_key_cert entry in SOPHOS UTM.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name of the object. Will be used to identify the entry"
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "utm_ca_host_key_cert": {
                  "type": "object",
                  "description": "Create, update or destroy a ca host_key_cert entry in SOPHOS UTM.\nThis module needs to have the REST Ability of the UTM to be activated.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name of the object. Will be used to identify the entry."
                     },
                     "ca": {
                        "type": "string",
                        "description": "A reference to an existing utm_ca_signing_ca or utm_ca_verification_ca object."
                     },
                     "meta": {
                        "type": "string",
                        "description": "A reference to an existing utm_ca_meta_x509 object."
                     },
                     "certificate": {
                        "type": "string",
                        "description": "The certificate in PEM format."
                     },
                     "comment": {
                        "type": "string",
                        "description": "Optional comment string."
                     },
                     "encrypted": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Optionally enable encryption."
                     },
                     "key": {
                        "type": "string",
                        "description": "Optional private key in PEM format."
                     }
                  },
                  "required": [
                     "name",
                     "ca",
                     "meta",
                     "certificate"
                  ]
               },
               "utm_aaa_group_info": {
                  "type": "object",
                  "description": "get info for a reverse_proxy frontend entry in SOPHOS UTM.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name of the object. Will be used to identify the entry"
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "utm_aaa_group": {
                  "type": "object",
                  "description": "Create, update or destroy an aaa group object in Sophos UTM.\nThis module needs to have the REST Ability of the UTM to be activated.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name of the object. Will be used to identify the entry."
                     },
                     "adirectory_groups": {
                        "type": "array",
                        "description": "List of adirectory group strings."
                     },
                     "adirectory_groups_sids": {
                        "type": "object",
                        "description": "Dictionary of group sids."
                     },
                     "backend_match": {
                        "type": "string",
                        "description": "Default: none\n\nThe backend for the group.",
                        "enum": [
                           "none",
                           "adirectory",
                           "edirectory",
                           "radius",
                           "tacacs",
                           "ldap"
                        ]
                     },
                     "comment": {
                        "type": "string",
                        "description": "Comment that describes the AAA group."
                     },
                     "dynamic": {
                        "type": "string",
                        "description": "Default: none\n\nGroup type. Is static if none is selected.",
                        "enum": [
                           "none",
                           "ipsec_dn",
                           "directory_groups"
                        ]
                     },
                     "edirectory_groups": {
                        "type": "array",
                        "description": "List of edirectory group strings."
                     },
                     "ipsec_dn": {
                        "type": "string",
                        "description": "The ipsec dn string."
                     },
                     "ldap_attribute": {
                        "type": "string",
                        "description": "The ldap attribute to check against."
                     },
                     "ldap_attribute_value": {
                        "type": "string",
                        "description": "The ldap attribute value to check against."
                     },
                     "members": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "A list of user ref names (aaa/user)."
                     },
                     "network": {
                        "type": "string",
                        "description": "The network reference name. The objects contains the known ip addresses for the authentication object (network/aaa)."
                     },
                     "radius_groups": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "A list of radius group strings."
                     },
                     "tacacs_groups": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "A list of tacacs group strings."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "tower_workflow_template": {
                  "type": "object",
                  "description": "Create, update, or destroy Ansible Tower workflows. See U(https://www.ansible.com/tower) for an overview.",
                  "properties": {
                     "allow_simultaneous": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "If enabled, simultaneous runs of this job template will be allowed."
                     },
                     "ask_extra_vars": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Prompt user for (extra_vars) on launch."
                     },
                     "ask_inventory": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Prompt user for inventory on launch."
                     },
                     "description": {
                        "type": "string",
                        "description": "The description to use for the workflow."
                     },
                     "extra_vars": {
                        "type": "string",
                        "description": "Extra variables used by Ansible in YAML or key=value format."
                     },
                     "inventory": {
                        "type": "string",
                        "description": "Name of the inventory to use for the job template."
                     },
                     "name": {
                        "type": "string",
                        "description": "The name to use for the workflow."
                     },
                     "organization": {
                        "type": "string",
                        "description": "The organization the workflow is linked to."
                     },
                     "schema": {
                        "type": "string",
                        "description": "The schema is a JSON- or YAML-formatted string defining the hierarchy structure that connects the nodes. Refer to Tower documentation for more information.\n"
                     },
                     "survey_enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Setting that variable will prompt the user for job type on the workflow launch."
                     },
                     "survey": {
                        "type": "string",
                        "description": "The definition of the survey associated to the workflow."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDesired state of the resource.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "tower_workflow_launch": {
                  "type": "object",
                  "description": "Launch an Ansible Tower workflows. See U(https://www.ansible.com/tower) for an overview.",
                  "properties": {
                     "workflow_template": {
                        "type": "string",
                        "description": "The name of the workflow template to run."
                     },
                     "extra_vars": {
                        "type": "string",
                        "description": "Any extra vars required to launch the job."
                     },
                     "wait": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nWait for the workflow to complete."
                     },
                     "timeout": {
                        "type": "string",
                        "description": "If waiting for the workflow to complete this will abort after this amount of seconds"
                     }
                  },
                  "required": [
                     "workflow_template"
                  ]
               },
               "tower_user": {
                  "type": "object",
                  "description": "Create, update, or destroy Ansible Tower users. See U(https://www.ansible.com/tower) for an overview.",
                  "properties": {
                     "username": {
                        "type": "string",
                        "description": "The username of the user."
                     },
                     "first_name": {
                        "type": "string",
                        "description": "First name of the user."
                     },
                     "last_name": {
                        "type": "string",
                        "description": "Last name of the user."
                     },
                     "email": {
                        "type": "string",
                        "description": "Email address of the user."
                     },
                     "password": {
                        "type": "string",
                        "description": "Password of the user."
                     },
                     "superuser": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nUser is a system wide administrator."
                     },
                     "auditor": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nUser is a system wide auditor."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDesired state of the resource.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     }
                  },
                  "required": [
                     "username",
                     "email"
                  ]
               },
               "tower_team": {
                  "type": "object",
                  "description": "Create, update, or destroy Ansible Tower teams. See U(https://www.ansible.com/tower) for an overview.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name to use for the team."
                     },
                     "organization": {
                        "type": "string",
                        "description": "Organization the team should be made a member of."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDesired state of the resource.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     }
                  },
                  "required": [
                     "name",
                     "organization"
                  ]
               },
               "tower_settings": {
                  "type": "object",
                  "description": "Modify Ansible Tower settings. See U(https://www.ansible.com/tower) for an overview.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of setting to modify"
                     },
                     "value": {
                        "type": "string",
                        "description": "Value to be modified for given setting."
                     }
                  },
                  "required": [
                     "name",
                     "value"
                  ]
               },
               "tower_send": {
                  "type": "object",
                  "description": "Send assets to Ansible Tower. See U(https://www.ansible.com/tower) for an overview.",
                  "properties": {
                     "assets": {
                        "type": "string",
                        "description": "The assets to import.\nThis can be the output of tower_receive or loaded from a file"
                     },
                     "files": {
                        "type": "array",
                        "description": "List of files to import."
                     },
                     "prevent": {
                        "type": "string",
                        "description": "A list of asset types to prevent import for"
                     },
                     "password_management": {
                        "type": "string",
                        "description": "Default: default\n\nThe password management option to use.\nThe prompt option is not supported.",
                        "enum": [
                           "default",
                           "random"
                        ]
                     }
                  }
               },
               "tower_role": {
                  "type": "object",
                  "description": "Create, update, or destroy Ansible Tower roles. See U(https://www.ansible.com/tower) for an overview.",
                  "properties": {
                     "user": {
                        "type": "string",
                        "description": "User that receives the permissions specified by the role."
                     },
                     "team": {
                        "type": "string",
                        "description": "Team that receives the permissions specified by the role."
                     },
                     "role": {
                        "type": "string",
                        "description": "The role type to grant/revoke.",
                        "enum": [
                           "admin",
                           "read",
                           "member",
                           "execute",
                           "adhoc",
                           "update",
                           "use",
                           "auditor",
                           "project_admin",
                           "inventory_admin",
                           "credential_admin",
                           "workflow_admin",
                           "notification_admin",
                           "job_template_admin"
                        ]
                     },
                     "target_team": {
                        "type": "string",
                        "description": "Team that the role acts on."
                     },
                     "inventory": {
                        "type": "string",
                        "description": "Inventory the role acts on."
                     },
                     "job_template": {
                        "type": "string",
                        "description": "The job template the role acts on."
                     },
                     "credential": {
                        "type": "string",
                        "description": "Credential the role acts on."
                     },
                     "organization": {
                        "type": "string",
                        "description": "Organization the role acts on."
                     },
                     "project": {
                        "type": "string",
                        "description": "Project the role acts on."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDesired state of the resource.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     }
                  },
                  "required": [
                     "role"
                  ]
               },
               "tower_receive": {
                  "type": "object",
                  "description": "Receive assets from Ansible Tower. See U(https://www.ansible.com/tower) for an overview.",
                  "properties": {
                     "all": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: False\n\nExport all assets"
                     },
                     "organization": {
                        "type": "array",
                        "description": "List of organization names to export"
                     },
                     "user": {
                        "type": "array",
                        "description": "List of user names to export"
                     },
                     "team": {
                        "type": "array",
                        "description": "List of team names to export"
                     },
                     "credential_type": {
                        "type": "array",
                        "description": "List of credential type names to export"
                     },
                     "credential": {
                        "type": "array",
                        "description": "List of credential names to export"
                     },
                     "notification_template": {
                        "type": "array",
                        "description": "List of notification template names to export"
                     },
                     "inventory_script": {
                        "type": "array",
                        "description": "List of inventory script names to export"
                     },
                     "inventory": {
                        "type": "array",
                        "description": "List of inventory names to export"
                     },
                     "project": {
                        "type": "array",
                        "description": "List of project names to export"
                     },
                     "job_template": {
                        "type": "array",
                        "description": "List of job template names to export"
                     },
                     "workflow": {
                        "type": "array",
                        "description": "List of workflow names to export"
                     }
                  }
               },
               "tower_project": {
                  "type": "object",
                  "description": "Create, update, or destroy Ansible Tower projects. See U(https://www.ansible.com/tower) for an overview.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name to use for the project."
                     },
                     "description": {
                        "type": "string",
                        "description": "Description to use for the project."
                     },
                     "scm_type": {
                        "type": "string",
                        "description": "Default: manual\n\nType of SCM resource.",
                        "enum": [
                           "manual",
                           "git",
                           "hg",
                           "svn"
                        ]
                     },
                     "scm_url": {
                        "type": "string",
                        "description": "URL of SCM resource."
                     },
                     "local_path": {
                        "type": "string",
                        "description": "The server playbook directory for manual projects."
                     },
                     "scm_branch": {
                        "type": "string",
                        "description": "The branch to use for the SCM resource."
                     },
                     "scm_credential": {
                        "type": "string",
                        "description": "Name of the credential to use with this SCM resource."
                     },
                     "scm_clean": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nRemove local modifications before updating."
                     },
                     "scm_delete_on_update": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nRemove the repository completely before updating."
                     },
                     "scm_update_on_launch": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nBefore an update to the local repository before launching a job with this project."
                     },
                     "scm_update_cache_timeout": {
                        "type": "string",
                        "description": "Cache Timeout to cache prior project syncs for a certain number of seconds. Only valid if scm_update_on_launch is to True, otherwise ignored."
                     },
                     "job_timeout": {
                        "type": "string",
                        "description": "The amount of time (in seconds) to run before the SCM Update is canceled. A value of 0 means no timeout."
                     },
                     "custom_virtualenv": {
                        "type": "string",
                        "description": "Local absolute file path containing a custom Python virtualenv to use"
                     },
                     "organization": {
                        "type": "string",
                        "description": "Primary key of organization for project."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDesired state of the resource.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "tower_organization": {
                  "type": "object",
                  "description": "Create, update, or destroy Ansible Tower organizations. See U(https://www.ansible.com/tower) for an overview.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name to use for the organization."
                     },
                     "description": {
                        "type": "string",
                        "description": "The description to use for the organization."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDesired state of the resource.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "tower_notification": {
                  "type": "object",
                  "description": "Create, update, or destroy Ansible Tower notifications. See U(https://www.ansible.com/tower) for an overview.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name of the notification."
                     },
                     "description": {
                        "type": "string",
                        "description": "The description of the notification."
                     },
                     "organization": {
                        "type": "string",
                        "description": "The organization the notification belongs to."
                     },
                     "notification_type": {
                        "type": "string",
                        "description": "The type of notification to be sent.",
                        "enum": [
                           "email",
                           "slack",
                           "twilio",
                           "pagerduty",
                           "hipchat",
                           "webhook",
                           "irc"
                        ]
                     },
                     "notification_configuration": {
                        "type": "string",
                        "description": "The notification configuration file. Note providing this field would disable all notification-configuration-related fields."
                     },
                     "username": {
                        "type": "string",
                        "description": "The mail server username. Required if I(notification_type=email)."
                     },
                     "sender": {
                        "type": "string",
                        "description": "The sender email address. Required if I(notification_type=email)."
                     },
                     "recipients": {
                        "type": "string",
                        "description": "The recipients email addresses. Required if I(notification_type=email)."
                     },
                     "use_tls": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "The TLS trigger. Required if I(notification_type=email)."
                     },
                     "host": {
                        "type": "string",
                        "description": "The mail server host. Required if I(notification_type=email)."
                     },
                     "use_ssl": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "The SSL trigger. Required if I(notification_type=email) or if I(notification_type=irc)."
                     },
                     "password": {
                        "type": "string",
                        "description": "The mail server password. Required if I(notification_type=email) or if I(notification_type=irc)."
                     },
                     "port": {
                        "type": "string",
                        "description": "The mail server port. Required if I(notification_type=email) or if I(notification_type=irc)."
                     },
                     "channels": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "The destination Slack channels. Required if I(notification_type=slack)."
                     },
                     "token": {
                        "type": "string",
                        "description": "The access token. Required if I(notification_type=slack), if I(notification_type=pagerduty) or if I(notification_type=hipchat)."
                     },
                     "account_token": {
                        "type": "string",
                        "description": "The Twillio account token. Required if I(notification_type=twillio)."
                     },
                     "from_number": {
                        "type": "string",
                        "description": "The source phone number. Required if I(notification_type=twillio)."
                     },
                     "to_numbers": {
                        "type": "string",
                        "description": "The destination phone numbers. Required if I(notification_type=twillio)."
                     },
                     "account_sid": {
                        "type": "string",
                        "description": "The Twillio account SID. Required if I(notification_type=twillio)."
                     },
                     "subdomain": {
                        "type": "string",
                        "description": "The PagerDuty subdomain. Required if I(notification_type=pagerduty)."
                     },
                     "service_key": {
                        "type": "string",
                        "description": "The PagerDuty service/integration API key. Required if I(notification_type=pagerduty)."
                     },
                     "client_name": {
                        "type": "string",
                        "description": "The PagerDuty client identifier. Required if I(notification_type=pagerduty)."
                     },
                     "message_from": {
                        "type": "string",
                        "description": "The label to be shown with the notification. Required if I(notification_type=hipchat)."
                     },
                     "api_url": {
                        "type": "string",
                        "description": "The HipChat API URL. Required if I(notification_type=hipchat)."
                     },
                     "color": {
                        "type": "string",
                        "description": "The notification color. Required if I(notification_type=hipchat).",
                        "enum": [
                           "yellow",
                           "green",
                           "red",
                           "purple",
                           "gray",
                           "random"
                        ]
                     },
                     "rooms": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "HipChat rooms to send the notification to. Required if I(notification_type=hipchat)."
                     },
                     "notify": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "The notify channel trigger. Required if I(notification_type=hipchat)."
                     },
                     "url": {
                        "type": "string",
                        "description": "The target URL. Required if I(notification_type=webhook)."
                     },
                     "headers": {
                        "type": "string",
                        "description": "The HTTP headers as JSON string. Required if I(notification_type=webhook)."
                     },
                     "server": {
                        "type": "string",
                        "description": "The IRC server address. Required if I(notification_type=irc)."
                     },
                     "nickname": {
                        "type": "string",
                        "description": "The IRC nickname. Required if I(notification_type=irc)."
                     },
                     "targets": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "The destination channels or users. Required if I(notification_type=irc)."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDesired state of the resource.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     }
                  },
                  "required": [
                     "name",
                     "notification_type"
                  ]
               },
               "tower_label": {
                  "type": "object",
                  "description": "Create, update, or destroy Ansible Tower labels. See U(https://www.ansible.com/tower) for an overview.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name to use for the label."
                     },
                     "organization": {
                        "type": "string",
                        "description": "Organization the label should be applied to."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDesired state of the resource.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     }
                  },
                  "required": [
                     "name",
                     "organization"
                  ]
               },
               "tower_job_wait": {
                  "type": "object",
                  "description": "Wait for Ansible Tower job to finish and report success or failure. See U(https://www.ansible.com/tower) for an overview.",
                  "properties": {
                     "job_id": {
                        "type": "string",
                        "description": "ID of the job to monitor."
                     },
                     "min_interval": {
                        "type": "string",
                        "description": "Default: 1\n\nMinimum interval in seconds, to request an update from Tower."
                     },
                     "max_interval": {
                        "type": "string",
                        "description": "Default: 30\n\nMaximum interval in seconds, to request an update from Tower."
                     },
                     "timeout": {
                        "type": "string",
                        "description": "Maximum time in seconds to wait for a job to finish."
                     }
                  },
                  "required": [
                     "job_id"
                  ]
               },
               "tower_job_template": {
                  "type": "object",
                  "description": "Create, update, or destroy Ansible Tower job templates. See U(https://www.ansible.com/tower) for an overview.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name to use for the job template."
                     },
                     "description": {
                        "type": "string",
                        "description": "Description to use for the job template."
                     },
                     "job_type": {
                        "type": "string",
                        "description": "The job type to use for the job template.",
                        "enum": [
                           "run",
                           "check",
                           "scan"
                        ]
                     },
                     "inventory": {
                        "type": "string",
                        "description": "Name of the inventory to use for the job template."
                     },
                     "project": {
                        "type": "string",
                        "description": "Name of the project to use for the job template."
                     },
                     "playbook": {
                        "type": "string",
                        "description": "Path to the playbook to use for the job template within the project provided."
                     },
                     "credential": {
                        "type": "string",
                        "description": "Name of the credential to use for the job template."
                     },
                     "vault_credential": {
                        "type": "string",
                        "description": "Name of the vault credential to use for the job template."
                     },
                     "forks": {
                        "type": "string",
                        "description": "The number of parallel or simultaneous processes to use while executing the playbook."
                     },
                     "limit": {
                        "type": "string",
                        "description": "A host pattern to further constrain the list of hosts managed or affected by the playbook"
                     },
                     "verbosity": {
                        "type": "string",
                        "description": "Control the output level Ansible produces as the playbook runs. 0 - Normal, 1 - Verbose, 2 - More Verbose, 3 - Debug, 4 - Connection Debug.",
                        "enum": [
                           0,
                           1,
                           2,
                           3,
                           4
                        ]
                     },
                     "extra_vars_path": {
                        "type": "string",
                        "description": "Path to the C(extra_vars) YAML file."
                     },
                     "job_tags": {
                        "type": "string",
                        "description": "Comma separated list of the tags to use for the job template."
                     },
                     "force_handlers_enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nEnable forcing playbook handlers to run even if a task fails."
                     },
                     "skip_tags": {
                        "type": "string",
                        "description": "Comma separated list of the tags to skip for the job template."
                     },
                     "start_at_task": {
                        "type": "string",
                        "description": "Start the playbook at the task matching this name."
                     },
                     "diff_mode_enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nEnable diff mode for the job template."
                     },
                     "fact_caching_enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nEnable use of fact caching for the job template."
                     },
                     "host_config_key": {
                        "type": "string",
                        "description": "Allow provisioning callbacks using this host config key."
                     },
                     "ask_diff_mode": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nPrompt user to enable diff mode (show changes) to files when supported by modules."
                     },
                     "ask_extra_vars": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nPrompt user for (extra_vars) on launch."
                     },
                     "ask_limit": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nPrompt user for a limit on launch."
                     },
                     "ask_tags": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nPrompt user for job tags on launch."
                     },
                     "ask_skip_tags": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nPrompt user for job tags to skip on launch."
                     },
                     "ask_job_type": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nPrompt user for job type on launch."
                     },
                     "ask_verbosity": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nPrompt user to choose a verbosity level on launch."
                     },
                     "ask_inventory": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nPrompt user for inventory on launch."
                     },
                     "ask_credential": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nPrompt user for credential on launch."
                     },
                     "survey_enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nEnable a survey on the job template."
                     },
                     "survey_spec": {
                        "type": "object",
                        "description": "JSON/YAML dict formatted survey definition."
                     },
                     "become_enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nActivate privilege escalation."
                     },
                     "concurrent_jobs_enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nAllow simultaneous runs of the job template."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDesired state of the resource.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     }
                  },
                  "required": [
                     "name",
                     "job_type",
                     "project",
                     "playbook"
                  ]
               },
               "tower_job_list": {
                  "type": "object",
                  "description": "List Ansible Tower jobs. See U(https://www.ansible.com/tower) for an overview.",
                  "properties": {
                     "status": {
                        "type": "string",
                        "description": "Only list jobs with this status.",
                        "enum": [
                           "pending",
                           "waiting",
                           "running",
                           "error",
                           "failed",
                           "canceled",
                           "successful"
                        ]
                     },
                     "page": {
                        "type": "string",
                        "description": "Page number of the results to fetch."
                     },
                     "all_pages": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nFetch all the pages and return a single result."
                     },
                     "query": {
                        "type": "string",
                        "description": "Query used to further filter the list of jobs. C({\"foo\":\"bar\"}) will be passed at C(?foo=bar)"
                     }
                  }
               },
               "tower_job_launch": {
                  "type": "object",
                  "description": "Launch an Ansible Tower jobs. See U(https://www.ansible.com/tower) for an overview.",
                  "properties": {
                     "job_template": {
                        "type": "string",
                        "description": "Name of the job template to use."
                     },
                     "job_explanation": {
                        "type": "string",
                        "description": "Job explanation field."
                     },
                     "job_type": {
                        "type": "string",
                        "description": "Job_type to use for the job, only used if prompt for job_type is set.",
                        "enum": [
                           "run",
                           "check",
                           "scan"
                        ]
                     },
                     "inventory": {
                        "type": "string",
                        "description": "Inventory to use for the job, only used if prompt for inventory is set."
                     },
                     "credential": {
                        "type": "string",
                        "description": "Credential to use for job, only used if prompt for credential is set."
                     },
                     "extra_vars": {
                        "type": "string",
                        "description": "Extra_vars to use for the job_template. Prepend C(@) if a file."
                     },
                     "limit": {
                        "type": "string",
                        "description": "Limit to use for the I(job_template)."
                     },
                     "tags": {
                        "type": "string",
                        "description": "Specific tags to use for from playbook."
                     },
                     "use_job_endpoint": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nDisable launching jobs from job template."
                     }
                  },
                  "required": [
                     "job_template"
                  ]
               },
               "tower_job_cancel": {
                  "type": "object",
                  "description": "Cancel Ansible Tower jobs. See U(https://www.ansible.com/tower) for an overview.",
                  "properties": {
                     "job_id": {
                        "type": "string",
                        "description": "ID of the job to cancel"
                     },
                     "fail_if_not_running": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Fail loudly if the I(job_id) does not reference a running job."
                     }
                  },
                  "required": [
                     "job_id"
                  ]
               },
               "tower_inventory_source": {
                  "type": "object",
                  "description": "Create, update, or destroy Ansible Tower inventories source. See U(https://www.ansible.com/tower) for an overview.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name to use for the inventory source."
                     },
                     "description": {
                        "type": "string",
                        "description": "The description to use for the inventory source."
                     },
                     "inventory": {
                        "type": "string",
                        "description": "The inventory the source is linked to."
                     },
                     "source": {
                        "type": "string",
                        "description": "Types of inventory source.",
                        "enum": [
                           "file",
                           "scm",
                           "ec2",
                           "gce",
                           "azure",
                           "azure_rm",
                           "vmware",
                           "satellite6",
                           "cloudforms",
                           "openstack",
                           "rhv",
                           "tower",
                           "custom"
                        ]
                     },
                     "credential": {
                        "type": "string",
                        "description": "Credential to use to retrieve the inventory from."
                     },
                     "source_vars": {
                        "type": "string",
                        "description": "The source_vars allow to Override variables found in the source config file. For example with Openstack, specifying *private: false* would change the output of the openstack.py script. It has to be YAML or JSON."
                     },
                     "timeout": {
                        "type": "string",
                        "description": "Number in seconds after which the Tower API methods will time out."
                     },
                     "source_project": {
                        "type": "string",
                        "description": "Use a *project* as a source for the *inventory*."
                     },
                     "source_path": {
                        "type": "string",
                        "description": "Path to the file to use as a source in the selected *project*."
                     },
                     "update_on_project_update": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "That parameter will sync the inventory when the project is synced. It can only be used with a SCM source."
                     },
                     "source_regions": {
                        "type": "array",
                        "description": "List of regions for your cloud provider. You can include multiple all regions. Only Hosts associated with the selected regions will be updated. Refer to Ansible Tower documentation for more detail."
                     },
                     "instance_filters": {
                        "type": "string",
                        "description": "Provide a comma-separated list of filter expressions. Hosts are imported when all of the filters match. Refer to Ansible Tower documentation for more detail."
                     },
                     "group_by": {
                        "type": "string",
                        "description": "Specify which groups to create automatically. Group names will be created similar to the options selected. If blank, all groups above are created. Refer to Ansible Tower documentation for more detail."
                     },
                     "source_script": {
                        "type": "string",
                        "description": "The source custom script to use to build the inventory. It needs to exist."
                     },
                     "overwrite": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "If set, any hosts and groups that were previously present on the external source but are now removed will be removed from the Tower inventory. Hosts and groups that were not managed by the inventory source will be promoted to the next manually created group or if there is no manually created group to promote them into, they will be left in the \"all\" default group for the inventory. When not checked, local child hosts and groups not found on the external source will remain untouched by the inventory update process."
                     },
                     "overwrite_vars": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "If set, all variables for child groups and hosts will be removed and replaced by those found on the external source. When not checked, a merge will be performed, combining local variables with those found on the external source."
                     },
                     "update_on_launch": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Each time a job runs using this inventory, refresh the inventory from the selected source before executing job tasks."
                     },
                     "update_cache_timeout": {
                        "type": "string",
                        "description": "Time in seconds to consider an inventory sync to be current. During job runs and callbacks the task system will evaluate the timestamp of the latest sync. If it is older than Cache Timeout, it is not considered current, and a new inventory sync will be performed."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDesired state of the resource.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "validate_certs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Tower option to avoid certificates check."
                     },
                     "tower_verify_ssl": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Tower option to avoid certificates check."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "validate_certs",
                                    "tower_verify_ssl"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "tower_inventory": {
                  "type": "object",
                  "description": "Create, update, or destroy Ansible Tower inventories. See U(https://www.ansible.com/tower) for an overview.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name to use for the inventory."
                     },
                     "description": {
                        "type": "string",
                        "description": "The description to use for the inventory."
                     },
                     "organization": {
                        "type": "string",
                        "description": "Organization the inventory belongs to."
                     },
                     "variables": {
                        "type": "string",
                        "description": "Inventory variables. Use C(@) to get from file."
                     },
                     "kind": {
                        "type": "string",
                        "description": "The kind field. Cannot be modified after created.",
                        "enum": [
                           "",
                           "smart"
                        ]
                     },
                     "host_filter": {
                        "type": "string",
                        "description": "The host_filter field. Only useful when C(kind=smart)."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDesired state of the resource.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     }
                  },
                  "required": [
                     "name",
                     "organization"
                  ]
               },
               "tower_host": {
                  "type": "object",
                  "description": "Create, update, or destroy Ansible Tower hosts. See U(https://www.ansible.com/tower) for an overview.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name to use for the host."
                     },
                     "description": {
                        "type": "string",
                        "description": "The description to use for the host."
                     },
                     "inventory": {
                        "type": "string",
                        "description": "Inventory the host should be made a member of."
                     },
                     "enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nIf the host should be enabled."
                     },
                     "variables": {
                        "type": "string",
                        "description": "Variables to use for the host. Use C(@) for a file."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDesired state of the resource.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     }
                  },
                  "required": [
                     "name",
                     "inventory"
                  ]
               },
               "tower_group": {
                  "type": "object",
                  "description": "Create, update, or destroy Ansible Tower groups. See U(https://www.ansible.com/tower) for an overview.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name to use for the group."
                     },
                     "description": {
                        "type": "string",
                        "description": "The description to use for the group."
                     },
                     "inventory": {
                        "type": "string",
                        "description": "Inventory the group should be made a member of."
                     },
                     "variables": {
                        "type": "string",
                        "description": "Variables to use for the group, use C(@) for a file."
                     },
                     "credential": {
                        "type": "string",
                        "description": "Credential to use for the group."
                     },
                     "source": {
                        "type": "string",
                        "description": "The source to use for this group.",
                        "enum": [
                           "manual",
                           "file",
                           "ec2",
                           "rax",
                           "vmware",
                           "gce",
                           "azure",
                           "azure_rm",
                           "openstack",
                           "satellite6",
                           "cloudforms",
                           "custom"
                        ]
                     },
                     "source_regions": {
                        "type": "string",
                        "description": "Regions for cloud provider."
                     },
                     "source_vars": {
                        "type": "string",
                        "description": "Override variables from source with variables from this field."
                     },
                     "instance_filters": {
                        "type": "string",
                        "description": "Comma-separated list of filter expressions for matching hosts."
                     },
                     "group_by": {
                        "type": "string",
                        "description": "Limit groups automatically created from inventory source."
                     },
                     "source_script": {
                        "type": "string",
                        "description": "Inventory script to be used when group type is C(custom)."
                     },
                     "overwrite": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nDelete child groups and hosts not found in source."
                     },
                     "overwrite_vars": {
                        "type": "string",
                        "description": "Override vars in child groups and hosts with those from external source."
                     },
                     "update_on_launch": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nRefresh inventory data from its source each time a job is run."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDesired state of the resource.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     }
                  },
                  "required": [
                     "name",
                     "inventory"
                  ]
               },
               "tower_credential_type": {
                  "type": "object",
                  "description": "Create, update, or destroy Ansible Tower credential type. See U(https://www.ansible.com/tower) for an overview.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name of the credential type."
                     },
                     "description": {
                        "type": "string",
                        "description": "The description of the credential type to give more detail about it."
                     },
                     "kind": {
                        "type": "string",
                        "description": "The type of credential type being added. Note that only cloud and net can be used for creating credential types. Refer to the Ansible for more information.",
                        "enum": [
                           "ssh",
                           "vault",
                           "net",
                           "scm",
                           "cloud",
                           "insights"
                        ]
                     },
                     "inputs": {
                        "type": "string",
                        "description": "Enter inputs using either JSON or YAML syntax. Refer to the Ansible Tower documentation for example syntax."
                     },
                     "injectors": {
                        "type": "string",
                        "description": "Enter injectors using either JSON or YAML syntax. Refer to the Ansible Tower documentation for example syntax."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDesired state of the resource.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "validate_certs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Tower option to avoid certificates check."
                     },
                     "tower_verify_ssl": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Tower option to avoid certificates check."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "validate_certs",
                                    "tower_verify_ssl"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "tower_credential": {
                  "type": "object",
                  "description": "Create, update, or destroy Ansible Tower credentials. See U(https://www.ansible.com/tower) for an overview.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name to use for the credential."
                     },
                     "description": {
                        "type": "string",
                        "description": "The description to use for the credential."
                     },
                     "user": {
                        "type": "string",
                        "description": "User that should own this credential."
                     },
                     "team": {
                        "type": "string",
                        "description": "Team that should own this credential."
                     },
                     "project": {
                        "type": "string",
                        "description": "Project that should for this credential."
                     },
                     "organization": {
                        "type": "string",
                        "description": "Organization that should own the credential."
                     },
                     "kind": {
                        "type": "string",
                        "description": "Type of credential being added.\nThe ssh choice refers to a Tower Machine credential.",
                        "enum": [
                           "ssh",
                           "vault",
                           "net",
                           "scm",
                           "aws",
                           "vmware",
                           "satellite6",
                           "cloudforms",
                           "gce",
                           "azure_rm",
                           "openstack",
                           "rhv",
                           "insights",
                           "tower"
                        ]
                     },
                     "host": {
                        "type": "string",
                        "description": "Host for this credential."
                     },
                     "username": {
                        "type": "string",
                        "description": "Username for this credential. ``access_key`` for AWS."
                     },
                     "password": {
                        "type": "string",
                        "description": "Password for this credential. ``secret_key`` for AWS. ``api_key`` for RAX.\nUse \"ASK\" and launch in Tower to be prompted."
                     },
                     "ssh_key_data": {
                        "type": "string",
                        "description": "SSH private key content. To extract the content from a file path, use the lookup function (see examples)."
                     },
                     "ssh_key_unlock": {
                        "type": "string",
                        "description": "Unlock password for ssh_key.\nUse \"ASK\" and launch in Tower to be prompted."
                     },
                     "authorize": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nShould use authorize for net type."
                     },
                     "authorize_password": {
                        "type": "string",
                        "description": "Password for net credentials that require authorize."
                     },
                     "client": {
                        "type": "string",
                        "description": "Client or application ID for azure_rm type."
                     },
                     "security_token": {
                        "type": "string",
                        "description": "STS token for aws type."
                     },
                     "secret": {
                        "type": "string",
                        "description": "Secret token for azure_rm type."
                     },
                     "subscription": {
                        "type": "string",
                        "description": "Subscription ID for azure_rm type."
                     },
                     "tenant": {
                        "type": "string",
                        "description": "Tenant ID for azure_rm type."
                     },
                     "domain": {
                        "type": "string",
                        "description": "Domain for openstack type."
                     },
                     "become_method": {
                        "type": "string",
                        "description": "Become method to use for privilege escalation.",
                        "enum": [
                           "None",
                           "sudo",
                           "su",
                           "pbrun",
                           "pfexec",
                           "pmrun"
                        ]
                     },
                     "become_username": {
                        "type": "string",
                        "description": "Become username.\nUse \"ASK\" and launch in Tower to be prompted."
                     },
                     "become_password": {
                        "type": "string",
                        "description": "Become password.\nUse \"ASK\" and launch in Tower to be prompted."
                     },
                     "vault_password": {
                        "type": "string",
                        "description": "Vault password.\nUse \"ASK\" and launch in Tower to be prompted."
                     },
                     "vault_id": {
                        "type": "string",
                        "description": "Vault identifier.\nThis parameter is only valid if C(kind) is specified as C(vault)."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDesired state of the resource.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     }
                  },
                  "required": [
                     "name",
                     "organization",
                     "kind"
                  ]
               },
               "wait_for_connection": {
                  "type": "object",
                  "description": "Waits for a total of C(timeout) seconds.\nRetries the transport connection after a timeout of C(connect_timeout).\nTests the transport connection every C(sleep) seconds.\nThis module makes use of internal ansible transport (and configuration) and the ping/win_ping module to guarantee correct end-to-end functioning.\nThis module is also supported for Windows targets.",
                  "properties": {
                     "connect_timeout": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 5\n\nMaximum number of seconds to wait for a connection to happen before closing and retrying."
                     },
                     "delay": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Number of seconds to wait before starting to poll."
                     },
                     "sleep": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 1\n\nNumber of seconds to sleep between checks."
                     },
                     "timeout": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 600\n\nMaximum number of seconds to wait for."
                     }
                  }
               },
               "wait_for": {
                  "type": "object",
                  "description": "You can wait for a set amount of time C(timeout), this is the default if nothing is specified or just C(timeout) is specified. This does not produce an error.\nWaiting for a port to become available is useful for when services are not immediately available after their init scripts return which is true of certain Java application servers.\nIt is also useful when starting guests with the M(virt) module and needing to pause until they are ready.\nThis module can also be used to wait for a regex match a string to be present in a file.\nIn Ansible 1.6 and later, this module can also be used to wait for a file to be available or absent on the filesystem.\nIn Ansible 1.8 and later, this module can also be used to wait for active connections to be closed before continuing, useful if a node is being rotated out of a load balancer pool.\nFor Windows targets, use the M(win_wait_for) module instead.",
                  "properties": {
                     "host": {
                        "type": "string",
                        "description": "Default: 127.0.0.1\n\nA resolvable hostname or IP address to wait for."
                     },
                     "timeout": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 300\n\nMaximum number of seconds to wait for, when used with another condition it will force an error.\nWhen used without other conditions it is equivalent of just sleeping."
                     },
                     "connect_timeout": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 5\n\nMaximum number of seconds to wait for a connection to happen before closing and retrying."
                     },
                     "delay": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Number of seconds to wait before starting to poll."
                     },
                     "port": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Port number to poll.\nC(path) and C(port) are mutually exclusive parameters."
                     },
                     "active_connection_states": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Default: ['ESTABLISHED', 'FIN_WAIT1', 'FIN_WAIT2', 'SYN_RECV', 'SYN_SENT', 'TIME_WAIT']\n\nThe list of TCP connection states which are counted as active connections."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: started\n\nEither C(present), C(started), or C(stopped), C(absent), or C(drained).\nWhen checking a port C(started) will ensure the port is open, C(stopped) will check that it is closed, C(drained) will check for active connections.\nWhen checking for a file or a search string C(present) or C(started) will ensure that the file or string is present before continuing, C(absent) will check that file is absent or removed.",
                        "enum": [
                           "absent",
                           "drained",
                           "present",
                           "started",
                           "stopped"
                        ]
                     },
                     "path": {
                        "type": "string",
                        "description": "Path to a file on the filesystem that must exist before continuing.\nC(path) and C(port) are mutually exclusive parameters."
                     },
                     "search_regex": {
                        "type": "string",
                        "description": "Can be used to match a string in either a file or a socket connection.\nDefaults to a multiline regex."
                     },
                     "exclude_hosts": {
                        "type": "array",
                        "description": "List of hosts or IPs to ignore when looking for active TCP connections for C(drained) state."
                     },
                     "sleep": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 1\n\nNumber of seconds to sleep between checks.\nBefore Ansible 2.3 this was hardcoded to 1 second."
                     },
                     "msg": {
                        "type": "string",
                        "description": "This overrides the normal error message from a failure to meet the required conditions."
                     }
                  }
               },
               "set_stats": {
                  "type": "object",
                  "description": "This module allows setting/accumulating stats on the current ansible run, either per host or for all hosts in the run.\nThis module is also supported for Windows targets.",
                  "properties": {
                     "data": {
                        "type": "object",
                        "description": "A dictionary of which each key represents a stat (or variable) you want to keep track of."
                     },
                     "per_host": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "whether the stats are per host or for all hosts in the run."
                     },
                     "aggregate": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nWhether the provided value is aggregated to the existing stat C(yes) or will replace it C(no)."
                     }
                  },
                  "required": [
                     "data"
                  ]
               },
               "set_fact": {
                  "type": "object",
                  "description": "This module allows setting new variables.\nVariables are set on a host-by-host basis just like facts discovered by the setup module.\nThese variables will be available to subsequent plays during an ansible-playbook run.\nSet C(cacheable) to C(yes) to save variables across executions using a fact cache. Variables created with set_fact have different precedence depending on whether they are or are not cached.\nPer the standard Ansible variable precedence rules, many other types of variables have a higher priority, so this value may be overridden.\nThis module is also supported for Windows targets.",
                  "properties": {
                     "key_value": {
                        "type": "string",
                        "description": "The C(set_fact) module takes key=value pairs as variables to set in the playbook scope. Or alternatively, accepts complex arguments using the C(args:) statement."
                     },
                     "cacheable": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "This boolean converts the variable into an actual 'fact' which will also be added to the fact cache, if fact caching is enabled.\nNormally this module creates 'host level variables' and has much higher precedence, this option changes the nature and precedence (by 7 steps) of the variable created. https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#variable-precedence-where-should-i-put-a-variable\nThis actually creates 2 copies of the variable, a normal 'set_fact' host variable with high precedence and a lower 'ansible_fact' one that is available for persistance via the facts cache plugin. This creates a possibly confusing interaction with C(meta: clear_facts) as it will remove the 'ansible_fact' but not the host variable."
                     }
                  },
                  "required": [
                     "key_value"
                  ]
               },
               "pause": {
                  "type": "object",
                  "description": "Pauses playbook execution for a set amount of time, or until a prompt is acknowledged. All parameters are optional. The default behavior is to pause with a prompt.\nTo pause/wait/sleep per host, use the M(wait_for) module.\nYou can use C(ctrl+c) if you wish to advance a pause earlier than it is set to expire or if you need to abort a playbook run entirely. To continue early press C(ctrl+c) and then C(c). To abort a playbook press C(ctrl+c) and then C(a).\nThe pause module integrates into async/parallelized playbooks without any special considerations (see Rolling Updates). When using pauses with the C(serial) playbook parameter (as in rolling updates) you are only prompted once for the current group of hosts.\nThis module is also supported for Windows targets.",
                  "properties": {
                     "minutes": {
                        "type": "string",
                        "description": "A positive number of minutes to pause for."
                     },
                     "seconds": {
                        "type": "string",
                        "description": "A positive number of seconds to pause for."
                     },
                     "prompt": {
                        "type": "string",
                        "description": "Optional text to use for the prompt message."
                     },
                     "echo": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nControls whether or not keyboard input is shown when typing.\nHas no effect if 'seconds' or 'minutes' is set."
                     }
                  }
               },
               "include_role": {
                  "type": "object",
                  "description": "Dynamically loads and executes a specified role as a task.\nMay be used only where Ansible tasks are allowed - inside C(pre_tasks), C(tasks), or C(post_tasks) playbook objects, or as a task inside a role.\nTask-level keywords, loops, and conditionals apply only to the C(include_role) statement itself.\nTo apply keywords to the tasks within the role, pass them using the C(apply) option or use M(import_role) instead.\nIgnores some keywords, like C(until) and C(retries).\nThis module is also supported for Windows targets.",
                  "properties": {
                     "apply": {
                        "type": "string",
                        "description": "Accepts a hash of task keywords (e.g. C(tags), C(become)) that will be applied to all tasks within the included role."
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the role to be executed."
                     },
                     "tasks_from": {
                        "type": "string",
                        "description": "Default: main\n\nFile to load from a role's C(tasks/) directory."
                     },
                     "vars_from": {
                        "type": "string",
                        "description": "Default: main\n\nFile to load from a role's C(vars/) directory."
                     },
                     "defaults_from": {
                        "type": "string",
                        "description": "Default: main\n\nFile to load from a role's C(defaults/) directory."
                     },
                     "allow_duplicates": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nOverrides the role's metadata setting to allow using a role more than once with the same parameters."
                     },
                     "public": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "This option dictates whether the role's C(vars) and C(defaults) are exposed to the playbook. If set to C(yes) the variables will be available to tasks following the C(include_role) task. This functionality differs from standard variable exposure for roles listed under the C(roles) header or C(import_role) as they are exposed at playbook parsing time, and available to earlier roles and tasks as well."
                     },
                     "handlers_from": {
                        "type": "string",
                        "description": "Default: main\n\nFile to load from a role's C(handlers/) directory."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "import_role": {
                  "type": "object",
                  "description": "Much like the C(roles:) keyword, this task loads a role, but it allows you to control it when the role tasks run in between other tasks of the play.\nMost keywords, loops and conditionals will only be applied to the imported tasks, not to this statement itself. If you want the opposite behavior, use M(include_role) instead.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name of the role to be executed."
                     },
                     "tasks_from": {
                        "type": "string",
                        "description": "Default: main\n\nFile to load from a role's C(tasks/) directory."
                     },
                     "vars_from": {
                        "type": "string",
                        "description": "Default: main\n\nFile to load from a role's C(vars/) directory."
                     },
                     "defaults_from": {
                        "type": "string",
                        "description": "Default: main\n\nFile to load from a role's C(defaults/) directory."
                     },
                     "allow_duplicates": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nOverrides the role's metadata setting to allow using a role more than once with the same parameters."
                     },
                     "handlers_from": {
                        "type": "string",
                        "description": "Default: main\n\nFile to load from a role's C(handlers/) directory."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "fail": {
                  "type": "object",
                  "description": "This module fails the progress with a custom message.\nIt can be useful for bailing out when a certain condition is met using C(when).\nThis module is also supported for Windows targets.",
                  "properties": {
                     "msg": {
                        "type": "string",
                        "description": "Default: Failed as requested from task\n\nThe customized message used for failing execution.\nIf omitted, fail will simply bail out with a generic message."
                     }
                  }
               },
               "debug": {
                  "type": "object",
                  "description": "This module prints statements during execution and can be useful for debugging variables or expressions without necessarily halting the playbook.\nUseful for debugging together with the 'when:' directive.\nThis module is also supported for Windows targets.",
                  "properties": {
                     "msg": {
                        "type": "string",
                        "description": "Default: Hello world!\n\nThe customized message that is printed. If omitted, prints a generic message."
                     },
                     "var": {
                        "type": "string",
                        "description": "A variable name to debug.\nMutually exclusive with the C(msg) option.\nBe aware that this option already runs in Jinja2 context and has an implicit C({{ }}) wrapping, so you should not be using Jinja2 delimiters unless you are looking for double interpolation."
                     },
                     "verbosity": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "A number that controls when the debug is run, if you set to 3 it will only run debug when -vvv or above"
                     }
                  }
               },
               "async_status": {
                  "type": "object",
                  "description": "This module gets the status of an asynchronous task.\nThis module is also supported for Windows targets.",
                  "properties": {
                     "jid": {
                        "type": "string",
                        "description": "Job or task identifier"
                     },
                     "mode": {
                        "type": "string",
                        "description": "Default: status\n\nIf C(status), obtain the status.\nIf C(cleanup), clean up the async job cache (by default in C(~/.ansible_async/)) for the specified job I(jid).",
                        "enum": [
                           "cleanup",
                           "status"
                        ]
                     }
                  },
                  "required": [
                     "jid"
                  ]
               },
               "assert": {
                  "type": "object",
                  "description": "This module asserts that given expressions are true with an optional custom message.\nThis module is also supported for Windows targets.",
                  "properties": {
                     "that": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "A list of string expressions of the same form that can be passed to the 'when' statement."
                     },
                     "fail_msg": {
                        "type": "string",
                        "description": "The customized message used for a failing assertion.\nThis argument was called 'msg' before Ansible 2.7, now it is renamed to 'fail_msg' with alias 'msg'."
                     },
                     "msg": {
                        "type": "string",
                        "description": "The customized message used for a failing assertion.\nThis argument was called 'msg' before Ansible 2.7, now it is renamed to 'fail_msg' with alias 'msg'."
                     },
                     "success_msg": {
                        "type": "string",
                        "description": "The customized message used for a successful assertion."
                     },
                     "quiet": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Set this to C(yes) to avoid verbose output."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "fail_msg",
                                    "msg"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "xfs_quota": {
                  "type": "object",
                  "description": "Configure quotas on XFS filesystems.\nBefore using this module /etc/projects and /etc/projid need to be configured.",
                  "properties": {
                     "type": {
                        "type": "string",
                        "description": "The XFS quota type.",
                        "enum": [
                           "user",
                           "group",
                           "project"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the user, group or project to apply the quota to, if other than default."
                     },
                     "mountpoint": {
                        "type": "string",
                        "description": "The mount point on which to apply the quotas."
                     },
                     "bhard": {
                        "type": "string",
                        "description": "Hard blocks quota limit.\nThis argument supports human readable sizes."
                     },
                     "bsoft": {
                        "type": "string",
                        "description": "Soft blocks quota limit.\nThis argument supports human readable sizes."
                     },
                     "ihard": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Hard inodes quota limit."
                     },
                     "isoft": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Soft inodes quota limit."
                     },
                     "rtbhard": {
                        "type": "string",
                        "description": "Hard realtime blocks quota limit.\nThis argument supports human readable sizes."
                     },
                     "rtbsoft": {
                        "type": "string",
                        "description": "Soft realtime blocks quota limit.\nThis argument supports human readable sizes."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether to apply the limits or remove them.\nWhen removing limit, they are set to 0, and not quite removed.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     }
                  },
                  "required": [
                     "type",
                     "mountpoint"
                  ]
               },
               "xfconf": {
                  "type": "object",
                  "description": "This module allows for the manipulation of Xfce 4 Configuration via xfconf-query.  Please see the xfconf-query(1) man pages for more details.",
                  "properties": {
                     "channel": {
                        "type": "string",
                        "description": "A Xfconf preference channel is a top-level tree key, inside of the Xfconf repository that corresponds to the location for which all application properties/keys are stored. See man xfconf-query(1)"
                     },
                     "property": {
                        "type": "string",
                        "description": "A Xfce preference key is an element in the Xfconf repository that corresponds to an application preference. See man xfconf-query(1)"
                     },
                     "value": {
                        "type": "string",
                        "description": "Preference properties typically have simple values such as strings, integers, or lists of strings and integers. This is ignored if the state is \"get\". See man xfconf-query(1)"
                     },
                     "value_type": {
                        "type": "string",
                        "description": "The type of value being set. This is ignored if the state is \"get\".",
                        "enum": [
                           "int",
                           "bool",
                           "float",
                           "string"
                        ]
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nThe action to take upon the property/value.",
                        "enum": [
                           "get",
                           "present",
                           "absent"
                        ]
                     }
                  },
                  "required": [
                     "channel",
                     "property"
                  ]
               },
               "vdo": {
                  "type": "object",
                  "description": "This module controls the VDO dedupe and compression device.\nVDO, or Virtual Data Optimizer, is a device-mapper target that provides inline block-level deduplication, compression, and thin provisioning capabilities to primary storage.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name of the VDO volume."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether this VDO volume should be \"present\" or \"absent\". If a \"present\" VDO volume does not exist, it will be created.  If a \"present\" VDO volume already exists, it will be modified, by updating the configuration, which will take effect when the VDO volume is restarted. Not all parameters of an existing VDO volume can be modified; the \"statusparamkeys\" list contains the parameters that can be modified after creation. If an \"absent\" VDO volume does not exist, it will not be removed.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "activated": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "The \"activate\" status for a VDO volume.  If this is set to \"no\", the VDO volume cannot be started, and it will not start on system startup.  However, on initial creation, a VDO volume with \"activated\" set to \"off\" will be running, until stopped.  This is the default behavior of the \"vdo create\" command; it provides the user an opportunity to write a base amount of metadata (filesystem, LVM headers, etc.) to the VDO volume prior to stopping the volume, and leaving it deactivated until ready to use."
                     },
                     "running": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether this VDO volume is running.\nA VDO volume must be activated in order to be started."
                     },
                     "device": {
                        "type": "string",
                        "description": "The full path of the device to use for VDO storage.\nThis is required if \"state\" is \"present\"."
                     },
                     "logicalsize": {
                        "type": "string",
                        "description": "The logical size of the VDO volume (in megabytes, or LVM suffix format).  If not specified for a new volume, this defaults to the same size as the underlying storage device, which is specified in the 'device' parameter. Existing volumes will maintain their size if the logicalsize parameter is not specified, or is smaller than or identical to the current size.  If the specified size is larger than the current size, a growlogical operation will be performed."
                     },
                     "deduplication": {
                        "type": "string",
                        "description": "Configures whether deduplication is enabled.  The default for a created volume is 'enabled'.  Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.",
                        "enum": [
                           "disabled",
                           "enabled"
                        ]
                     },
                     "compression": {
                        "type": "string",
                        "description": "Configures whether compression is enabled.  The default for a created volume is 'enabled'.  Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.",
                        "enum": [
                           "disabled",
                           "enabled"
                        ]
                     },
                     "blockmapcachesize": {
                        "type": "string",
                        "description": "The amount of memory allocated for caching block map pages, in megabytes (or may be issued with an LVM-style suffix of K, M, G, or T).  The default (and minimum) value is 128M.  The value specifies the size of the cache; there is a 15% memory usage overhead. Each 1.25G of block map covers 1T of logical blocks, therefore a small amount of block map cache memory can cache a significantly large amount of block map data.  Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook."
                     },
                     "readcache": {
                        "type": "string",
                        "description": "Enables or disables the read cache.  The default is 'disabled'.  Choosing 'enabled' enables a read cache which may improve performance for workloads of high deduplication, read workloads with a high level of compression, or on hard disk storage.  Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.\nThe read cache feature is available in VDO 6.1 and older.",
                        "enum": [
                           "disabled",
                           "enabled"
                        ]
                     },
                     "readcachesize": {
                        "type": "string",
                        "description": "Specifies the extra VDO device read cache size in megabytes.  This is in addition to a system-defined minimum.  Using a value with a suffix of K, M, G, or T is optional.  The default value is 0.  1.125 MB of memory per bio thread will be used per 1 MB of read cache specified (for example, a VDO volume configured with 4 bio threads will have a read cache memory usage overhead of 4.5 MB per 1 MB of read cache specified). Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.\nThe read cache feature is available in VDO 6.1 and older."
                     },
                     "emulate512": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Enables 512-byte emulation mode, allowing drivers or filesystems to access the VDO volume at 512-byte granularity, instead of the default 4096-byte granularity. Default is 'disabled'; only recommended when a driver or filesystem requires 512-byte sector level access to a device.  This option is only available when creating a new volume, and cannot be changed for an existing volume."
                     },
                     "growphysical": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Specifies whether to attempt to execute a growphysical operation, if there is enough unused space on the device.  A growphysical operation will be executed if there is at least 64 GB of free space, relative to the previous physical size of the affected VDO volume."
                     },
                     "slabsize": {
                        "type": "string",
                        "description": "The size of the increment by which the physical size of a VDO volume is grown, in megabytes (or may be issued with an LVM-style suffix of K, M, G, or T).  Must be a power of two between 128M and 32G.  The default is 2G, which supports volumes having a physical size up to 16T. The maximum, 32G, supports a physical size of up to 256T. This option is only available when creating a new volume, and cannot be changed for an existing volume."
                     },
                     "writepolicy": {
                        "type": "string",
                        "description": "Specifies the write policy of the VDO volume.  The 'sync' mode acknowledges writes only after data is on stable storage.  The 'async' mode acknowledges writes when data has been cached for writing to stable storage.  The default (and highly recommended) 'auto' mode checks the storage device to determine whether it supports flushes.  Devices that support flushes will result in a VDO volume in 'async' mode, while devices that do not support flushes will run in sync mode. Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook.",
                        "enum": [
                           "async",
                           "auto",
                           "sync"
                        ]
                     },
                     "indexmem": {
                        "type": "string",
                        "description": "Specifies the amount of index memory in gigabytes.  The default is 0.25.  The special decimal values 0.25, 0.5, and 0.75 can be used, as can any positive integer. This option is only available when creating a new volume, and cannot be changed for an existing volume."
                     },
                     "indexmode": {
                        "type": "string",
                        "description": "Specifies the index mode of the Albireo index.  The default is 'dense', which has a deduplication window of 1 GB of index memory per 1 TB of incoming data, requiring 10 GB of index data on persistent storage. The 'sparse' mode has a deduplication window of 1 GB of index memory per 10 TB of incoming data, but requires 100 GB of index data on persistent storage.  This option is only available when creating a new volume, and cannot be changed for an existing volume.",
                        "enum": [
                           "dense",
                           "sparse"
                        ]
                     },
                     "ackthreads": {
                        "type": "string",
                        "description": "Specifies the number of threads to use for acknowledging completion of requested VDO I/O operations. Valid values are integer values from 1 to 100 (lower numbers are preferable due to overhead).  The default is 1.  Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook."
                     },
                     "biothreads": {
                        "type": "string",
                        "description": "Specifies the number of threads to use for submitting I/O operations to the storage device.  Valid values are integer values from 1 to 100 (lower numbers are preferable due to overhead).  The default is 4. Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook."
                     },
                     "cputhreads": {
                        "type": "string",
                        "description": "Specifies the number of threads to use for CPU-intensive work such as hashing or compression.  Valid values are integer values from 1 to 100 (lower numbers are preferable due to overhead).  The default is 2. Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook."
                     },
                     "logicalthreads": {
                        "type": "string",
                        "description": "Specifies the number of threads across which to subdivide parts of the VDO processing based on logical block addresses.  Valid values are integer values from 1 to 100 (lower numbers are preferable due to overhead). The default is 1.  Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook."
                     },
                     "physicalthreads": {
                        "type": "string",
                        "description": "Specifies the number of threads across which to subdivide parts of the VDO processing based on physical block addresses.  Valid values are integer values from 1 to 16 (lower numbers are preferable due to overhead). The physical space used by the VDO volume must be larger than (slabsize * physicalthreads).  The default is 1.  Existing volumes will maintain their previously configured setting unless a different value is specified in the playbook."
                     }
                  },
                  "required": [
                     "name",
                     "state"
                  ]
               },
               "user": {
                  "type": "object",
                  "description": "Manage user accounts and user attributes.\nFor Windows targets, use the M(win_user) module instead.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the user to create, remove or modify."
                     },
                     "user": {
                        "type": "string",
                        "description": "Name of the user to create, remove or modify."
                     },
                     "uid": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Optionally sets the I(UID) of the user."
                     },
                     "comment": {
                        "type": "string",
                        "description": "Optionally sets the description (aka I(GECOS)) of user account."
                     },
                     "hidden": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "macOS only, optionally hide the user from the login window and system preferences.\nThe default will be C(yes) if the I(system) option is used."
                     },
                     "non_unique": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Optionally when used with the -u option, this option allows to change the user ID to a non-unique value."
                     },
                     "seuser": {
                        "type": "string",
                        "description": "Optionally sets the seuser type (user_u) on selinux enabled systems."
                     },
                     "group": {
                        "type": "string",
                        "description": "Optionally sets the user's primary group (takes a group name)."
                     },
                     "groups": {
                        "type": "array",
                        "description": "List of groups user will be added to. When set to an empty string C(''), the user is removed from all groups except the primary group.\nBefore Ansible 2.3, the only input format allowed was a comma separated string.\nMutually exclusive with C(local)"
                     },
                     "append": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "If C(yes), add the user to the groups specified in C(groups).\nIf C(no), user will only be added to the groups specified in C(groups), removing them from all other groups.\nMutually exclusive with C(local)"
                     },
                     "shell": {
                        "type": "string",
                        "description": "Optionally set the user's shell.\nOn macOS, before Ansible 2.5, the default shell for non-system users was C(/usr/bin/false). Since Ansible 2.5, the default shell for non-system users on macOS is C(/bin/bash).\nOn other operating systems, the default shell is determined by the underlying tool being used. See Notes for details."
                     },
                     "home": {
                        "type": "string",
                        "description": "Optionally set the user's home directory."
                     },
                     "skeleton": {
                        "type": "string",
                        "description": "Optionally set a home skeleton directory.\nRequires C(create_home) option!"
                     },
                     "password": {
                        "type": "string",
                        "description": "Optionally set the user's password to this crypted value.\nOn macOS systems, this value has to be cleartext. Beware of security issues.\nTo create a disabled account on Linux systems, set this to C('!') or C('*').\nTo create a disabled account on OpenBSD, set this to C('*************').\nSee U(https://docs.ansible.com/ansible/faq.html#how-do-i-generate-encrypted-passwords-for-the-user-module) for details on various ways to generate these password values."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the account should exist or not, taking action if the state is different from what is stated.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "create_home": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nUnless set to C(no), a home directory will be made for the user when the account is created or if the home directory does not exist.\nChanged from C(createhome) to C(create_home) in Ansible 2.5."
                     },
                     "createhome": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nUnless set to C(no), a home directory will be made for the user when the account is created or if the home directory does not exist.\nChanged from C(createhome) to C(create_home) in Ansible 2.5."
                     },
                     "move_home": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "If set to C(yes) when used with C(home: ), attempt to move the user's old home directory to the specified directory if it isn't there already and the old home exists."
                     },
                     "system": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "When creating an account C(state=present), setting this to C(yes) makes the user a system account.\nThis setting cannot be changed on existing users."
                     },
                     "force": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "This only affects C(state=absent), it forces removal of the user and associated directories on supported platforms.\nThe behavior is the same as C(userdel --force), check the man page for C(userdel) on your system for details and support.\nWhen used with C(generate_ssh_key=yes) this forces an existing key to be overwritten."
                     },
                     "remove": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "This only affects C(state=absent), it attempts to remove directories associated with the user.\nThe behavior is the same as C(userdel --remove), check the man page for details and support."
                     },
                     "login_class": {
                        "type": "string",
                        "description": "Optionally sets the user's login class, a feature of most BSD OSs."
                     },
                     "generate_ssh_key": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether to generate a SSH key for the user in question.\nThis will B(not) overwrite an existing SSH key unless used with C(force=yes)."
                     },
                     "ssh_key_bits": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: default set by ssh-keygen\n\nOptionally specify number of bits in SSH key to create."
                     },
                     "ssh_key_type": {
                        "type": "string",
                        "description": "Default: rsa\n\nOptionally specify the type of SSH key to generate.\nAvailable SSH key types will depend on implementation present on target host."
                     },
                     "ssh_key_file": {
                        "type": "string",
                        "description": "Optionally specify the SSH key filename.\nIf this is a relative filename then it will be relative to the user's home directory.\nThis parameter defaults to I(.ssh/id_rsa)."
                     },
                     "ssh_key_comment": {
                        "type": "string",
                        "description": "Default: ansible-generated on $HOSTNAME\n\nOptionally define the comment for the SSH key."
                     },
                     "ssh_key_passphrase": {
                        "type": "string",
                        "description": "Set a passphrase for the SSH key.\nIf no passphrase is provided, the SSH key will default to having no passphrase."
                     },
                     "update_password": {
                        "type": "string",
                        "description": "Default: always\n\nC(always) will update passwords if they differ.\nC(on_create) will only set the password for newly created users.",
                        "enum": [
                           "always",
                           "on_create"
                        ]
                     },
                     "expires": {
                        "type": "number",
                        "description": "An expiry time for the user in epoch, it will be ignored on platforms that do not support this.\nCurrently supported on GNU/Linux, FreeBSD, and DragonFlyBSD.\nSince Ansible 2.6 you can remove the expiry time specify a negative value. Currently supported on GNU/Linux and FreeBSD."
                     },
                     "password_lock": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Lock the password (usermod -L, pw lock, usermod -C).\nBUT implementation differs on different platforms, this option does not always mean the user cannot login via other methods.\nThis option does not disable the user, only lock the password. Do not change the password in the same task.\nCurrently supported on Linux, FreeBSD, DragonFlyBSD, NetBSD, OpenBSD."
                     },
                     "local": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Forces the use of \"local\" command alternatives on platforms that implement it.\nThis is useful in environments that use centralized authentification when you want to manipulate the local users (i.e. it uses C(luseradd) instead of C(useradd)).\nThis will check C(/etc/passwd) for an existing account before invoking commands. If the local account database exists somewhere other than C(/etc/passwd), this setting will not work properly.\nThis requires that the above commands as well as C(/etc/passwd) must exist on the target host, otherwise it will be a fatal error.\nMutually exclusive with C(groups) and C(append)"
                     },
                     "profile": {
                        "type": "string",
                        "description": "Sets the profile of the user.\nDoes nothing when used with other platforms.\nCan set multiple profiles using comma separation.\nTo delete all the profiles, use C(profile='').\nCurrently supported on Illumos/Solaris."
                     },
                     "authorization": {
                        "type": "string",
                        "description": "Sets the authorization of the user.\nDoes nothing when used with other platforms.\nCan set multiple authorizations using comma separation.\nTo delete all authorizations, use C(authorization='').\nCurrently supported on Illumos/Solaris."
                     },
                     "role": {
                        "type": "string",
                        "description": "Sets the role of the user.\nDoes nothing when used with other platforms.\nCan set multiple roles using comma separation.\nTo delete all roles, use C(role='').\nCurrently supported on Illumos/Solaris."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "user"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "user"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "create_home",
                                    "createhome"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "ufw": {
                  "type": "object",
                  "description": "Manage firewall with UFW.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "C(enabled) reloads firewall and enables firewall on boot.\nC(disabled) unloads firewall and disables firewall on boot.\nC(reloaded) reloads firewall.\nC(reset) disables and resets firewall to installation defaults.",
                        "enum": [
                           "disabled",
                           "enabled",
                           "reloaded",
                           "reset"
                        ]
                     },
                     "default": {
                        "type": "string",
                        "description": "Change the default policy for incoming or outgoing traffic.",
                        "enum": [
                           "allow",
                           "deny",
                           "reject"
                        ]
                     },
                     "policy": {
                        "type": "string",
                        "description": "Change the default policy for incoming or outgoing traffic.",
                        "enum": [
                           "allow",
                           "deny",
                           "reject"
                        ]
                     },
                     "direction": {
                        "type": "string",
                        "description": "Select direction for a rule or default policy command.",
                        "enum": [
                           "in",
                           "incoming",
                           "out",
                           "outgoing",
                           "routed"
                        ]
                     },
                     "logging": {
                        "type": "string",
                        "description": "Toggles logging. Logged packets use the LOG_KERN syslog facility.",
                        "enum": [
                           "on",
                           "off",
                           "low",
                           "medium",
                           "high",
                           "full"
                        ]
                     },
                     "insert": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Insert the corresponding rule as rule number NUM.\nNote that ufw numbers rules starting with 1."
                     },
                     "insert_relative_to": {
                        "type": "string",
                        "description": "Default: zero\n\nAllows to interpret the index in I(insert) relative to a position.\nC(zero) interprets the rule number as an absolute index (i.e. 1 is the first rule).\nC(first-ipv4) interprets the rule number relative to the index of the first IPv4 rule, or relative to the position where the first IPv4 rule would be if there is currently none.\nC(last-ipv4) interprets the rule number relative to the index of the last IPv4 rule, or relative to the position where the last IPv4 rule would be if there is currently none.\nC(first-ipv6) interprets the rule number relative to the index of the first IPv6 rule, or relative to the position where the first IPv6 rule would be if there is currently none.\nC(last-ipv6) interprets the rule number relative to the index of the last IPv6 rule, or relative to the position where the last IPv6 rule would be if there is currently none.",
                        "enum": [
                           "first-ipv4",
                           "first-ipv6",
                           "last-ipv4",
                           "last-ipv6",
                           "zero"
                        ]
                     },
                     "rule": {
                        "type": "string",
                        "description": "Add firewall rule",
                        "enum": [
                           "allow",
                           "deny",
                           "limit",
                           "reject"
                        ]
                     },
                     "log": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Log new connections matched to this rule"
                     },
                     "from_ip": {
                        "type": "string",
                        "description": "Default: any\n\nSource IP address."
                     },
                     "from": {
                        "type": "string",
                        "description": "Default: any\n\nSource IP address."
                     },
                     "src": {
                        "type": "string",
                        "description": "Default: any\n\nSource IP address."
                     },
                     "from_port": {
                        "type": "string",
                        "description": "Source port."
                     },
                     "to_ip": {
                        "type": "string",
                        "description": "Default: any\n\nDestination IP address."
                     },
                     "dest": {
                        "type": "string",
                        "description": "Default: any\n\nDestination IP address."
                     },
                     "to": {
                        "type": "string",
                        "description": "Default: any\n\nDestination IP address."
                     },
                     "to_port": {
                        "type": "string",
                        "description": "Destination port."
                     },
                     "port": {
                        "type": "string",
                        "description": "Destination port."
                     },
                     "proto": {
                        "type": "string",
                        "description": "TCP/IP protocol.",
                        "enum": [
                           "any",
                           "tcp",
                           "udp",
                           "ipv6",
                           "esp",
                           "ah",
                           "gre",
                           "igmp"
                        ]
                     },
                     "protocol": {
                        "type": "string",
                        "description": "TCP/IP protocol.",
                        "enum": [
                           "any",
                           "tcp",
                           "udp",
                           "ipv6",
                           "esp",
                           "ah",
                           "gre",
                           "igmp"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "Use profile located in C(/etc/ufw/applications.d)."
                     },
                     "app": {
                        "type": "string",
                        "description": "Use profile located in C(/etc/ufw/applications.d)."
                     },
                     "delete": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Delete rule."
                     },
                     "interface": {
                        "type": "string",
                        "description": "Specify interface for rule."
                     },
                     "if": {
                        "type": "string",
                        "description": "Specify interface for rule."
                     },
                     "route": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Apply the rule to routed/forwarded packets."
                     },
                     "comment": {
                        "type": "string",
                        "description": "Add a comment to the rule. Requires UFW version >=0.35."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "default",
                                    "policy"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "from_ip",
                                    "from",
                                    "src"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "to_ip",
                                    "dest",
                                    "to"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "to_port",
                                    "port"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "proto",
                                    "protocol"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "app"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "interface",
                                    "if"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "timezone": {
                  "type": "object",
                  "description": "This module configures the timezone setting, both of the system clock and of the hardware clock. If you want to set up the NTP, use M(service) module.\nIt is recommended to restart C(crond) after changing the timezone, otherwise the jobs may run at the wrong time.\nSeveral different tools are used depending on the OS/Distribution involved. For Linux it can use C(timedatectl) or edit C(/etc/sysconfig/clock) or C(/etc/timezone) and C(hwclock). On SmartOS, C(sm-set-timezone), for macOS, C(systemsetup), for BSD, C(/etc/localtime) is modified. On AIX, C(chtz) is used.\nAs of Ansible 2.3 support was added for SmartOS and BSDs.\nAs of Ansible 2.4 support was added for macOS.\nAs of Ansible 2.9 support was added for AIX 6.1+\nWindows and HPUX are not supported, please let us know if you find any other OS/distro in which this fails.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the timezone for the system clock.\nDefault is to keep current setting.\nB(At least one of name and hwclock are required.)"
                     },
                     "hwclock": {
                        "type": "string",
                        "description": "Whether the hardware clock is in UTC or in local timezone.\nDefault is to keep current setting.\nNote that this option is recommended not to change and may fail to configure, especially on virtual environments such as AWS.\nB(At least one of name and hwclock are required.)\nI(Only used on Linux.)",
                        "enum": [
                           "local",
                           "UTC"
                        ]
                     },
                     "rtc": {
                        "type": "string",
                        "description": "Whether the hardware clock is in UTC or in local timezone.\nDefault is to keep current setting.\nNote that this option is recommended not to change and may fail to configure, especially on virtual environments such as AWS.\nB(At least one of name and hwclock are required.)\nI(Only used on Linux.)",
                        "enum": [
                           "local",
                           "UTC"
                        ]
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "hwclock",
                                    "rtc"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "sysvinit": {
                  "type": "object",
                  "description": "Controls services on target hosts that use the SysV init system.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the service."
                     },
                     "service": {
                        "type": "string",
                        "description": "Name of the service."
                     },
                     "state": {
                        "type": "string",
                        "description": "C(started)/C(stopped) are idempotent actions that will not run commands unless necessary. Not all init scripts support C(restarted) nor C(reloaded) natively, so these will both trigger a stop and start as needed.",
                        "enum": [
                           "started",
                           "stopped",
                           "restarted",
                           "reloaded"
                        ]
                     },
                     "enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether the service should start on boot. B(At least one of state and enabled are required.)"
                     },
                     "sleep": {
                        "type": "string",
                        "description": "Default: 1\n\nIf the service is being C(restarted) or C(reloaded) then sleep this many seconds between the stop and start command. This helps to workaround badly behaving services."
                     },
                     "pattern": {
                        "type": "string",
                        "description": "A substring to look for as would be found in the output of the I(ps) command as a stand-in for a status result.\nIf the string is found, the service will be assumed to be running.\nThis option is mainly for use with init scripts that don't support the 'status' option."
                     },
                     "runlevels": {
                        "type": "string",
                        "description": "The runlevels this script should be enabled/disabled from.\nUse this to override the defaults set by the package or init script itself."
                     },
                     "arguments": {
                        "type": "string",
                        "description": "Additional arguments provided on the command line that some init scripts accept."
                     },
                     "args": {
                        "type": "string",
                        "description": "Additional arguments provided on the command line that some init scripts accept."
                     },
                     "daemonize": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Have the module daemonize as the service itself might not do so properly.\nThis is useful with badly written init scripts or daemons, which commonly manifests as the task hanging as it is still holding the tty or the service dying when the task is over as the connection closes the session."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "service"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "service"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "arguments",
                                    "args"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "systemd": {
                  "type": "object",
                  "description": "Controls systemd services on remote hosts.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the service. This parameter takes the name of exactly one service to work with.\nWhen using in a chroot environment you always need to specify the full name i.e. (crond.service)."
                     },
                     "service": {
                        "type": "string",
                        "description": "Name of the service. This parameter takes the name of exactly one service to work with.\nWhen using in a chroot environment you always need to specify the full name i.e. (crond.service)."
                     },
                     "unit": {
                        "type": "string",
                        "description": "Name of the service. This parameter takes the name of exactly one service to work with.\nWhen using in a chroot environment you always need to specify the full name i.e. (crond.service)."
                     },
                     "state": {
                        "type": "string",
                        "description": "C(started)/C(stopped) are idempotent actions that will not run commands unless necessary. C(restarted) will always bounce the service. C(reloaded) will always reload.",
                        "enum": [
                           "reloaded",
                           "restarted",
                           "started",
                           "stopped"
                        ]
                     },
                     "enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether the service should start on boot. B(At least one of state and enabled are required.)"
                     },
                     "force": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether to override existing symlinks."
                     },
                     "masked": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether the unit should be masked or not, a masked unit is impossible to start."
                     },
                     "daemon_reload": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Run daemon-reload before doing any other operations, to make sure systemd has read any changes.\nWhen set to C(yes), runs daemon-reload even if the module does not start or stop anything."
                     },
                     "daemon-reload": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Run daemon-reload before doing any other operations, to make sure systemd has read any changes.\nWhen set to C(yes), runs daemon-reload even if the module does not start or stop anything."
                     },
                     "daemon_reexec": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Run daemon_reexec command before doing any other operations, the systemd manager will serialize the manager state."
                     },
                     "daemon-reexec": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Run daemon_reexec command before doing any other operations, the systemd manager will serialize the manager state."
                     },
                     "user": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "(deprecated) run ``systemctl`` talking to the service manager of the calling user, rather than the service manager of the system.\nThis option is deprecated and will eventually be removed in 2.11. The ``scope`` option should be used instead."
                     },
                     "scope": {
                        "type": "string",
                        "description": "run systemctl within a given service manager scope, either as the default system scope (system), the current user's scope (user), or the scope of all users (global).\nFor systemd to work with 'user', the executing user must have its own instance of dbus started (systemd requirement). The user dbus process is normally started during normal login, but not during the run of Ansible tasks. Otherwise you will probably get a 'Failed to connect to bus: no such file or directory' error.",
                        "enum": [
                           "system",
                           "user",
                           "global"
                        ]
                     },
                     "no_block": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Do not synchronously wait for the requested operation to finish. Enqueued job will continue without Ansible blocking on its completion."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "service",
                                    "unit"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "daemon_reload",
                                    "daemon-reload"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "daemon_reexec",
                                    "daemon-reexec"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "syspatch": {
                  "type": "object",
                  "description": "Manage OpenBSD system patches using syspatch",
                  "properties": {
                     "apply": {
                        "type": "string",
                        "description": "Apply all available system patches"
                     },
                     "revert": {
                        "type": "string",
                        "description": "Revert system patches",
                        "enum": [
                           "all",
                           "one"
                        ]
                     }
                  }
               },
               "sysctl": {
                  "type": "object",
                  "description": "This module manipulates sysctl entries and optionally performs a C(/sbin/sysctl -p) after changing them.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The dot-separated path (aka I(key)) specifying the sysctl variable."
                     },
                     "key": {
                        "type": "string",
                        "description": "The dot-separated path (aka I(key)) specifying the sysctl variable."
                     },
                     "value": {
                        "type": "string",
                        "description": "Desired value of the sysctl key."
                     },
                     "val": {
                        "type": "string",
                        "description": "Desired value of the sysctl key."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the entry should be present or absent in the sysctl file.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "ignoreerrors": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nUse this option to ignore errors about unknown keys."
                     },
                     "reload": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nIf C(yes), performs a I(/sbin/sysctl -p) if the C(sysctl_file) is updated. If C(no), does not reload I(sysctl) even if the C(sysctl_file) is updated."
                     },
                     "sysctl_file": {
                        "type": "string",
                        "description": "Default: /etc/sysctl.conf\n\nSpecifies the absolute path to C(sysctl.conf), if not C(/etc/sysctl.conf)."
                     },
                     "sysctl_set": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nVerify token value with the sysctl command and set with -w if necessary"
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "key"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "key"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "value",
                                    "val"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "svc": {
                  "type": "object",
                  "description": "Controls daemontools services on remote hosts using the svc utility.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the service to manage."
                     },
                     "state": {
                        "type": "string",
                        "description": "C(Started)/C(stopped) are idempotent actions that will not run commands unless necessary.  C(restarted) will always bounce the svc (svc -t) and C(killed) will always bounce the svc (svc -k). C(reloaded) will send a sigusr1 (svc -1). C(once) will run a normally downed svc once (svc -o), not really an idempotent operation.",
                        "enum": [
                           "killed",
                           "once",
                           "reloaded",
                           "restarted",
                           "started",
                           "stopped"
                        ]
                     },
                     "downed": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Should a 'down' file exist or not, if it exists it disables auto startup. Defaults to no. Downed does not imply stopped."
                     },
                     "enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether the service is enabled or not, if disabled it also implies stopped. Take note that a service can be enabled and downed (no auto restart)."
                     },
                     "service_dir": {
                        "type": "string",
                        "description": "Default: /service\n\nDirectory svscan watches for services"
                     },
                     "service_src": {
                        "type": "string",
                        "description": "Default: /etc/service\n\nDirectory where services are defined, the source of symlinks to service_dir."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "solaris_zone": {
                  "type": "object",
                  "description": "Create, start, stop and delete Solaris zones.\nThis module does not currently allow changing of options for a zone that is already been created.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nC(present), configure and install the zone.\nC(installed), synonym for C(present).\nC(running), if the zone already exists, boot it, otherwise, configure and install the zone first, then boot it.\nC(started), synonym for C(running).\nC(stopped), shutdown a zone.\nC(absent), destroy the zone.\nC(configured), configure the ready so that it's to be attached.\nC(attached), attach a zone, but do not boot it.\nC(detached), shutdown and detach a zone",
                        "enum": [
                           "absent",
                           "attached",
                           "configured",
                           "detached",
                           "installed",
                           "present",
                           "running",
                           "started",
                           "stopped"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "Zone name.\nA zone name must be unique name.\nA zone name must begin with an alpha-numeric character.\nThe name can contain alpha-numeric characters, underbars I(_), hyphens I(-), and periods I(.).\nThe name cannot be longer than 64 characters."
                     },
                     "path": {
                        "type": "string",
                        "description": "The path where the zone will be created. This is required when the zone is created, but not used otherwise."
                     },
                     "sparse": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether to create a sparse (C(true)) or whole root (C(false)) zone."
                     },
                     "root_password": {
                        "type": "string",
                        "description": "The password hash for the root account. If not specified, the zone's root account will not have a password."
                     },
                     "config": {
                        "type": "string",
                        "description": "The zonecfg configuration commands for this zone. See zonecfg(1M) for the valid options and syntax. Typically this is a list of options separated by semi-colons or new lines, e.g. \"set auto-boot=true;add net;set physical=bge0;set address=10.1.1.1;end\""
                     },
                     "create_options": {
                        "type": "string",
                        "description": "Extra options to the zonecfg(1M) create command."
                     },
                     "install_options": {
                        "type": "string",
                        "description": "Extra options to the zoneadm(1M) install command. To automate Solaris 11 zone creation, use this to specify the profile XML file, e.g. install_options=\"-c sc_profile.xml\""
                     },
                     "attach_options": {
                        "type": "string",
                        "description": "Extra options to the zoneadm attach command. For example, this can be used to specify whether a minimum or full update of packages is required and if any packages need to be deleted. For valid values, see zoneadm(1M)"
                     },
                     "timeout": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 600\n\nTimeout, in seconds, for zone to boot."
                     }
                  },
                  "required": [
                     "state",
                     "name"
                  ]
               },
               "setup": {
                  "type": "object",
                  "description": "This module is automatically called by playbooks to gather useful variables about remote hosts that can be used in playbooks. It can also be executed directly by C(/usr/bin/ansible) to check what variables are available to a host. Ansible provides many I(facts) about the system, automatically.\nThis module is also supported for Windows targets.",
                  "properties": {
                     "gather_subset": {
                        "type": "string",
                        "description": "Default: all\n\nIf supplied, restrict the additional facts collected to the given subset. Possible values: C(all), C(min), C(hardware), C(network), C(virtual), C(ohai), and C(facter). Can specify a list of values to specify a larger subset. Values can also be used with an initial C(!) to specify that that specific subset should not be collected.  For instance: C(!hardware,!network,!virtual,!ohai,!facter). If C(!all) is specified then only the min subset is collected. To avoid collecting even the min subset, specify C(!all,!min). To collect only specific facts, use C(!all,!min), and specify the particular fact subsets. Use the filter parameter if you do not want to display some collected facts."
                     },
                     "gather_timeout": {
                        "type": "string",
                        "description": "Default: 10\n\nSet the default timeout in seconds for individual fact gathering."
                     },
                     "filter": {
                        "type": "string",
                        "description": "Default: *\n\nIf supplied, only return facts that match this shell-style (fnmatch) wildcard."
                     },
                     "fact_path": {
                        "type": "string",
                        "description": "Default: /etc/ansible/facts.d\n\nPath used for local ansible facts (C(*.fact)) - files in this dir will be run (if executable) and their results be added to C(ansible_local) facts if a file is not executable it is read. Check notes for Windows options. (from 2.1 on) File/results format can be JSON or INI-format. The default C(fact_path) can be specified in C(ansible.cfg) for when setup is automatically called as part of C(gather_facts)."
                     }
                  }
               },
               "service_facts": {
                  "type": "object",
                  "description": "Return service state information as fact data for various service management utilities",
                  "properties": {}
               },
               "service": {
                  "type": "object",
                  "description": "Controls services on remote hosts. Supported init systems include BSD init, OpenRC, SysV, Solaris SMF, systemd, upstart.\nFor Windows targets, use the M(win_service) module instead.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the service."
                     },
                     "state": {
                        "type": "string",
                        "description": "C(started)/C(stopped) are idempotent actions that will not run commands unless necessary.\nC(restarted) will always bounce the service.\nC(reloaded) will always reload.\nB(At least one of state and enabled are required.)\nNote that reloaded will start the service if it is not already started, even if your chosen init system wouldn't normally.",
                        "enum": [
                           "reloaded",
                           "restarted",
                           "started",
                           "stopped"
                        ]
                     },
                     "sleep": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "If the service is being C(restarted) then sleep this many seconds between the stop and start command.\nThis helps to work around badly-behaving init scripts that exit immediately after signaling a process to stop.\nNot all service managers support sleep, i.e when using systemd this setting will be ignored."
                     },
                     "pattern": {
                        "type": "string",
                        "description": "If the service does not respond to the status command, name a substring to look for as would be found in the output of the I(ps) command as a stand-in for a status result.\nIf the string is found, the service will be assumed to be started."
                     },
                     "enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether the service should start on boot.\nB(At least one of state and enabled are required.)"
                     },
                     "runlevel": {
                        "type": "string",
                        "description": "Default: default\n\nFor OpenRC init scripts (e.g. Gentoo) only.\nThe runlevel that this service belongs to."
                     },
                     "arguments": {
                        "type": "string",
                        "description": "Additional arguments provided on the command line."
                     },
                     "args": {
                        "type": "string",
                        "description": "Additional arguments provided on the command line."
                     },
                     "use": {
                        "type": "string",
                        "description": "Default: auto\n\nThe service module actually uses system specific modules, normally through auto detection, this setting can force a specific module.\nNormally it uses the value of the 'ansible_service_mgr' fact and falls back to the old 'service' module when none matching is found."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "arguments",
                                    "args"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "seport": {
                  "type": "object",
                  "description": "Manages SELinux network port type definitions.",
                  "properties": {
                     "ports": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Ports or port ranges.\nCan be a list (since 2.6) or comma separated string."
                     },
                     "proto": {
                        "type": "string",
                        "description": "Protocol for the specified port.",
                        "enum": [
                           "tcp",
                           "udp"
                        ]
                     },
                     "setype": {
                        "type": "string",
                        "description": "SELinux type for the specified port."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDesired boolean value.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "reload": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nReload SELinux policy after commit."
                     },
                     "ignore_selinux_state": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Run independent of selinux runtime state"
                     }
                  },
                  "required": [
                     "ports",
                     "proto",
                     "setype"
                  ]
               },
               "selogin": {
                  "type": "object",
                  "description": "Manages linux user to SELinux user mapping",
                  "properties": {
                     "login": {
                        "type": "string",
                        "description": "a Linux user"
                     },
                     "seuser": {
                        "type": "string",
                        "description": "SELinux user name"
                     },
                     "selevel": {
                        "type": "string",
                        "description": "Default: s0\n\nMLS/MCS Security Range (MLS/MCS Systems only) SELinux Range for SELinux login mapping defaults to the SELinux user record range."
                     },
                     "serange": {
                        "type": "string",
                        "description": "Default: s0\n\nMLS/MCS Security Range (MLS/MCS Systems only) SELinux Range for SELinux login mapping defaults to the SELinux user record range."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDesired mapping value.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "reload": {
                        "type": "string",
                        "description": "Default: True\n\nReload SELinux policy after commit."
                     },
                     "ignore_selinux_state": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Run independent of selinux runtime state"
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "selevel",
                                    "serange"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "selinux_permissive": {
                  "type": "object",
                  "description": "Add and remove a domain from the list of permissive domains.",
                  "properties": {
                     "domain": {
                        "type": "string",
                        "description": "The domain that will be added or removed from the list of permissive domains."
                     },
                     "name": {
                        "type": "string",
                        "description": "The domain that will be added or removed from the list of permissive domains."
                     },
                     "permissive": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Indicate if the domain should or should not be set as permissive."
                     },
                     "no_reload": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Disable reloading of the SELinux policy after making change to a domain's permissive setting.\nThe default is C(no), which causes policy to be reloaded when a domain changes state.\nReloading the policy does not work on older versions of the C(policycoreutils-python) library, for example in EL 6.\""
                     },
                     "store": {
                        "type": "string",
                        "description": "Name of the SELinux policy store to use."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "domain",
                                    "name"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "domain"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "selinux": {
                  "type": "object",
                  "description": "Configures the SELinux mode and policy.\nA reboot may be required after usage.\nAnsible will not issue this reboot but will let you know when it is required.",
                  "properties": {
                     "policy": {
                        "type": "string",
                        "description": "The name of the SELinux policy to use (e.g. C(targeted)) will be required if state is not C(disabled)."
                     },
                     "state": {
                        "type": "string",
                        "description": "The SELinux mode.",
                        "enum": [
                           "disabled",
                           "enforcing",
                           "permissive"
                        ]
                     },
                     "configfile": {
                        "type": "string",
                        "description": "Default: /etc/selinux/config\n\nThe path to the SELinux configuration file, if non-standard."
                     },
                     "conf": {
                        "type": "string",
                        "description": "Default: /etc/selinux/config\n\nThe path to the SELinux configuration file, if non-standard."
                     },
                     "file": {
                        "type": "string",
                        "description": "Default: /etc/selinux/config\n\nThe path to the SELinux configuration file, if non-standard."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "configfile",
                                    "conf",
                                    "file"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "sefcontext": {
                  "type": "object",
                  "description": "Manages SELinux file context mapping definitions.\nSimilar to the C(semanage fcontext) command.",
                  "properties": {
                     "target": {
                        "type": "string",
                        "description": "Target path (expression)."
                     },
                     "path": {
                        "type": "string",
                        "description": "Target path (expression)."
                     },
                     "ftype": {
                        "type": "string",
                        "description": "Default: a\n\nThe file type that should have SELinux contexts applied.\nThe following file type options are available:\nC(a) for all files,\nC(b) for block devices,\nC(c) for character devices,\nC(d) for directories,\nC(f) for regular files,\nC(l) for symbolic links,\nC(p) for named pipes,\nC(s) for socket files.",
                        "enum": [
                           "a",
                           "b",
                           "c",
                           "d",
                           "f",
                           "l",
                           "p",
                           "s"
                        ]
                     },
                     "setype": {
                        "type": "string",
                        "description": "SELinux type for the specified target."
                     },
                     "seuser": {
                        "type": "string",
                        "description": "SELinux user for the specified target."
                     },
                     "selevel": {
                        "type": "string",
                        "description": "SELinux range for the specified target."
                     },
                     "serange": {
                        "type": "string",
                        "description": "SELinux range for the specified target."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the SELinux file context must be C(absent) or C(present).",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "reload": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nReload SELinux policy after commit.\nNote that this does not apply SELinux file contexts to existing files."
                     },
                     "ignore_selinux_state": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Useful for scenarios (chrooted environment) that you can't get the real SELinux state."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "target",
                                    "path"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "target"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "path"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "selevel",
                                    "serange"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "seboolean": {
                  "type": "object",
                  "description": "Toggles SELinux booleans.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the boolean to configure."
                     },
                     "persistent": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nSet to C(yes) if the boolean setting should survive a reboot."
                     },
                     "state": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Desired boolean value"
                     },
                     "ignore_selinux_state": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Useful for scenarios (chrooted environment) that you can't get the real SELinux state."
                     }
                  },
                  "required": [
                     "name",
                     "state"
                  ]
               },
               "runit": {
                  "type": "object",
                  "description": "Controls runit services on remote hosts using the sv utility.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the service to manage."
                     },
                     "state": {
                        "type": "string",
                        "description": "C(started)/C(stopped) are idempotent actions that will not run commands unless necessary.  C(restarted) will always bounce the service (sv restart) and C(killed) will always bounce the service (sv force-stop). C(reloaded) will send a HUP (sv reload). C(once) will run a normally downed sv once (sv once), not really an idempotent operation.",
                        "enum": [
                           "killed",
                           "once",
                           "reloaded",
                           "restarted",
                           "started",
                           "stopped"
                        ]
                     },
                     "enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether the service is enabled or not, if disabled it also implies stopped."
                     },
                     "service_dir": {
                        "type": "string",
                        "description": "Default: /var/service\n\ndirectory runsv watches for services"
                     },
                     "service_src": {
                        "type": "string",
                        "description": "Default: /etc/sv\n\ndirectory where services are defined, the source of symlinks to service_dir."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "reboot": {
                  "type": "object",
                  "description": "Reboot a machine, wait for it to go down, come back up, and respond to commands.\nFor Windows targets, use the M(win_reboot) module instead.",
                  "properties": {
                     "pre_reboot_delay": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Seconds to wait before reboot. Passed as a parameter to the reboot command.\nOn Linux, macOS and OpenBSD, this is converted to minutes and rounded down. If less than 60, it will be set to 0.\nOn Solaris and FreeBSD, this will be seconds."
                     },
                     "post_reboot_delay": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Seconds to wait after the reboot command was successful before attempting to validate the system rebooted successfully.\nThis is useful if you want wait for something to settle despite your connection already working."
                     },
                     "reboot_timeout": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 600\n\nMaximum seconds to wait for machine to reboot and respond to a test command.\nThis timeout is evaluated separately for both reboot verification and test command success so the maximum execution time for the module is twice this amount."
                     },
                     "connect_timeout": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Maximum seconds to wait for a successful connection to the managed hosts before trying again.\nIf unspecified, the default setting for the underlying connection plugin is used."
                     },
                     "test_command": {
                        "type": "string",
                        "description": "Default: whoami\n\nCommand to run on the rebooted host and expect success from to determine the machine is ready for further tasks."
                     },
                     "msg": {
                        "type": "string",
                        "description": "Default: Reboot initiated by Ansible\n\nMessage to display to users before reboot."
                     },
                     "search_paths": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Default: ['/sbin', '/usr/sbin', '/usr/local/sbin']\n\nPaths to search on the remote machine for the C(shutdown) command.\nI(Only) these paths will be searched for the C(shutdown) command. C(PATH) is ignored in the remote node when searching for the C(shutdown) command."
                     }
                  }
               },
               "python_requirements_info": {
                  "type": "object",
                  "description": "Get info about available Python requirements on the target host, including listing required libraries and gathering versions.\nThis module was called C(python_requirements_facts) before Ansible 2.9. The usage did not change.",
                  "properties": {
                     "dependencies": {
                        "type": "string",
                        "description": "A list of version-likes or module names to check for installation. Supported operators: <, >, <=, >=, or ==. The bare module name like I(ansible), the module with a specific version like I(boto3==1.6.1), or a partial version like I(requests>2) are all valid specifications.\n"
                     }
                  }
               },
               "puppet": {
                  "type": "object",
                  "description": "Runs I(puppet) agent or apply in a reliable manner.",
                  "properties": {
                     "timeout": {
                        "type": "string",
                        "description": "Default: 30m\n\nHow long to wait for I(puppet) to finish."
                     },
                     "puppetmaster": {
                        "type": "string",
                        "description": "The hostname of the puppetmaster to contact."
                     },
                     "modulepath": {
                        "type": "string",
                        "description": "Path to an alternate location for puppet modules."
                     },
                     "manifest": {
                        "type": "string",
                        "description": "Path to the manifest file to run puppet apply on."
                     },
                     "noop": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Override puppet.conf noop mode.\nWhen C(yes), run Puppet agent with C(--noop) switch set.\nWhen C(no), run Puppet agent with C(--no-noop) switch set.\nWhen unset (default), use default or puppet.conf value if defined."
                     },
                     "facts": {
                        "type": "object",
                        "description": "A dict of values to pass in as persistent external facter facts."
                     },
                     "facter_basename": {
                        "type": "string",
                        "description": "Default: ansible\n\nBasename of the facter output file."
                     },
                     "environment": {
                        "type": "string",
                        "description": "Puppet environment to be used."
                     },
                     "logdest": {
                        "type": "string",
                        "description": "Default: stdout\n\nWhere the puppet logs should go, if puppet apply is being used.\nC(all) will go to both C(stdout) and C(syslog).",
                        "enum": [
                           "all",
                           "stdout",
                           "syslog"
                        ]
                     },
                     "certname": {
                        "type": "string",
                        "description": "The name to use when handling certificates."
                     },
                     "tags": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "A list of puppet tags to be used."
                     },
                     "execute": {
                        "type": "string",
                        "description": "Execute a specific piece of Puppet code.\nIt has no effect with a puppetmaster."
                     },
                     "use_srv_records": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Toggles use_srv_records flag"
                     },
                     "summarize": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether to print a transaction summary."
                     },
                     "verbose": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Print extra information."
                     },
                     "debug": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Enable full debugging."
                     }
                  }
               },
               "pids": {
                  "type": "object",
                  "description": "Retrieves a list of PIDs of given process name in Ansible controller/controlled machines.Returns an empty list if no process in that name exists.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "the name of the process you want to get PID for."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "parted": {
                  "type": "object",
                  "description": "This module allows configuring block device partition using the C(parted) command line tool. For a full description of the fields and the options check the GNU parted manual.",
                  "properties": {
                     "device": {
                        "type": "string",
                        "description": "The block device (disk) where to operate."
                     },
                     "align": {
                        "type": "string",
                        "description": "Default: optimal\n\nSet alignment for newly created partitions.",
                        "enum": [
                           "cylinder",
                           "minimal",
                           "none",
                           "optimal"
                        ]
                     },
                     "number": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "The number of the partition to work with or the number of the partition that will be created.\nRequired when performing any action on the disk, except fetching information."
                     },
                     "unit": {
                        "type": "string",
                        "description": "Default: KiB\n\nSelects the current default unit that Parted will use to display locations and capacities on the disk and to interpret those given by the user if they are not suffixed by an unit.\nWhen fetching information about a disk, it is always recommended to specify a unit.",
                        "enum": [
                           "s",
                           "B",
                           "KB",
                           "KiB",
                           "MB",
                           "MiB",
                           "GB",
                           "GiB",
                           "TB",
                           "TiB",
                           "%",
                           "cyl",
                           "chs",
                           "compact"
                        ]
                     },
                     "label": {
                        "type": "string",
                        "description": "Default: msdos\n\nCreates a new disk label.",
                        "enum": [
                           "aix",
                           "amiga",
                           "bsd",
                           "dvh",
                           "gpt",
                           "loop",
                           "mac",
                           "msdos",
                           "pc98",
                           "sun"
                        ]
                     },
                     "part_type": {
                        "type": "string",
                        "description": "Default: primary\n\nMay be specified only with 'msdos' or 'dvh' partition tables.\nA C(name) must be specified for a 'gpt' partition table.\nNeither C(part_type) nor C(name) may be used with a 'sun' partition table.",
                        "enum": [
                           "extended",
                           "logical",
                           "primary"
                        ]
                     },
                     "part_start": {
                        "type": "string",
                        "description": "Default: 0%\n\nWhere the partition will start as offset from the beginning of the disk, that is, the \"distance\" from the start of the disk.\nThe distance can be specified with all the units supported by parted (except compat) and it is case sensitive, e.g. C(10GiB), C(15%)."
                     },
                     "part_end": {
                        "type": "string",
                        "description": "Default: 100%\n\nWhere the partition will end as offset from the beginning of the disk, that is, the \"distance\" from the start of the disk.\nThe distance can be specified with all the units supported by parted (except compat) and it is case sensitive, e.g. C(10GiB), C(15%)."
                     },
                     "name": {
                        "type": "string",
                        "description": "Sets the name for the partition number (GPT, Mac, MIPS and PC98 only)."
                     },
                     "flags": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "A list of the flags that has to be set on the partition."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: info\n\nWhether to create or delete a partition.\nIf set to C(info) the module will only return the device information.",
                        "enum": [
                           "absent",
                           "present",
                           "info"
                        ]
                     }
                  },
                  "required": [
                     "device"
                  ]
               },
               "pamd": {
                  "type": "object",
                  "description": "Edit PAM service's type, control, module path and module arguments.\nIn order for a PAM rule to be modified, the type, control and module_path must match an existing rule.  See man(5) pam.d for details.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name generally refers to the PAM service file to change, for example system-auth."
                     },
                     "type": {
                        "type": "string",
                        "description": "The type of the PAM rule being modified.\nThe C(type), C(control) and C(module_path) all must match a rule to be modified.",
                        "enum": [
                           "account",
                           "-account",
                           "auth",
                           "-auth",
                           "password",
                           "-password",
                           "session",
                           "-session"
                        ]
                     },
                     "control": {
                        "type": "string",
                        "description": "The control of the PAM rule being modified.\nThis may be a complicated control with brackets. If this is the case, be sure to put \"[bracketed controls]\" in quotes.\nThe C(type), C(control) and C(module_path) all must match a rule to be modified."
                     },
                     "module_path": {
                        "type": "string",
                        "description": "The module path of the PAM rule being modified.\nThe C(type), C(control) and C(module_path) all must match a rule to be modified."
                     },
                     "new_type": {
                        "type": "string",
                        "description": "The new type to assign to the new rule.",
                        "enum": [
                           "account",
                           "-account",
                           "auth",
                           "-auth",
                           "password",
                           "-password",
                           "session",
                           "-session"
                        ]
                     },
                     "new_control": {
                        "type": "string",
                        "description": "The new control to assign to the new rule."
                     },
                     "new_module_path": {
                        "type": "string",
                        "description": "The new module path to be assigned to the new rule."
                     },
                     "module_arguments": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "When state is C(updated), the module_arguments will replace existing module_arguments.\nWhen state is C(args_absent) args matching those listed in module_arguments will be removed.\nWhen state is C(args_present) any args listed in module_arguments are added if missing from the existing rule.\nFurthermore, if the module argument takes a value denoted by C(=), the value will be changed to that specified in module_arguments."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: updated\n\nThe default of C(updated) will modify an existing rule if type, control and module_path all match an existing rule.\nWith C(before), the new rule will be inserted before a rule matching type, control and module_path.\nSimilarly, with C(after), the new rule will be inserted after an existing rulematching type, control and module_path.\nWith either C(before) or C(after) new_type, new_control, and new_module_path must all be specified.\nIf state is C(args_absent) or C(args_present), new_type, new_control, and new_module_path will be ignored.\nState C(absent) will remove the rule.  The 'absent' state was added in Ansible 2.4.",
                        "enum": [
                           "absent",
                           "before",
                           "after",
                           "args_absent",
                           "args_present",
                           "updated"
                        ]
                     },
                     "path": {
                        "type": "string",
                        "description": "Default: /etc/pam.d\n\nThis is the path to the PAM service files."
                     },
                     "backup": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly."
                     }
                  },
                  "required": [
                     "name",
                     "type",
                     "control",
                     "module_path"
                  ]
               },
               "pam_limits": {
                  "type": "object",
                  "description": "The C(pam_limits) module modifies PAM limits. The default file is C(/etc/security/limits.conf). For the full documentation, see C(man 5 limits.conf).",
                  "properties": {
                     "domain": {
                        "type": "string",
                        "description": "A username, @groupname, wildcard, uid/gid range."
                     },
                     "limit_type": {
                        "type": "string",
                        "description": "Limit type, see C(man 5 limits.conf) for an explanation",
                        "enum": [
                           "hard",
                           "soft",
                           "-"
                        ]
                     },
                     "limit_item": {
                        "type": "string",
                        "description": "The limit to be set",
                        "enum": [
                           "core",
                           "data",
                           "fsize",
                           "memlock",
                           "nofile",
                           "rss",
                           "stack",
                           "cpu",
                           "nproc",
                           "as",
                           "maxlogins",
                           "maxsyslogins",
                           "priority",
                           "locks",
                           "sigpending",
                           "msgqueue",
                           "nice",
                           "rtprio",
                           "chroot"
                        ]
                     },
                     "value": {
                        "type": "string",
                        "description": "The value of the limit."
                     },
                     "backup": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nCreate a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly."
                     },
                     "use_min": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nIf set to C(yes), the minimal value will be used or conserved. If the specified value is inferior to the value in the file, file content is replaced with the new value, else content is not modified."
                     },
                     "use_max": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nIf set to C(yes), the maximal value will be used or conserved. If the specified value is superior to the value in the file, file content is replaced with the new value, else content is not modified."
                     },
                     "dest": {
                        "type": "string",
                        "description": "Default: /etc/security/limits.conf\n\nModify the limits.conf path."
                     },
                     "comment": {
                        "type": "string",
                        "description": "Comment associated with the limit."
                     }
                  },
                  "required": [
                     "domain",
                     "limit_type",
                     "limit_item",
                     "value"
                  ]
               },
               "osx_defaults": {
                  "type": "object",
                  "description": "osx_defaults allows users to read, write, and delete macOS user defaults from Ansible scripts.\nmacOS applications and other programs use the defaults system to record user preferences and other information that must be maintained when the applications are not running (such as default font for new documents, or the position of an Info panel).",
                  "properties": {
                     "domain": {
                        "type": "string",
                        "description": "Default: NSGlobalDomain\n\nThe domain is a domain name of the form C(com.companyname.appname)."
                     },
                     "host": {
                        "type": "string",
                        "description": "The host on which the preference should apply.\nThe special value C(currentHost) corresponds to the C(-currentHost) switch of the defaults commandline tool."
                     },
                     "key": {
                        "type": "string",
                        "description": "The key of the user preference."
                     },
                     "type": {
                        "type": "string",
                        "description": "Default: string\n\nThe type of value to write.",
                        "enum": [
                           "array",
                           "bool",
                           "boolean",
                           "date",
                           "float",
                           "int",
                           "integer",
                           "string"
                        ]
                     },
                     "array_add": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Add new elements to the array for a key which has an array as its value."
                     },
                     "value": {
                        "type": "string",
                        "description": "The value to write.\nOnly required when C(state=present)."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nThe state of the user defaults.\nIf set to C(list) will query the given parameter specified by C(key). Returns 'null' is nothing found or mis-spelled.\nC(list) added in version 2.8.",
                        "enum": [
                           "absent",
                           "list",
                           "present"
                        ]
                     },
                     "path": {
                        "type": "string",
                        "description": "Default: /usr/bin:/usr/local/bin\n\nThe path in which to search for C(defaults)."
                     }
                  },
                  "required": [
                     "key"
                  ]
               },
               "openwrt_init": {
                  "type": "object",
                  "description": "Controls OpenWrt services on remote hosts.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the service."
                     },
                     "service": {
                        "type": "string",
                        "description": "Name of the service."
                     },
                     "state": {
                        "type": "string",
                        "description": "C(started)/C(stopped) are idempotent actions that will not run commands unless necessary. C(restarted) will always bounce the service. C(reloaded) will always reload.",
                        "enum": [
                           "started",
                           "stopped",
                           "restarted",
                           "reloaded"
                        ]
                     },
                     "enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether the service should start on boot. B(At least one of state and enabled are required.)"
                     },
                     "pattern": {
                        "type": "string",
                        "description": "If the service does not respond to the 'running' command, name a substring to look for as would be found in the output of the I(ps) command as a stand-in for a 'running' result.  If the string is found, the service will be assumed to be running."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "service"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "service"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "open_iscsi": {
                  "type": "object",
                  "description": "Discover targets on given portal, (dis)connect targets, mark targets to manually or auto start, return device nodes of connected targets.",
                  "properties": {
                     "portal": {
                        "type": "string",
                        "description": "The IP address of the iSCSI target."
                     },
                     "ip": {
                        "type": "string",
                        "description": "The IP address of the iSCSI target."
                     },
                     "port": {
                        "type": "string",
                        "description": "Default: 3260\n\nThe port on which the iSCSI target process listens."
                     },
                     "target": {
                        "type": "string",
                        "description": "The iSCSI target name."
                     },
                     "name": {
                        "type": "string",
                        "description": "The iSCSI target name."
                     },
                     "targetname": {
                        "type": "string",
                        "description": "The iSCSI target name."
                     },
                     "login": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether the target node should be connected."
                     },
                     "state": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether the target node should be connected."
                     },
                     "node_auth": {
                        "type": "string",
                        "description": "Default: CHAP\n\nThe value for C(discovery.sendtargets.auth.authmethod)."
                     },
                     "node_user": {
                        "type": "string",
                        "description": "The value for C(discovery.sendtargets.auth.username)."
                     },
                     "node_pass": {
                        "type": "string",
                        "description": "The value for C(discovery.sendtargets.auth.password)."
                     },
                     "auto_node_startup": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether the target node should be automatically connected at startup."
                     },
                     "automatic": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether the target node should be automatically connected at startup."
                     },
                     "discover": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether the list of target nodes on the portal should be (re)discovered and added to the persistent iSCSI database.\nKeep in mind that C(iscsiadm) discovery resets configuration, like C(node.startup) to manual, hence combined with C(auto_node_startup=yes) will always return a changed state."
                     },
                     "show_nodes": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether the list of nodes in the persistent iSCSI database should be returned by the module."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "portal",
                                    "ip"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "target",
                                    "name",
                                    "targetname"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "login",
                                    "state"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "auto_node_startup",
                                    "automatic"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "ohai": {
                  "type": "object",
                  "description": "Similar to the M(facter) module, this runs the I(Ohai) discovery program (U(https://docs.chef.io/ohai.html)) on the remote host and returns JSON inventory data. I(Ohai) data is a bit more verbose and nested than I(facter).",
                  "properties": {}
               },
               "nosh": {
                  "type": "object",
                  "description": "Control running and enabled state for system-wide or user services.\nBSD and Linux systems are supported.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the service to manage."
                     },
                     "state": {
                        "type": "string",
                        "description": "C(started)/C(stopped) are idempotent actions that will not run commands unless necessary. C(restarted) will always bounce the service. C(reloaded) will send a SIGHUP or start the service. C(reset) will start or stop the service according to whether it is enabled or not.",
                        "enum": [
                           "started",
                           "stopped",
                           "reset",
                           "restarted",
                           "reloaded"
                        ]
                     },
                     "enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Enable or disable the service, independently of C(*.preset) file preference or running state. Mutually exclusive with I(preset). Will take effect prior to I(state=reset)."
                     },
                     "preset": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Enable or disable the service according to local preferences in *.preset files. Mutually exclusive with I(enabled). Only has an effect if set to true. Will take effect prior to I(state=reset)."
                     },
                     "user": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nRun system-control talking to the calling user's service manager, rather than the system-wide service manager."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "mount": {
                  "type": "object",
                  "description": "This module controls active and configured mount points in C(/etc/fstab).",
                  "properties": {
                     "path": {
                        "type": "string",
                        "description": "Path to the mount point (e.g. C(/mnt/files)).\nBefore Ansible 2.3 this option was only usable as I(dest), I(destfile) and I(name)."
                     },
                     "name": {
                        "type": "string",
                        "description": "Path to the mount point (e.g. C(/mnt/files)).\nBefore Ansible 2.3 this option was only usable as I(dest), I(destfile) and I(name)."
                     },
                     "src": {
                        "type": "string",
                        "description": "Device to be mounted on I(path).\nRequired when I(state) set to C(present) or C(mounted)."
                     },
                     "fstype": {
                        "type": "string",
                        "description": "Filesystem type.\nRequired when I(state) is C(present) or C(mounted)."
                     },
                     "opts": {
                        "type": "string",
                        "description": "Mount options (see fstab(5), or vfstab(4) on Solaris)."
                     },
                     "dump": {
                        "type": "string",
                        "description": "Dump (see fstab(5)).\nNote that if set to C(null) and I(state) set to C(present), it will cease to work and duplicate entries will be made with subsequent runs.\nHas no effect on Solaris systems."
                     },
                     "passno": {
                        "type": "string",
                        "description": "Passno (see fstab(5)).\nNote that if set to C(null) and I(state) set to C(present), it will cease to work and duplicate entries will be made with subsequent runs.\nDeprecated on Solaris systems."
                     },
                     "state": {
                        "type": "string",
                        "description": "If C(mounted), the device will be actively mounted and appropriately configured in I(fstab). If the mount point is not present, the mount point will be created.\nIf C(unmounted), the device will be unmounted without changing I(fstab).\nC(present) only specifies that the device is to be configured in I(fstab) and does not trigger or require a mount.\nC(absent) specifies that the device mount's entry will be removed from I(fstab) and will also unmount the device and remove the mount point.\nC(remounted) specifies that the device will be remounted for when you want to force a refresh on the mount itself (added in 2.9). This will always return changed=true.",
                        "enum": [
                           "absent",
                           "mounted",
                           "present",
                           "unmounted",
                           "remounted"
                        ]
                     },
                     "fstab": {
                        "type": "string",
                        "description": "File to use instead of C(/etc/fstab).\nYou should not use this option unless you really know what you are doing.\nThis might be useful if you need to configure mountpoints in a chroot environment.\nOpenBSD does not allow specifying alternate fstab files with mount so do not use this on OpenBSD with any state that operates on the live filesystem.\nThis parameter defaults to /etc/fstab or /etc/vfstab on Solaris."
                     },
                     "boot": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nDetermines if the filesystem should be mounted on boot.\nOnly applies to Solaris systems."
                     },
                     "backup": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Create a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "path",
                                    "name"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "path"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "modprobe": {
                  "type": "object",
                  "description": "Load or unload kernel modules.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of kernel module to manage."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the module should be present or absent.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "params": {
                        "type": "string",
                        "description": "Modules parameters."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "mksysb": {
                  "type": "object",
                  "description": "This module manages a basic AIX mksysb (image) of rootvg.",
                  "properties": {
                     "backup_crypt_files": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nBackup encrypted files."
                     },
                     "backup_dmapi_fs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nBack up DMAPI filesystem files."
                     },
                     "create_map_files": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nCreates a new MAP files."
                     },
                     "exclude_files": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nExcludes files using C(/etc/rootvg.exclude)."
                     },
                     "exclude_wpar_files": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nExcludes WPAR files."
                     },
                     "extended_attrs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nBackup extended attributes."
                     },
                     "name": {
                        "type": "string",
                        "description": "Backup name"
                     },
                     "new_image_data": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nCreates a new file data."
                     },
                     "software_packing": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nExclude files from packing option listed in C(/etc/exclude_packing.rootvg)."
                     },
                     "storage_path": {
                        "type": "string",
                        "description": "Storage path where the mksysb will stored."
                     },
                     "use_snapshot": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nCreates backup using snapshots."
                     }
                  },
                  "required": [
                     "name",
                     "storage_path"
                  ]
               },
               "make": {
                  "type": "object",
                  "description": "Run targets in a Makefile.",
                  "properties": {
                     "target": {
                        "type": "string",
                        "description": "The target to run.\nTypically this would be something like C(install),C(test) or C(all).\""
                     },
                     "params": {
                        "type": "object",
                        "description": "Any extra parameters to pass to make."
                     },
                     "chdir": {
                        "type": "string",
                        "description": "Change to this directory before running make."
                     },
                     "file": {
                        "type": "string",
                        "description": "Use a custom Makefile."
                     }
                  },
                  "required": [
                     "chdir"
                  ]
               },
               "lvol": {
                  "type": "object",
                  "description": "This module creates, removes or resizes logical volumes.",
                  "properties": {
                     "vg": {
                        "type": "string",
                        "description": "The volume group this logical volume is part of."
                     },
                     "lv": {
                        "type": "string",
                        "description": "The name of the logical volume."
                     },
                     "size": {
                        "type": "string",
                        "description": "The size of the logical volume, according to lvcreate(8) --size, by default in megabytes or optionally with one of [bBsSkKmMgGtTpPeE] units; or according to lvcreate(8) --extents as a percentage of [VG|PVS|FREE]; Float values must begin with a digit. Resizing using percentage values was not supported prior to 2.1."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nControl if the logical volume exists. If C(present) and the volume does not already exist then the C(size) option is required.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "active": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nWhether the volume is activate and visible to the host."
                     },
                     "force": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nShrink or remove operations of volumes requires this switch. Ensures that that filesystems get never corrupted/destroyed by mistake."
                     },
                     "opts": {
                        "type": "string",
                        "description": "Free-form options to be passed to the lvcreate command."
                     },
                     "snapshot": {
                        "type": "string",
                        "description": "The name of the snapshot volume"
                     },
                     "pvs": {
                        "type": "string",
                        "description": "Comma separated list of physical volumes (e.g. /dev/sda,/dev/sdb)."
                     },
                     "thinpool": {
                        "type": "string",
                        "description": "The thin pool volume name. When you want to create a thin provisioned volume, specify a thin pool volume name."
                     },
                     "shrink": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nShrink if current size is higher than size requested."
                     },
                     "resizefs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nResize the underlying filesystem together with the logical volume."
                     }
                  }
               },
               "lvg": {
                  "type": "object",
                  "description": "This module creates, removes or resizes volume groups.",
                  "properties": {
                     "vg": {
                        "type": "string",
                        "description": "The name of the volume group."
                     },
                     "pvs": {
                        "type": "array",
                        "description": "List of comma-separated devices to use as physical devices in this volume group.\nRequired when creating or resizing volume group.\nThe module will take care of running pvcreate if needed."
                     },
                     "pesize": {
                        "type": "string",
                        "description": "Default: 4\n\nThe size of the physical extent. I(pesize) must be a power of 2 of at least 1 sector (where the sector size is the largest sector size of the PVs currently used in the VG), or at least 128KiB.\nSince Ansible 2.6, pesize can be optionally suffixed by a UNIT (k/K/m/M/g/G), default unit is megabyte."
                     },
                     "pv_options": {
                        "type": "string",
                        "description": "Additional options to pass to C(pvcreate) when creating the volume group."
                     },
                     "vg_options": {
                        "type": "string",
                        "description": "Additional options to pass to C(vgcreate) when creating the volume group."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nControl if the volume group exists.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "force": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "If C(yes), allows to remove volume group with logical volumes."
                     }
                  },
                  "required": [
                     "vg"
                  ]
               },
               "locale_gen": {
                  "type": "object",
                  "description": "Manages locales by editing /etc/locale.gen and invoking locale-gen.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name and encoding of the locale, such as \"en_GB.UTF-8\"."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the locale shall be present.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "listen_ports_facts": {
                  "type": "object",
                  "description": "Gather facts on processes listening on TCP and UDP ports.",
                  "properties": {}
               },
               "known_hosts": {
                  "type": "object",
                  "description": "The C(known_hosts) module lets you add or remove a host keys from the C(known_hosts) file.\nStarting at Ansible 2.2, multiple entries per host are allowed, but only one for each key type supported by ssh. This is useful if you're going to want to use the M(git) module over ssh, for example.\nIf you have a very large number of host keys to manage, you will find the M(template) module more useful.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The host to add or remove (must match a host specified in key). It will be converted to lowercase so that ssh-keygen can find it.\nMust match with <hostname> or <ip> present in key attribute."
                     },
                     "host": {
                        "type": "string",
                        "description": "The host to add or remove (must match a host specified in key). It will be converted to lowercase so that ssh-keygen can find it.\nMust match with <hostname> or <ip> present in key attribute."
                     },
                     "key": {
                        "type": "string",
                        "description": "The SSH public host key, as a string (required if state=present, optional when state=absent, in which case all keys for the host are removed). The key must be in the right format for ssh (see sshd(8), section \"SSH_KNOWN_HOSTS FILE FORMAT\").\nSpecifically, the key should not match the format that is found in an SSH pubkey file, but should rather have the hostname prepended to a line that includes the pubkey, the same way that it would appear in the known_hosts file. The value prepended to the line must also match the value of the name parameter.\nShould be of format `<hostname[,IP]> ssh-rsa <pubkey>`"
                     },
                     "path": {
                        "type": "string",
                        "description": "Default: (homedir)+/.ssh/known_hosts\n\nThe known_hosts file to edit"
                     },
                     "hash_host": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nHash the hostname in the known_hosts file"
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nI(present) to add the host key, I(absent) to remove it.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "host"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "host"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "kernel_blacklist": {
                  "type": "object",
                  "description": "Add or remove kernel modules from blacklist.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of kernel module to black- or whitelist."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the module should be present in the blacklist or absent.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "blacklist_file": {
                        "type": "string",
                        "description": "If specified, use this blacklist file instead of C(/etc/modprobe.d/blacklist-ansible.conf)."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "java_keystore": {
                  "type": "object",
                  "description": "Create or delete a Java keystore in JKS format for a given certificate.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the certificate."
                     },
                     "certificate": {
                        "type": "string",
                        "description": "Certificate that should be used to create the key store."
                     },
                     "private_key": {
                        "type": "string",
                        "description": "Private key that should be used to create the key store."
                     },
                     "password": {
                        "type": "string",
                        "description": "Password that should be used to secure the key store."
                     },
                     "dest": {
                        "type": "string",
                        "description": "Absolute path where the jks should be generated."
                     },
                     "owner": {
                        "type": "string",
                        "description": "Name of the user that should own jks file."
                     },
                     "group": {
                        "type": "string",
                        "description": "Name of the group that should own jks file."
                     },
                     "mode": {
                        "type": "string",
                        "description": "Mode the file should be."
                     },
                     "force": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nKey store will be created even if it already exists."
                     }
                  },
                  "required": [
                     "name",
                     "certificate",
                     "private_key",
                     "password",
                     "dest"
                  ]
               },
               "java_cert": {
                  "type": "object",
                  "description": "This is a wrapper module around keytool, which can be used to import/remove certificates from a given java keystore.",
                  "properties": {
                     "cert_url": {
                        "type": "string",
                        "description": "Basic URL to fetch SSL certificate from.\nOne of C(cert_url) or C(cert_path) is required to load certificate."
                     },
                     "cert_port": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 443\n\nPort to connect to URL.\nThis will be used to create server URL:PORT."
                     },
                     "cert_path": {
                        "type": "string",
                        "description": "Local path to load certificate from.\nOne of C(cert_url) or C(cert_path) is required to load certificate."
                     },
                     "cert_alias": {
                        "type": "string",
                        "description": "Imported certificate alias.\nThe alias is used when checking for the presence of a certificate in the keystore."
                     },
                     "pkcs12_path": {
                        "type": "string",
                        "description": "Local path to load PKCS12 keystore from."
                     },
                     "pkcs12_password": {
                        "type": "string",
                        "description": "Password for importing from PKCS12 keystore."
                     },
                     "pkcs12_alias": {
                        "type": "string",
                        "description": "Alias in the PKCS12 keystore."
                     },
                     "keystore_path": {
                        "type": "string",
                        "description": "Path to keystore."
                     },
                     "keystore_pass": {
                        "type": "string",
                        "description": "Keystore password."
                     },
                     "keystore_create": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Create keystore if it does not exist."
                     },
                     "keystore_type": {
                        "type": "string",
                        "description": "Keystore type (JCEKS, JKS)."
                     },
                     "executable": {
                        "type": "string",
                        "description": "Default: keytool\n\nPath to keytool binary if not used we search in PATH for it."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDefines action which can be either certificate import or removal.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     }
                  },
                  "required": [
                     "keystore_pass"
                  ]
               },
               "iptables": {
                  "type": "object",
                  "description": "C(iptables) is used to set up, maintain, and inspect the tables of IP packet filter rules in the Linux kernel.\nThis module does not handle the saving and/or loading of rules, but rather only manipulates the current rules that are present in memory. This is the same as the behaviour of the C(iptables) and C(ip6tables) command which this module uses internally.",
                  "properties": {
                     "table": {
                        "type": "string",
                        "description": "Default: filter\n\nThis option specifies the packet matching table which the command should operate on.\nIf the kernel is configured with automatic module loading, an attempt will be made to load the appropriate module for that table if it is not already there.",
                        "enum": [
                           "filter",
                           "nat",
                           "mangle",
                           "raw",
                           "security"
                        ]
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the rule should be absent or present.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "action": {
                        "type": "string",
                        "description": "Default: append\n\nWhether the rule should be appended at the bottom or inserted at the top.\nIf the rule already exists the chain will not be modified.",
                        "enum": [
                           "append",
                           "insert"
                        ]
                     },
                     "rule_num": {
                        "type": "string",
                        "description": "Insert the rule as the given rule number.\nThis works only with C(action=insert)."
                     },
                     "ip_version": {
                        "type": "string",
                        "description": "Default: ipv4\n\nWhich version of the IP protocol this rule should apply to.",
                        "enum": [
                           "ipv4",
                           "ipv6"
                        ]
                     },
                     "chain": {
                        "type": "string",
                        "description": "Specify the iptables chain to modify.\nThis could be a user-defined chain or one of the standard iptables chains, like C(INPUT), C(FORWARD), C(OUTPUT), C(PREROUTING), C(POSTROUTING), C(SECMARK) or C(CONNSECMARK)."
                     },
                     "protocol": {
                        "type": "string",
                        "description": "The protocol of the rule or of the packet to check.\nThe specified protocol can be one of C(tcp), C(udp), C(udplite), C(icmp), C(esp), C(ah), C(sctp) or the special keyword C(all), or it can be a numeric value, representing one of these protocols or a different one.\nA protocol name from I(/etc/protocols) is also allowed.\nA C(!) argument before the protocol inverts the test.\nThe number zero is equivalent to all.\nC(all) will match with all protocols and is taken as default when this option is omitted."
                     },
                     "source": {
                        "type": "string",
                        "description": "Source specification.\nAddress can be either a network name, a hostname, a network IP address (with /mask), or a plain IP address.\nHostnames will be resolved once only, before the rule is submitted to the kernel. Please note that specifying any name to be resolved with a remote query such as DNS is a really bad idea.\nThe mask can be either a network mask or a plain number, specifying the number of 1's at the left side of the network mask. Thus, a mask of 24 is equivalent to 255.255.255.0. A C(!) argument before the address specification inverts the sense of the address."
                     },
                     "destination": {
                        "type": "string",
                        "description": "Destination specification.\nAddress can be either a network name, a hostname, a network IP address (with /mask), or a plain IP address.\nHostnames will be resolved once only, before the rule is submitted to the kernel. Please note that specifying any name to be resolved with a remote query such as DNS is a really bad idea.\nThe mask can be either a network mask or a plain number, specifying the number of 1's at the left side of the network mask. Thus, a mask of 24 is equivalent to 255.255.255.0. A C(!) argument before the address specification inverts the sense of the address."
                     },
                     "tcp_flags": {
                        "type": "object",
                        "description": "TCP flags specification.\nC(tcp_flags) expects a dict with the two keys C(flags) and C(flags_set)."
                     },
                     "match": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Specifies a match to use, that is, an extension module that tests for a specific property.\nThe set of matches make up the condition under which a target is invoked.\nMatches are evaluated first to last if specified as an array and work in short-circuit fashion, i.e. if one extension yields false, evaluation will stop."
                     },
                     "jump": {
                        "type": "string",
                        "description": "This specifies the target of the rule; i.e., what to do if the packet matches it.\nThe target can be a user-defined chain (other than the one this rule is in), one of the special builtin targets which decide the fate of the packet immediately, or an extension (see EXTENSIONS below).\nIf this option is omitted in a rule (and the goto parameter is not used), then matching the rule will have no effect on the packet's fate, but the counters on the rule will be incremented."
                     },
                     "gateway": {
                        "type": "string",
                        "description": "This specifies the IP address of host to send the cloned packets.\nThis option is only valid when C(jump) is set to C(TEE)."
                     },
                     "log_prefix": {
                        "type": "string",
                        "description": "Specifies a log text for the rule. Only make sense with a LOG jump."
                     },
                     "log_level": {
                        "type": "string",
                        "description": "Logging level according to the syslogd-defined priorities.\nThe value can be strings or numbers from 1-8.\nThis parameter is only applicable if C(jump) is set to C(LOG).",
                        "enum": [
                           "0",
                           "1",
                           "2",
                           "3",
                           "4",
                           "5",
                           "6",
                           "7",
                           "emerg",
                           "alert",
                           "crit",
                           "error",
                           "warning",
                           "notice",
                           "info",
                           "debug"
                        ]
                     },
                     "goto": {
                        "type": "string",
                        "description": "This specifies that the processing should continue in a user specified chain.\nUnlike the jump argument return will not continue processing in this chain but instead in the chain that called us via jump."
                     },
                     "in_interface": {
                        "type": "string",
                        "description": "Name of an interface via which a packet was received (only for packets entering the C(INPUT), C(FORWARD) and C(PREROUTING) chains).\nWhen the C(!) argument is used before the interface name, the sense is inverted.\nIf the interface name ends in a C(+), then any interface which begins with this name will match.\nIf this option is omitted, any interface name will match."
                     },
                     "out_interface": {
                        "type": "string",
                        "description": "Name of an interface via which a packet is going to be sent (for packets entering the C(FORWARD), C(OUTPUT) and C(POSTROUTING) chains).\nWhen the C(!) argument is used before the interface name, the sense is inverted.\nIf the interface name ends in a C(+), then any interface which begins with this name will match.\nIf this option is omitted, any interface name will match."
                     },
                     "fragment": {
                        "type": "string",
                        "description": "This means that the rule only refers to second and further fragments of fragmented packets.\nSince there is no way to tell the source or destination ports of such a packet (or ICMP type), such a packet will not match any rules which specify them.\nWhen the \"!\" argument precedes fragment argument, the rule will only match head fragments, or unfragmented packets."
                     },
                     "set_counters": {
                        "type": "string",
                        "description": "This enables the administrator to initialize the packet and byte counters of a rule (during C(INSERT), C(APPEND), C(REPLACE) operations)."
                     },
                     "source_port": {
                        "type": "string",
                        "description": "Source port or port range specification.\nThis can either be a service name or a port number.\nAn inclusive range can also be specified, using the format C(first:last).\nIf the first port is omitted, C(0) is assumed; if the last is omitted, C(65535) is assumed.\nIf the first port is greater than the second one they will be swapped."
                     },
                     "destination_port": {
                        "type": "string",
                        "description": "Destination port or port range specification. This can either be a service name or a port number. An inclusive range can also be specified, using the format first:last. If the first port is omitted, '0' is assumed; if the last is omitted, '65535' is assumed. If the first port is greater than the second one they will be swapped. This is only valid if the rule also specifies one of the following protocols: tcp, udp, dccp or sctp."
                     },
                     "to_ports": {
                        "type": "string",
                        "description": "This specifies a destination port or range of ports to use, without this, the destination port is never altered.\nThis is only valid if the rule also specifies one of the protocol C(tcp), C(udp), C(dccp) or C(sctp)."
                     },
                     "to_destination": {
                        "type": "string",
                        "description": "This specifies a destination address to use with C(DNAT).\nWithout this, the destination address is never altered."
                     },
                     "to_source": {
                        "type": "string",
                        "description": "This specifies a source address to use with C(SNAT).\nWithout this, the source address is never altered."
                     },
                     "syn": {
                        "type": "string",
                        "description": "Default: ignore\n\nThis allows matching packets that have the SYN bit set and the ACK and RST bits unset.\nWhen negated, this matches all packets with the RST or the ACK bits set.",
                        "enum": [
                           "ignore",
                           "match",
                           "negate"
                        ]
                     },
                     "set_dscp_mark": {
                        "type": "string",
                        "description": "This allows specifying a DSCP mark to be added to packets. It takes either an integer or hex value.\nMutually exclusive with C(set_dscp_mark_class)."
                     },
                     "set_dscp_mark_class": {
                        "type": "string",
                        "description": "This allows specifying a predefined DiffServ class which will be translated to the corresponding DSCP mark.\nMutually exclusive with C(set_dscp_mark)."
                     },
                     "comment": {
                        "type": "string",
                        "description": "This specifies a comment that will be added to the rule."
                     },
                     "ctstate": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "C(ctstate) is a list of the connection states to match in the conntrack module.\nPossible states are C(INVALID), C(NEW), C(ESTABLISHED), C(RELATED), C(UNTRACKED), C(SNAT), C(DNAT)"
                     },
                     "src_range": {
                        "type": "string",
                        "description": "Specifies the source IP range to match in the iprange module."
                     },
                     "dst_range": {
                        "type": "string",
                        "description": "Specifies the destination IP range to match in the iprange module."
                     },
                     "limit": {
                        "type": "string",
                        "description": "Specifies the maximum average number of matches to allow per second.\nThe number can specify units explicitly, using `/second', `/minute', `/hour' or `/day', or parts of them (so `5/second' is the same as `5/s')."
                     },
                     "limit_burst": {
                        "type": "string",
                        "description": "Specifies the maximum burst before the above limit kicks in."
                     },
                     "uid_owner": {
                        "type": "string",
                        "description": "Specifies the UID or username to use in match by owner rule.\nFrom Ansible 2.6 when the C(!) argument is prepended then the it inverts the rule to apply instead to all users except that one specified."
                     },
                     "gid_owner": {
                        "type": "string",
                        "description": "Specifies the GID or group to use in match by owner rule."
                     },
                     "reject_with": {
                        "type": "string",
                        "description": "Specifies the error packet type to return while rejecting. It implies \"jump: REJECT\""
                     },
                     "icmp_type": {
                        "type": "string",
                        "description": "This allows specification of the ICMP type, which can be a numeric ICMP type, type/code pair, or one of the ICMP type names shown by the command 'iptables -p icmp -h'"
                     },
                     "flush": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Flushes the specified table and chain of all rules.\nIf no chain is specified then the entire table is purged.\nIgnores all other parameters."
                     },
                     "policy": {
                        "type": "string",
                        "description": "Set the policy for the chain to the given target.\nOnly built-in chains can have policies.\nThis parameter requires the C(chain) parameter.\nIgnores all other parameters.",
                        "enum": [
                           "ACCEPT",
                           "DROP",
                           "QUEUE",
                           "RETURN"
                        ]
                     }
                  }
               },
               "interfaces_file": {
                  "type": "object",
                  "description": "Manage (add, remove, change) individual interface options in an interfaces-style file without having to manage the file as a whole with, say, M(template) or M(assemble). Interface has to be presented in a file.\nRead information about interfaces from interfaces-styled files",
                  "properties": {
                     "dest": {
                        "type": "string",
                        "description": "Default: /etc/network/interfaces\n\nPath to the interfaces file"
                     },
                     "iface": {
                        "type": "string",
                        "description": "Name of the interface, required for value changes or option remove"
                     },
                     "address_family": {
                        "type": "string",
                        "description": "Address family of the interface, useful if same interface name is used for both inet and inet6"
                     },
                     "option": {
                        "type": "string",
                        "description": "Name of the option, required for value changes or option remove"
                     },
                     "value": {
                        "type": "string",
                        "description": "If I(option) is not presented for the I(interface) and I(state) is C(present) option will be added. If I(option) already exists and is not C(pre-up), C(up), C(post-up) or C(down), it's value will be updated. C(pre-up), C(up), C(post-up) and C(down) options can't be updated, only adding new options, removing existing ones or cleaning the whole option set are supported"
                     },
                     "backup": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nCreate a backup file including the timestamp information so you can get the original file back if you somehow clobbered it incorrectly."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIf set to C(absent) the option or section will be removed if present instead of created.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     }
                  }
               },
               "hostname": {
                  "type": "object",
                  "description": "Set system's hostname, supports most OSs/Distributions, including those using systemd.\nNote, this module does *NOT* modify C(/etc/hosts). You need to modify it yourself using other modules like template or replace.\nWindows, HP-UX and AIX are not currently supported.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the host"
                     },
                     "use": {
                        "type": "string",
                        "description": "Which strategy to use to update the hostname.\nIf not set we try to autodetect, but this can be problematic, specially with containers as they can present misleading information.",
                        "enum": [
                           "generic",
                           "debian",
                           "sles",
                           "redhat",
                           "alpine",
                           "systemd",
                           "openrc",
                           "openbsd",
                           "solaris",
                           "freebsd"
                        ]
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "group": {
                  "type": "object",
                  "description": "Manage presence of groups on a host.\nFor Windows targets, use the M(win_group) module instead.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the group to manage."
                     },
                     "gid": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Optional I(GID) to set for the group."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the group should be present or not on the remote host.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "system": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "If I(yes), indicates that the group created is a system group."
                     },
                     "local": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Forces the use of \"local\" command alternatives on platforms that implement it.\nThis is useful in environments that use centralized authentication when you want to manipulate the local groups. (e.g. it uses C(lgroupadd) instead of C(groupadd)).\nThis requires that these commands exist on the targeted host, otherwise it will be a fatal error."
                     },
                     "non_unique": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "This option allows to change the group ID to a non-unique value. Requires C(gid).\nNot supported on macOS or BusyBox distributions."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "getent": {
                  "type": "object",
                  "description": "Runs getent against one of it's various databases and returns information into the host's facts, in a getent_<database> prefixed variable.",
                  "properties": {
                     "database": {
                        "type": "string",
                        "description": "The name of a getent database supported by the target system (passwd, group, hosts, etc)."
                     },
                     "key": {
                        "type": "string",
                        "description": "Key from which to return values from the specified database, otherwise the full contents are returned."
                     },
                     "service": {
                        "type": "string",
                        "description": "Override all databases with the specified service\nThe underlying system must support the service flag which is not always available."
                     },
                     "split": {
                        "type": "string",
                        "description": "Character used to split the database values into lists/arrays such as ':' or '\t', otherwise  it will try to pick one depending on the database."
                     },
                     "fail_key": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nIf a supplied key is missing this will make the task fail if C(yes)."
                     }
                  },
                  "required": [
                     "database"
                  ]
               },
               "gconftool2": {
                  "type": "object",
                  "description": "This module allows for the manipulation of GNOME 2 Configuration via gconftool-2.  Please see the gconftool-2(1) man pages for more details.",
                  "properties": {
                     "key": {
                        "type": "string",
                        "description": "A GConf preference key is an element in the GConf repository that corresponds to an application preference. See man gconftool-2(1)"
                     },
                     "value": {
                        "type": "string",
                        "description": "Preference keys typically have simple values such as strings, integers, or lists of strings and integers. This is ignored if the state is \"get\". See man gconftool-2(1)"
                     },
                     "value_type": {
                        "type": "string",
                        "description": "The type of value being set. This is ignored if the state is \"get\".",
                        "enum": [
                           "bool",
                           "float",
                           "int",
                           "string"
                        ]
                     },
                     "state": {
                        "type": "string",
                        "description": "The action to take upon the key/value.",
                        "enum": [
                           "absent",
                           "get",
                           "present"
                        ]
                     },
                     "config_source": {
                        "type": "string",
                        "description": "Specify a configuration source to use rather than the default path. See man gconftool-2(1)"
                     },
                     "direct": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nAccess the config database directly, bypassing server.  If direct is specified then the config_source must be specified as well. See man gconftool-2(1)"
                     }
                  },
                  "required": [
                     "key",
                     "state"
                  ]
               },
               "gather_facts": {
                  "type": "object",
                  "description": "This module takes care of executing the configured facts modules, the default is to use the M(setup) module.\nThis module is automatically called by playbooks to gather useful variables about remote hosts that can be used in playbooks.\nIt can also be executed directly by C(/usr/bin/ansible) to check what variables are available to a host.\nAnsible provides many I(facts) about the system, automatically.",
                  "properties": {
                     "parallel": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "A toggle that controls if the fact modules are executed in parallel or serially and in order. This can guarantee the merge order of module facts at the expense of performance.\nBy default it will be true if more than one fact module is used."
                     }
                  }
               },
               "firewalld": {
                  "type": "object",
                  "description": "This module allows for addition or deletion of services and ports (either TCP or UDP) in either running or permanent firewalld rules.",
                  "properties": {
                     "service": {
                        "type": "string",
                        "description": "Name of a service to add/remove to/from firewalld.\nThe service must be listed in output of firewall-cmd --get-services."
                     },
                     "port": {
                        "type": "string",
                        "description": "Name of a port or port range to add/remove to/from firewalld.\nMust be in the form PORT/PROTOCOL or PORT-PORT/PROTOCOL for port ranges."
                     },
                     "rich_rule": {
                        "type": "string",
                        "description": "Rich rule to add/remove to/from firewalld."
                     },
                     "source": {
                        "type": "string",
                        "description": "The source/network you would like to add/remove to/from firewalld."
                     },
                     "interface": {
                        "type": "string",
                        "description": "The interface you would like to add/remove to/from a zone in firewalld."
                     },
                     "icmp_block": {
                        "type": "string",
                        "description": "The ICMP block you would like to add/remove to/from a zone in firewalld."
                     },
                     "icmp_block_inversion": {
                        "type": "string",
                        "description": "Enable/Disable inversion of ICMP blocks for a zone in firewalld."
                     },
                     "zone": {
                        "type": "string",
                        "description": "The firewalld zone to add/remove to/from.\nNote that the default zone can be configured per system but C(public) is default from upstream.\nAvailable choices can be extended based on per-system configs, listed here are \"out of the box\" defaults.\nPossible values include C(block), C(dmz), C(drop), C(external), C(home), C(internal), C(public), C(trusted), C(work)."
                     },
                     "permanent": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Should this configuration be in the running firewalld configuration or persist across reboots.\nAs of Ansible 2.3, permanent operations can operate on firewalld configs when it is not running (requires firewalld >= 3.0.9).\nNote that if this is C(no), immediate is assumed C(yes)."
                     },
                     "immediate": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Should this configuration be applied immediately, if set as permanent."
                     },
                     "state": {
                        "type": "string",
                        "description": "Enable or disable a setting.\nFor ports: Should this port accept (enabled) or reject (disabled) connections.\nThe states C(present) and C(absent) can only be used in zone level operations (i.e. when no other parameters but zone and state are set).",
                        "enum": [
                           "absent",
                           "disabled",
                           "enabled",
                           "present"
                        ]
                     },
                     "timeout": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "The amount of time the rule should be in effect for when non-permanent."
                     },
                     "masquerade": {
                        "type": "string",
                        "description": "The masquerade setting you would like to enable/disable to/from zones within firewalld."
                     },
                     "offline": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether to run this module even when firewalld is offline."
                     }
                  },
                  "required": [
                     "state"
                  ]
               },
               "filesystem": {
                  "type": "object",
                  "description": "This module creates a filesystem.",
                  "properties": {
                     "fstype": {
                        "type": "string",
                        "description": "Filesystem type to be created.\nreiserfs support was added in 2.2.\nlvm support was added in 2.5.\nsince 2.5, I(dev) can be an image file.\nvfat support was added in 2.5\nocfs2 support was added in 2.6\nf2fs support was added in 2.7\nswap support was added in 2.8",
                        "enum": [
                           "btrfs",
                           "ext2",
                           "ext3",
                           "ext4",
                           "ext4dev",
                           "f2fs",
                           "lvm",
                           "ocfs2",
                           "reiserfs",
                           "xfs",
                           "vfat",
                           "swap"
                        ]
                     },
                     "type": {
                        "type": "string",
                        "description": "Filesystem type to be created.\nreiserfs support was added in 2.2.\nlvm support was added in 2.5.\nsince 2.5, I(dev) can be an image file.\nvfat support was added in 2.5\nocfs2 support was added in 2.6\nf2fs support was added in 2.7\nswap support was added in 2.8",
                        "enum": [
                           "btrfs",
                           "ext2",
                           "ext3",
                           "ext4",
                           "ext4dev",
                           "f2fs",
                           "lvm",
                           "ocfs2",
                           "reiserfs",
                           "xfs",
                           "vfat",
                           "swap"
                        ]
                     },
                     "dev": {
                        "type": "string",
                        "description": "Target path to device or image file."
                     },
                     "device": {
                        "type": "string",
                        "description": "Target path to device or image file."
                     },
                     "force": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nIf C(yes), allows to create new filesystem on devices that already has filesystem."
                     },
                     "resizefs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nIf C(yes), if the block device and filesystem size differ, grow the filesystem into the space.\nSupported for C(ext2), C(ext3), C(ext4), C(ext4dev), C(f2fs), C(lvm), C(xfs), C(vfat), C(swap) filesystems.\nXFS Will only grow if mounted.\nvFAT will likely fail if fatresize < 1.04."
                     },
                     "opts": {
                        "type": "array",
                        "description": "List of options to be passed to mkfs command."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "fstype",
                                    "type"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "fstype"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "type"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "dev",
                                    "device"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "dev"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "device"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "facter": {
                  "type": "object",
                  "description": "Runs the I(facter) discovery program (U(https://github.com/puppetlabs/facter)) on the remote system, returning JSON data that can be useful for inventory purposes.",
                  "properties": {}
               },
               "debconf": {
                  "type": "object",
                  "description": "Configure a .deb package using debconf-set-selections.\nOr just query existing selections.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of package to configure."
                     },
                     "pkg": {
                        "type": "string",
                        "description": "Name of package to configure."
                     },
                     "question": {
                        "type": "string",
                        "description": "A debconf configuration setting."
                     },
                     "selection": {
                        "type": "string",
                        "description": "A debconf configuration setting."
                     },
                     "setting": {
                        "type": "string",
                        "description": "A debconf configuration setting."
                     },
                     "vtype": {
                        "type": "string",
                        "description": "The type of the value supplied.\nC(seen) was added in Ansible 2.2.",
                        "enum": [
                           "boolean",
                           "error",
                           "multiselect",
                           "note",
                           "password",
                           "seen",
                           "select",
                           "string",
                           "text",
                           "title"
                        ]
                     },
                     "value": {
                        "type": "string",
                        "description": "Value to set the configuration to."
                     },
                     "answer": {
                        "type": "string",
                        "description": "Value to set the configuration to."
                     },
                     "unseen": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Do not set 'seen' flag when pre-seeding."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "pkg"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "pkg"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "question",
                                    "selection",
                                    "setting"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "value",
                                    "answer"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "dconf": {
                  "type": "object",
                  "description": "This module allows modifications and reading of dconf database. The module is implemented as a wrapper around dconf tool. Please see the dconf(1) man page for more details.\nSince C(dconf) requires a running D-Bus session to change values, the module will try to detect an existing session and reuse it, or run the tool via C(dbus-run-session).",
                  "properties": {
                     "key": {
                        "type": "string",
                        "description": "A dconf key to modify or read from the dconf database."
                     },
                     "value": {
                        "type": "string",
                        "description": "Value to set for the specified dconf key. Value should be specified in GVariant format. Due to complexity of this format, it is best to have a look at existing values in the dconf database. Required for C(state=present)."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nThe action to take upon the key/value.",
                        "enum": [
                           "read",
                           "present",
                           "absent"
                        ]
                     }
                  },
                  "required": [
                     "key"
                  ]
               },
               "crypttab": {
                  "type": "object",
                  "description": "Control Linux encrypted block devices that are set up during system boot in C(/etc/crypttab).",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the encrypted block device as it appears in the C(/etc/crypttab) file, or optionally prefixed with C(/dev/mapper/), as it appears in the filesystem. I(/dev/mapper/) will be stripped from I(name)."
                     },
                     "state": {
                        "type": "string",
                        "description": "Use I(present) to add a line to C(/etc/crypttab) or update its definition if already present.\nUse I(absent) to remove a line with matching I(name).\nUse I(opts_present) to add options to those already present; options with different values will be updated.\nUse I(opts_absent) to remove options from the existing set.",
                        "enum": [
                           "absent",
                           "opts_absent",
                           "opts_present",
                           "present"
                        ]
                     },
                     "backing_device": {
                        "type": "string",
                        "description": "Path to the underlying block device or file, or the UUID of a block-device prefixed with I(UUID=)."
                     },
                     "password": {
                        "type": "string",
                        "description": "Encryption password, the path to a file containing the password, or C(-) or unset if the password should be entered at boot."
                     },
                     "opts": {
                        "type": "string",
                        "description": "A comma-delimited list of options. See C(crypttab(5) ) for details."
                     },
                     "path": {
                        "type": "string",
                        "description": "Default: /etc/crypttab\n\nPath to file to use instead of C(/etc/crypttab).\nThis might be useful in a chroot environment."
                     }
                  },
                  "required": [
                     "name",
                     "state"
                  ]
               },
               "cronvar": {
                  "type": "object",
                  "description": "Use this module to manage crontab variables.\nThis module allows you to create, update, or delete cron variable definitions.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the crontab variable."
                     },
                     "value": {
                        "type": "string",
                        "description": "The value to set this variable to.\nRequired if C(state=present)."
                     },
                     "insertafter": {
                        "type": "string",
                        "description": "If specified, the variable will be inserted after the variable specified.\nUsed with C(state=present)."
                     },
                     "insertbefore": {
                        "type": "string",
                        "description": "Used with C(state=present). If specified, the variable will be inserted just before the variable specified."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether to ensure that the variable is present or absent.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "user": {
                        "type": "string",
                        "description": "The specific user whose crontab should be modified.\nThis parameter defaults to C(root) when unset."
                     },
                     "cron_file": {
                        "type": "string",
                        "description": "If specified, uses this file instead of an individual user's crontab.\nWithout a leading C(/), this is assumed to be in I(/etc/cron.d).\nWith a leading C(/), this is taken as absolute."
                     },
                     "backup": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "If set, create a backup of the crontab before it is modified. The location of the backup is returned in the C(backup) variable by this module."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "cron": {
                  "type": "object",
                  "description": "Use this module to manage crontab and environment variables entries. This module allows you to create environment variables and named crontab entries, update, or delete them.\nWhen crontab jobs are managed: the module includes one line with the description of the crontab entry C(\"#Ansible: <name>\") corresponding to the \"name\" passed to the module, which is used by future ansible/module calls to find/check the state. The \"name\" parameter should be unique, and changing the \"name\" value will result in a new cron task being created (or a different one being removed).\nWhen environment variables are managed, no comment line is added, but, when the module needs to find/check the state, it uses the \"name\" parameter to find the environment variable definition line.\nWhen using symbols such as %, they must be properly escaped.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Description of a crontab entry or, if env is set, the name of environment variable.\nRequired if C(state=absent).\nNote that if name is not set and C(state=present), then a new crontab entry will always be created, regardless of existing ones.\nThis parameter will always be required in future releases."
                     },
                     "user": {
                        "type": "string",
                        "description": "The specific user whose crontab should be modified.\nWhen unset, this parameter defaults to using C(root)."
                     },
                     "job": {
                        "type": "string",
                        "description": "The command to execute or, if env is set, the value of environment variable.\nThe command should not contain line breaks.\nRequired if C(state=present)."
                     },
                     "value": {
                        "type": "string",
                        "description": "The command to execute or, if env is set, the value of environment variable.\nThe command should not contain line breaks.\nRequired if C(state=present)."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether to ensure the job or environment variable is present or absent.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "cron_file": {
                        "type": "string",
                        "description": "If specified, uses this file instead of an individual user's crontab.\nIf this is a relative path, it is interpreted with respect to I(/etc/cron.d).\nIf it is absolute, it will typically be I(/etc/crontab).\nMany linux distros expect (and some require) the filename portion to consist solely of upper- and lower-case letters, digits, underscores, and hyphens.\nTo use the C(cron_file) parameter you must specify the C(user) as well."
                     },
                     "backup": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "If set, create a backup of the crontab before it is modified. The location of the backup is returned in the C(backup_file) variable by this module."
                     },
                     "minute": {
                        "type": "string",
                        "description": "Default: *\n\nMinute when the job should run ( 0-59, *, */2, etc )"
                     },
                     "hour": {
                        "type": "string",
                        "description": "Default: *\n\nHour when the job should run ( 0-23, *, */2, etc )"
                     },
                     "day": {
                        "type": "string",
                        "description": "Default: *\n\nDay of the month the job should run ( 1-31, *, */2, etc )"
                     },
                     "dom": {
                        "type": "string",
                        "description": "Default: *\n\nDay of the month the job should run ( 1-31, *, */2, etc )"
                     },
                     "month": {
                        "type": "string",
                        "description": "Default: *\n\nMonth of the year the job should run ( 1-12, *, */2, etc )"
                     },
                     "weekday": {
                        "type": "string",
                        "description": "Default: *\n\nDay of the week that the job should run ( 0-6 for Sunday-Saturday, *, etc )"
                     },
                     "dow": {
                        "type": "string",
                        "description": "Default: *\n\nDay of the week that the job should run ( 0-6 for Sunday-Saturday, *, etc )"
                     },
                     "reboot": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "If the job should be run at reboot. This option is deprecated. Users should use special_time."
                     },
                     "special_time": {
                        "type": "string",
                        "description": "Special time specification nickname.",
                        "enum": [
                           "annually",
                           "daily",
                           "hourly",
                           "monthly",
                           "reboot",
                           "weekly",
                           "yearly"
                        ]
                     },
                     "disabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "If the job should be disabled (commented out) in the crontab.\nOnly has effect if C(state=present)."
                     },
                     "env": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "If set, manages a crontab's environment variable.\nNew variables are added on top of crontab.\nC(name) and C(value) parameters are the name and the value of environment variable."
                     },
                     "insertafter": {
                        "type": "string",
                        "description": "Used with C(state=present) and C(env).\nIf specified, the environment variable will be inserted after the declaration of specified environment variable."
                     },
                     "insertbefore": {
                        "type": "string",
                        "description": "Used with C(state=present) and C(env).\nIf specified, the environment variable will be inserted before the declaration of specified environment variable."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "job",
                                    "value"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "day",
                                    "dom"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "weekday",
                                    "dow"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "capabilities": {
                  "type": "object",
                  "description": "This module manipulates files privileges using the Linux capabilities(7) system.",
                  "properties": {
                     "path": {
                        "type": "string",
                        "description": "Specifies the path to the file to be managed."
                     },
                     "key": {
                        "type": "string",
                        "description": "Specifies the path to the file to be managed."
                     },
                     "capability": {
                        "type": "string",
                        "description": "Desired capability to set (with operator and flags, if state is C(present)) or remove (if state is C(absent))"
                     },
                     "cap": {
                        "type": "string",
                        "description": "Desired capability to set (with operator and flags, if state is C(present)) or remove (if state is C(absent))"
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the entry should be present or absent in the file's capabilities.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "path",
                                    "key"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "path"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "key"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "capability",
                                    "cap"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "capability"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "cap"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "beadm": {
                  "type": "object",
                  "description": "Create, delete or activate ZFS boot environments.\nMount and unmount ZFS boot environments.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "ZFS boot environment name."
                     },
                     "be": {
                        "type": "string",
                        "description": "ZFS boot environment name."
                     },
                     "snapshot": {
                        "type": "string",
                        "description": "If specified, the new boot environment will be cloned from the given snapshot or inactive boot environment."
                     },
                     "description": {
                        "type": "string",
                        "description": "Associate a description with a new boot environment. This option is available only on Solarish platforms."
                     },
                     "options": {
                        "type": "string",
                        "description": "Create the datasets for new BE with specific ZFS properties.\nMultiple options can be specified.\nThis option is available only on Solarish platforms."
                     },
                     "mountpoint": {
                        "type": "string",
                        "description": "Path where to mount the ZFS boot environment."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nCreate or delete ZFS boot environment.",
                        "enum": [
                           "absent",
                           "activated",
                           "mounted",
                           "present",
                           "unmounted"
                        ]
                     },
                     "force": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Specifies if the unmount should be forced."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "be"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "be"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "awall": {
                  "type": "object",
                  "description": "This modules allows for enable/disable/activate of I(awall) policies.\nAlpine Wall (I(awall)) generates a firewall configuration from the enabled policy files and activates the configuration on the system.",
                  "properties": {
                     "name": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "One or more policy names."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: enabled\n\nWhether the policies should be enabled or disabled.",
                        "enum": [
                           "disabled",
                           "enabled"
                        ]
                     },
                     "activate": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Activate the new firewall rules.\nCan be run with other steps or on its own."
                     }
                  }
               },
               "authorized_key": {
                  "type": "object",
                  "description": "Adds or removes SSH authorized keys for particular user accounts.",
                  "properties": {
                     "user": {
                        "type": "string",
                        "description": "The username on the remote host whose authorized_keys file will be modified."
                     },
                     "key": {
                        "type": "string",
                        "description": "The SSH public key(s), as a string or (since Ansible 1.9) url (https://github.com/username.keys)."
                     },
                     "path": {
                        "type": "string",
                        "description": "Alternate path to the authorized_keys file.\nWhen unset, this value defaults to I(~/.ssh/authorized_keys)."
                     },
                     "manage_dir": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nWhether this module should manage the directory of the authorized key file.\nIf set to C(yes), the module will create the directory, as well as set the owner and permissions of an existing directory.\nBe sure to set C(manage_dir=no) if you are using an alternate directory for authorized_keys, as set with C(path), since you could lock yourself out of SSH access.\nSee the example below."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the given key (with the given key_options) should or should not be in the file.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "key_options": {
                        "type": "string",
                        "description": "A string of ssh key options to be prepended to the key in the authorized_keys file."
                     },
                     "exclusive": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether to remove all other non-specified keys from the authorized_keys file.\nMultiple keys can be specified in a single C(key) string value by separating them by newlines.\nThis option is not loop aware, so if you use C(with_) , it will be exclusive per iteration of the loop.\nIf you want multiple keys in the file you need to pass them all to C(key) in a single batch as mentioned above."
                     },
                     "validate_certs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nThis only applies if using a https url as the source of the keys.\nIf set to C(no), the SSL certificates will not be validated.\nThis should only set to C(no) used on personally controlled sites using self-signed certificates as it avoids verifying the source site.\nPrior to 2.1 the code worked as if this was set to C(yes)."
                     },
                     "comment": {
                        "type": "string",
                        "description": "Change the comment on the public key.\nRewriting the comment is useful in cases such as fetching it from GitHub or GitLab.\nIf no comment is specified, the existing comment will be kept."
                     },
                     "follow": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Follow path symlink instead of replacing it."
                     }
                  },
                  "required": [
                     "user",
                     "key"
                  ]
               },
               "at": {
                  "type": "object",
                  "description": "Use this module to schedule a command or script file to run once in the future.\nAll jobs are executed in the 'a' queue.",
                  "properties": {
                     "command": {
                        "type": "string",
                        "description": "A command to be executed in the future."
                     },
                     "script_file": {
                        "type": "string",
                        "description": "An existing script file to be executed in the future."
                     },
                     "count": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "The count of units in the future to execute the command or script file."
                     },
                     "units": {
                        "type": "string",
                        "description": "The type of units in the future to execute the command or script file.",
                        "enum": [
                           "minutes",
                           "hours",
                           "days",
                           "weeks"
                        ]
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nThe state dictates if the command or script file should be evaluated as present(added) or absent(deleted).",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "unique": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "If a matching job is present a new job will not be added."
                     }
                  },
                  "required": [
                     "count",
                     "units"
                  ]
               },
               "alternatives": {
                  "type": "object",
                  "description": "Manages symbolic links using the 'update-alternatives' tool.\nUseful when multiple programs are installed but provide similar functionality (e.g. different editors).",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The generic name of the link."
                     },
                     "path": {
                        "type": "string",
                        "description": "The path to the real executable that the link should point to."
                     },
                     "link": {
                        "type": "string",
                        "description": "The path to the symbolic link that should point to the real executable.\nThis option is always required on RHEL-based distributions. On Debian-based distributions this option is required when the alternative I(name) is unknown to the system."
                     },
                     "priority": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 50\n\nThe priority of the alternative."
                     }
                  },
                  "required": [
                     "name",
                     "path"
                  ]
               },
               "aix_lvol": {
                  "type": "object",
                  "description": "This module creates, removes or resizes AIX logical volumes. Inspired by lvol module.",
                  "properties": {
                     "vg": {
                        "type": "string",
                        "description": "The volume group this logical volume is part of."
                     },
                     "lv": {
                        "type": "string",
                        "description": "The name of the logical volume."
                     },
                     "lv_type": {
                        "type": "string",
                        "description": "Default: jfs2\n\nThe type of the logical volume."
                     },
                     "size": {
                        "type": "string",
                        "description": "The size of the logical volume with one of the [MGT] units."
                     },
                     "copies": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 1\n\nThe number of copies of the logical volume.\nMaximum copies are 3."
                     },
                     "policy": {
                        "type": "string",
                        "description": "Default: maximum\n\nSets the interphysical volume allocation policy.\nC(maximum) allocates logical partitions across the maximum number of physical volumes.\nC(minimum) allocates logical partitions across the minimum number of physical volumes.",
                        "enum": [
                           "maximum",
                           "minimum"
                        ]
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nControl if the logical volume exists. If C(present) and the volume does not already exist then the C(size) option is required.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "opts": {
                        "type": "string",
                        "description": "Free-form options to be passed to the mklv command."
                     },
                     "pvs": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "A list of physical volumes e.g. C(hdisk1,hdisk2)."
                     }
                  },
                  "required": [
                     "vg",
                     "lv"
                  ]
               },
               "aix_lvg": {
                  "type": "object",
                  "description": "This module creates, removes or resize volume groups on AIX LVM.",
                  "properties": {
                     "force": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Force volume group creation."
                     },
                     "pp_size": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "The size of the physical partition in megabytes."
                     },
                     "pvs": {
                        "type": "array",
                        "description": "List of comma-separated devices to use as physical devices in this volume group.\nRequired when creating or extending (C(present) state) the volume group.\nIf not informed reducing (C(absent) state) the volume group will be removed."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nControl if the volume group exists and volume group AIX state varyonvg C(varyon) or varyoffvg C(varyoff).",
                        "enum": [
                           "absent",
                           "present",
                           "varyoff",
                           "varyon"
                        ]
                     },
                     "vg": {
                        "type": "string",
                        "description": "The name of the volume group."
                     },
                     "vg_type": {
                        "type": "string",
                        "description": "Default: normal\n\nThe type of the volume group.",
                        "enum": [
                           "big",
                           "normal",
                           "scalable"
                        ]
                     }
                  },
                  "required": [
                     "vg"
                  ]
               },
               "aix_inittab": {
                  "type": "object",
                  "description": "Manages the inittab on AIX.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the inittab entry."
                     },
                     "service": {
                        "type": "string",
                        "description": "Name of the inittab entry."
                     },
                     "runlevel": {
                        "type": "string",
                        "description": "Runlevel of the entry."
                     },
                     "action": {
                        "type": "string",
                        "description": "Action what the init has to do with this entry.",
                        "enum": [
                           "boot",
                           "bootwait",
                           "hold",
                           "initdefault",
                           "off",
                           "once",
                           "ondemand",
                           "powerfail",
                           "powerwait",
                           "respawn",
                           "sysinit",
                           "wait"
                        ]
                     },
                     "command": {
                        "type": "string",
                        "description": "What command has to run."
                     },
                     "insertafter": {
                        "type": "string",
                        "description": "After which inittabline should the new entry inserted."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the entry should be present or absent in the inittab file.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "service"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "service"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "aix_filesystem": {
                  "type": "object",
                  "description": "This module creates, removes, mount and unmount LVM and NFS file system for AIX using C(/etc/filesystems).\nFor LVM file systems is possible to resize a file system.",
                  "properties": {
                     "account_subsystem": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Specifies whether the file system is to be processed by the accounting subsystem."
                     },
                     "attributes": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Default: agblksize='4096',isnapshot='no'\n\nSpecifies attributes for files system separated by comma."
                     },
                     "auto_mount": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nFile system is automatically mounted at system restart."
                     },
                     "device": {
                        "type": "string",
                        "description": "Logical volume (LV) device name or remote export device to create a NFS file system.\nIt is used to create a file system on an already existing logical volume or the exported NFS file system.\nIf not mentioned a new logical volume name will be created following AIX standards (LVM)."
                     },
                     "fs_type": {
                        "type": "string",
                        "description": "Default: jfs2\n\nSpecifies the virtual file system type."
                     },
                     "permissions": {
                        "type": "string",
                        "description": "Default: rw\n\nSet file system permissions. C(rw) (read-write) or C(ro) (read-only).",
                        "enum": [
                           "ro",
                           "rw"
                        ]
                     },
                     "mount_group": {
                        "type": "string",
                        "description": "Specifies the mount group."
                     },
                     "filesystem": {
                        "type": "string",
                        "description": "Specifies the mount point, which is the directory where the file system will be mounted."
                     },
                     "nfs_server": {
                        "type": "string",
                        "description": "Specifies a Network File System (NFS) server."
                     },
                     "rm_mount_point": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Removes the mount point directory when used with state C(absent)."
                     },
                     "size": {
                        "type": "string",
                        "description": "Specifies the file system size.\nFor already C(present) it will be resized.\n512-byte blocks, Megabytes or Gigabytes. If the value has M specified it will be in Megabytes. If the value has G specified it will be in Gigabytes.\nIf no M or G the value will be 512-byte blocks.\nIf \"+\" is specified in begin of value, the value will be added.\nIf \"-\" is specified in begin of value, the value will be removed.\nIf \"+\" or \"-\" is not specified, the total value will be the specified.\nSize will respects the LVM AIX standards."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nControls the file system state.\nC(present) check if file system exists, creates or resize.\nC(absent) removes existing file system if already C(unmounted).\nC(mounted) checks if the file system is mounted or mount the file system.\nC(unmounted) check if the file system is unmounted or unmount the file system.",
                        "enum": [
                           "absent",
                           "mounted",
                           "present",
                           "unmounted"
                        ]
                     },
                     "vg": {
                        "type": "string",
                        "description": "Specifies an existing volume group (VG)."
                     }
                  },
                  "required": [
                     "filesystem",
                     "state"
                  ]
               },
               "aix_devices": {
                  "type": "object",
                  "description": "This module discovers, defines, removes and modifies attributes of AIX devices.",
                  "properties": {
                     "attributes": {
                        "type": "object",
                        "description": "A list of device attributes."
                     },
                     "device": {
                        "type": "string",
                        "description": "The name of the device.\nC(all) is valid to rescan C(available) all devices (AIX cfgmgr command)."
                     },
                     "force": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Forces action."
                     },
                     "recursive": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Removes or defines a device and children devices."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: available\n\nControls the device state.\nC(available) (alias C(present)) rescan a specific device or all devices (when C(device) is not specified).\nC(removed) (alias C(absent) removes a device.\nC(defined) changes device to Defined state.",
                        "enum": [
                           "available",
                           "defined",
                           "removed"
                        ]
                     }
                  },
                  "required": [
                     "device"
                  ]
               },
               "zpool_facts": {
                  "type": "object",
                  "description": "Gather facts from ZFS pool properties.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "ZFS pool name."
                     },
                     "pool": {
                        "type": "string",
                        "description": "ZFS pool name."
                     },
                     "zpool": {
                        "type": "string",
                        "description": "ZFS pool name."
                     },
                     "parsable": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Specifies if property values should be displayed in machine friendly format."
                     },
                     "properties": {
                        "type": "string",
                        "description": "Default: all\n\nSpecifies which dataset properties should be queried in comma-separated format. For more information about dataset properties, check zpool(1M) man page."
                     },
                     "props": {
                        "type": "string",
                        "description": "Default: all\n\nSpecifies which dataset properties should be queried in comma-separated format. For more information about dataset properties, check zpool(1M) man page."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "pool",
                                    "zpool"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "properties",
                                    "props"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "zfs_facts": {
                  "type": "object",
                  "description": "Gather facts from ZFS dataset properties.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "ZFS dataset name."
                     },
                     "ds": {
                        "type": "string",
                        "description": "ZFS dataset name."
                     },
                     "dataset": {
                        "type": "string",
                        "description": "ZFS dataset name."
                     },
                     "recurse": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nSpecifies if properties for any children should be recursively displayed."
                     },
                     "parsable": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nSpecifies if property values should be displayed in machine friendly format."
                     },
                     "properties": {
                        "type": "string",
                        "description": "Default: all\n\nSpecifies which dataset properties should be queried in comma-separated format. For more information about dataset properties, check zfs(1M) man page."
                     },
                     "props": {
                        "type": "string",
                        "description": "Default: all\n\nSpecifies which dataset properties should be queried in comma-separated format. For more information about dataset properties, check zfs(1M) man page."
                     },
                     "type": {
                        "type": "string",
                        "description": "Default: all\n\nSpecifies which datasets types to display. Multiple values have to be provided in comma-separated form.",
                        "enum": [
                           "all",
                           "filesystem",
                           "volume",
                           "snapshot",
                           "bookmark"
                        ]
                     },
                     "depth": {
                        "type": "string",
                        "description": "Specifies recursion depth."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "ds",
                                    "dataset"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "ds"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "dataset"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "properties",
                                    "props"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "zfs_delegate_admin": {
                  "type": "object",
                  "description": "Manages ZFS file system delegated administration permissions, which allow unprivileged users to perform ZFS operations normally restricted to the superuser.\nSee the C(zfs allow) section of C(zfs(1M)) for detailed explanations of options.\nThis module attempts to adhere to the behavior of the command line tool as much as possible.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "File system or volume name e.g. C(rpool/myfs)."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether to allow (C(present)), or unallow (C(absent)) a permission.\nWhen set to C(present), at least one \"entity\" param of I(users), I(groups), or I(everyone) are required.\nWhen set to C(absent), removes permissions from the specified entities, or removes all permissions if no entity params are specified.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "users": {
                        "type": "array",
                        "description": "List of users to whom permission(s) should be granted."
                     },
                     "groups": {
                        "type": "array",
                        "description": "List of groups to whom permission(s) should be granted."
                     },
                     "everyone": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Apply permissions to everyone."
                     },
                     "permissions": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "The list of permission(s) to delegate (required if C(state) is C(present))."
                     },
                     "local": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Apply permissions to C(name) locally (C(zfs allow -l))."
                     },
                     "descendents": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Apply permissions to C(name)'s descendents (C(zfs allow -d))."
                     },
                     "recursive": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Unallow permissions recursively (ignored when C(state) is C(present))."
                     }
                  },
                  "required": [
                     "name",
                     "state"
                  ]
               },
               "zfs": {
                  "type": "object",
                  "description": "Manages ZFS file systems, volumes, clones and snapshots",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "File system, snapshot or volume name e.g. C(rpool/myfs)."
                     },
                     "state": {
                        "type": "string",
                        "description": "Whether to create (C(present)), or remove (C(absent)) a file system, snapshot or volume. All parents/children will be created/destroyed as needed to reach the desired state.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "origin": {
                        "type": "string",
                        "description": "Snapshot from which to create a clone."
                     },
                     "extra_zfs_properties": {
                        "type": "object",
                        "description": "A dictionary of zfs properties to be set.\nSee the zfs(8) man page for more information."
                     }
                  },
                  "required": [
                     "name",
                     "state"
                  ]
               },
               "vexata_volume": {
                  "type": "object",
                  "description": "Create, deletes or extend volumes on a Vexata VX100 array.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Volume name."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nCreates/Modifies volume when present or removes when absent.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "size": {
                        "type": "string",
                        "description": "Volume size in M, G, T units. M=2^20, G=2^30, T=2^40 bytes."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "vexata_eg": {
                  "type": "object",
                  "description": "Create or delete export groups on a Vexata VX100 array.\nAn export group is a tuple of a volume group, initiator group and port group that allows a set of volumes to be exposed to one or more hosts through specific array ports.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Export group name."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nCreates export group when present or delete when absent.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "vg": {
                        "type": "string",
                        "description": "Volume group name."
                     },
                     "ig": {
                        "type": "string",
                        "description": "Initiator group name."
                     },
                     "pg": {
                        "type": "string",
                        "description": "Port group name."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "purefb_subnet": {
                  "type": "object",
                  "description": "This module manages network subnets on Pure Storage FlashBlade.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Subnet Name."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nCreate, delete or modifies a subnet.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "gateway": {
                        "type": "string",
                        "description": "IPv4 or IPv6 address of subnet gateway."
                     },
                     "mtu": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 1500\n\nMTU size of the subnet. Range is 1280 to 9216."
                     },
                     "prefix": {
                        "type": "string",
                        "description": "IPv4 or IPv6 address associated with the subnet.\nSupply the prefix length (CIDR) as well as the IP address."
                     },
                     "vlan": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "VLAN ID of the subnet."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "purefb_snap": {
                  "type": "object",
                  "description": "Create or delete volumes and filesystem snapshots on Pure Storage FlashBlades.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name of the source filesystem."
                     },
                     "suffix": {
                        "type": "string",
                        "description": "Suffix of snapshot name."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDefine whether the filesystem snapshot should exist or not.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "eradicate": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nDefine whether to eradicate the snapshot on delete or leave in trash."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "purefb_smtp": {
                  "type": "object",
                  "description": "Configure SMTP for a Pure Storage FlashBlade.\nWhilst there can be no relay host, a sender domain must be configured.",
                  "properties": {
                     "host": {
                        "type": "string",
                        "description": "Relay server name"
                     },
                     "domain": {
                        "type": "string",
                        "description": "Domain name for alert messages"
                     }
                  },
                  "required": [
                     "domain"
                  ]
               },
               "purefb_s3user": {
                  "type": "object",
                  "description": "Create or delete object store account users on a Pure Storage FlashBlade.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nCreate or delete object store account user",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of object store user"
                     },
                     "account": {
                        "type": "string",
                        "description": "The name of object store account associated with user"
                     },
                     "access_key": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nCreate secret access key.\nKey can be exposed using the I(debug) module"
                     }
                  }
               },
               "purefb_s3acc": {
                  "type": "object",
                  "description": "Create or delete object store accounts on a Pure Storage FlashBlade.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nCreate or delete object store account",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of object store account"
                     }
                  }
               },
               "purefb_ra": {
                  "type": "object",
                  "description": "Enable or Disable Remote Assist for a Pure Storage FlashBlade.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDefine state of remote assist\nWhen set to I(enable) the RA port can be exposed using the I(debug) module.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     }
                  }
               },
               "purefb_network": {
                  "type": "object",
                  "description": "This module manages network interfaces on Pure Storage FlashBlade.\nWhen creating a network interface a subnet must already exist with a network prefix that covers the IP address of the interface being created.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Interface Name."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nCreate, delete or modifies a network interface.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "address": {
                        "type": "string",
                        "description": "IP address of interface."
                     },
                     "services": {
                        "type": "string",
                        "description": "Default: data\n\nDefine which services are configured for the interfaces.",
                        "enum": [
                           "data"
                        ]
                     },
                     "itype": {
                        "type": "string",
                        "description": "Default: vip\n\nType of interface.",
                        "enum": [
                           "vip"
                        ]
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "purefb_info": {
                  "type": "object",
                  "description": "Collect information from a Pure Storage FlashBlade running the Purity//FB operating system. By default, the module will collect basic information including hosts, host groups, protection groups and volume counts. Additional information can be collected based on the configured set of arguments.",
                  "properties": {
                     "gather_subset": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Default: minimum\n\nWhen supplied, this argument will define the information to be collected. Possible values for this include all, minimum, config, performance, capacity, network, subnets, lags, filesystems and snapshots."
                     }
                  }
               },
               "purefb_fs": {
                  "type": "object",
                  "description": "This module manages filesystems on Pure Storage FlashBlade.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Filesystem Name."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nCreate, delete or modifies a filesystem.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "eradicate": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Define whether to eradicate the filesystem on delete or leave in trash."
                     },
                     "size": {
                        "type": "string",
                        "description": "Default: 32G\n\nVolume size in M, G, T or P units. See examples."
                     },
                     "nfsv3": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nDefine whether to NFSv3 protocol is enabled for the filesystem."
                     },
                     "nfsv4": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nDefine whether to NFSv4.1 protocol is enabled for the filesystem."
                     },
                     "nfs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\n(Deprecate) Define whether to NFSv3 protocol is enabled for the filesystem.\nThis option will be deprecated in 2.10, use I(nfsv3) instead."
                     },
                     "nfs_rules": {
                        "type": "string",
                        "description": "Default: *(rw,no_root_squash)\n\nDefine the NFS rules in operation."
                     },
                     "smb": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Define whether to SMB protocol is enabled for the filesystem."
                     },
                     "http": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Define whether to HTTP/HTTPS protocol is enabled for the filesystem."
                     },
                     "snapshot": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Define whether a snapshot directory is enabled for the filesystem."
                     },
                     "fastremove": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Define whether the fast remove directory is enabled for the filesystem."
                     },
                     "hard_limit": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Define whether the capacity for a filesystem is a hard limit.\nCAUTION This will cause the filesystem to go Read-Only if the capacity has already exceeded the logical size of the filesystem."
                     },
                     "user_quota": {
                        "type": "string",
                        "description": "Default quota in M, G, T or P units for a user under this file system."
                     },
                     "group_quota": {
                        "type": "string",
                        "description": "Default quota in M, G, T or P units for a group under this file system."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "purefb_dsrole": {
                  "type": "object",
                  "description": "Set or erase directory services role configurations.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nCreate or delete directory service role",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "role": {
                        "type": "string",
                        "description": "The directory service role to work on",
                        "enum": [
                           "array_admin",
                           "ops_admin",
                           "readonly",
                           "storage_admin"
                        ]
                     },
                     "group_base": {
                        "type": "string",
                        "description": "Specifies where the configured group is located in the directory tree. This field consists of Organizational Units (OUs) that combine with the base DN attribute and the configured group CNs to complete the full Distinguished Name of the groups. The group base should specify OU= for each OU and multiple OUs should be separated by commas. The order of OUs is important and should get larger in scope from left to right.\nEach OU should not exceed 64 characters in length."
                     },
                     "group": {
                        "type": "string",
                        "description": "Sets the common Name (CN) of the configured directory service group containing users for the FlashBlade. This name should be just the Common Name of the group without the CN= specifier.\nCommon Names should not exceed 64 characters in length."
                     }
                  }
               },
               "purefb_ds": {
                  "type": "object",
                  "description": "Create or erase directory services configurations. There is no facility to SSL certificates at this time. Use the FlashBlade GUI for this additional configuration work.\nTo modify an existing directory service configuration you must first delete an existing configuration and then recreate with new settings.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nCreate or delete directory service configuration",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "dstype": {
                        "type": "string",
                        "description": "The type of directory service to work on",
                        "enum": [
                           "management",
                           "nfs",
                           "smb"
                        ]
                     },
                     "enable": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether to enable or disable directory service support."
                     },
                     "uri": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "A list of up to 30 URIs of the directory servers. Each URI must include the scheme ldap:// or ldaps:// (for LDAP over SSL), a hostname, and a domain name or IP address. For example, ldap://ad.company.com configures the directory service with the hostname \"ad\" in the domain \"company.com\" while specifying the unencrypted LDAP protocol."
                     },
                     "base_dn": {
                        "type": "string",
                        "description": "Sets the base of the Distinguished Name (DN) of the directory service groups. The base should consist of only Domain Components (DCs). The base_dn will populate with a default value when a URI is entered by parsing domain components from the URI. The base DN should specify DC= for each domain component and multiple DCs should be separated by commas."
                     },
                     "bind_password": {
                        "type": "string",
                        "description": "Sets the password of the bind_user user name account."
                     },
                     "bind_user": {
                        "type": "string",
                        "description": "Sets the user name that can be used to bind to and query the directory.\nFor Active Directory, enter the username - often referred to as sAMAccountName or User Logon Name - of the account that is used to perform directory lookups.\nFor OpenLDAP, enter the full DN of the user."
                     },
                     "nis_servers": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "A list of up to 30 IP addresses or FQDNs for NIS servers.\nThis cannot be used in conjunction with LDAP configurations."
                     },
                     "nis_domain": {
                        "type": "string",
                        "description": "The NIS domain to search\nThis cannot be used in conjunction with LDAP configurations."
                     },
                     "join_ou": {
                        "type": "string",
                        "description": "The optional organizational unit (OU) where the machine account for the directory service will be created."
                     }
                  },
                  "required": [
                     "base_dn"
                  ]
               },
               "purefb_bucket": {
                  "type": "object",
                  "description": "This module managess object store (s3) buckets on Pure Storage FlashBlade.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Bucket Name."
                     },
                     "account": {
                        "type": "string",
                        "description": "Object Store Account for Bucket."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nCreate, delete or modifies a bucket.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "eradicate": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Define whether to eradicate the bucket on delete or leave in trash."
                     }
                  },
                  "required": [
                     "name",
                     "account"
                  ]
               },
               "purefa_volume": {
                  "type": "object",
                  "description": "Create, delete or extend the capacity of a volume on Pure Storage FlashArray.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name of the volume."
                     },
                     "target": {
                        "type": "string",
                        "description": "The name of the target volume, if copying."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDefine whether the volume should exist or not.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "eradicate": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nDefine whether to eradicate the volume on delete or leave in trash."
                     },
                     "overwrite": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nDefine whether to overwrite a target volume if it already exists."
                     },
                     "size": {
                        "type": "string",
                        "description": "Volume size in M, G, T or P units."
                     },
                     "qos": {
                        "type": "string",
                        "description": "Bandwidth limit for volume in M or G units. M will set MB/s G will set GB/s To clear an existing Qos setting using 0 (zero)"
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "purefa_vg": {
                  "type": "object",
                  "description": "Create, delete or modify volume groups on Pure Storage FlashArrays.",
                  "properties": {
                     "vgroup": {
                        "type": "string",
                        "description": "The name of the volume group."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDefine whether the volume group should exist or not.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "eradicate": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nDefine whether to eradicate the volume group on delete and leave in trash."
                     }
                  },
                  "required": [
                     "vgroup"
                  ]
               },
               "purefa_user": {
                  "type": "object",
                  "description": "Create, modify or delete local users on a Pure Storage FlashArray.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nCreate, delete or update local user account",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the local user account"
                     },
                     "role": {
                        "type": "string",
                        "description": "Sets the local user's access level to the array",
                        "enum": [
                           "readonly",
                           "storage_admin",
                           "array_admin"
                        ]
                     },
                     "password": {
                        "type": "string",
                        "description": "Password for the local user."
                     },
                     "old_password": {
                        "type": "string",
                        "description": "If changing an existing password, you must provide the old password for security"
                     },
                     "api": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Define whether to create an API token for this user\nToken can be exposed using the I(debug) module"
                     }
                  }
               },
               "purefa_syslog": {
                  "type": "object",
                  "description": "Configure syslog configuration for Pure Storage FlashArrays.\nAdd or delete an individual syslog server to the existing list of serves.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nCreate or delete syslog servers configuration",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "protocol": {
                        "type": "string",
                        "description": "Protocol which server uses",
                        "enum": [
                           "tcp",
                           "tls",
                           "udp"
                        ]
                     },
                     "port": {
                        "type": "string",
                        "description": "Port at which the server is listening. If no port is specified the system will use 514"
                     },
                     "address": {
                        "type": "string",
                        "description": "Syslog server address. This field supports IPv4, IPv6 or FQDN. An invalid IP addresses will cause the module to fail. No validation is performed for FQDNs."
                     }
                  },
                  "required": [
                     "protocol",
                     "address"
                  ]
               },
               "purefa_snmp": {
                  "type": "object",
                  "description": "Manage SNMP managers on a Pure Storage FlashArray.\nChanging of a named SNMP managers version is not supported.\nThis module is not idempotent and will always modify an existing SNMP manager due to hidden parameters that cannot be compared to the play parameters.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of SNMP Manager"
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nCreate or delete SNMP manager",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "auth_passphrase": {
                        "type": "string",
                        "description": "SNMPv3 only. Passphrase of 8 - 32 characters."
                     },
                     "auth_protocol": {
                        "type": "string",
                        "description": "SNMP v3 only. Hash algorithm to use",
                        "enum": [
                           "MD5",
                           "SHA"
                        ]
                     },
                     "community": {
                        "type": "string",
                        "description": "SNMP v2c only. Manager community ID. Between 1 and 32 characters long."
                     },
                     "host": {
                        "type": "string",
                        "description": "IPv4 or IPv6 address or FQDN to send trap messages to."
                     },
                     "user": {
                        "type": "string",
                        "description": "SNMP v3 only. User ID recognized by the specified SNMP manager. Must be between 1 and 32 characters."
                     },
                     "version": {
                        "type": "string",
                        "description": "Default: v2c\n\nVersion of SNMP protocol to use for the manager.",
                        "enum": [
                           "v2c",
                           "v3"
                        ]
                     },
                     "notification": {
                        "type": "string",
                        "description": "Default: trap\n\nAction to perform on event.",
                        "enum": [
                           "inform",
                           "trap"
                        ]
                     },
                     "privacy_passphrase": {
                        "type": "string",
                        "description": "SNMPv3 only. Passphrase to encrypt SNMP messages. Must be between 8 and 63 non-space ASCII characters."
                     },
                     "privacy_protocol": {
                        "type": "string",
                        "description": "SNMP v3 only. Encryption protocol to use",
                        "enum": [
                           "AES",
                           "DES"
                        ]
                     }
                  },
                  "required": [
                     "name",
                     "host"
                  ]
               },
               "purefa_snap": {
                  "type": "object",
                  "description": "Create or delete volumes and volume snapshots on Pure Storage FlashArray.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name of the source volume."
                     },
                     "suffix": {
                        "type": "string",
                        "description": "Suffix of snapshot name."
                     },
                     "target": {
                        "type": "string",
                        "description": "Name of target volume if creating from snapshot."
                     },
                     "overwrite": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nDefine whether to overwrite existing volume when creating from snapshot."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDefine whether the volume snapshot should exist or not.",
                        "enum": [
                           "absent",
                           "copy",
                           "present"
                        ]
                     },
                     "eradicate": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nDefine whether to eradicate the snapshot on delete or leave in trash."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "purefa_smtp": {
                  "type": "object",
                  "description": "Set or erase configuration for the SMTP settings.\nIf username/password are set this will always force a change as there is no way to see if the password is different from the current SMTP configuration.\nPure Storage Ansible Team (@sdodsley) <pure-ansible-team@purestorage.com>",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nSet or delete SMTP configuration",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "password": {
                        "type": "string",
                        "description": "The SMTP password."
                     },
                     "user": {
                        "type": "string",
                        "description": "The SMTP username."
                     },
                     "relay_host": {
                        "type": "string",
                        "description": "IPv4 or IPv6 address or FQDN. A port number may be appended."
                     },
                     "sender_domain": {
                        "type": "string",
                        "description": "Domain name."
                     }
                  }
               },
               "purefa_ra": {
                  "type": "object",
                  "description": "Enable or Disable Remote Assist for a Pure Storage FlashArray.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: enable\n\nDefine state of remote assist\nWhen set to I(enable) the RA port can be exposed using the I(debug) module.",
                        "enum": [
                           "enable",
                           "disable"
                        ]
                     }
                  }
               },
               "purefa_phonehome": {
                  "type": "object",
                  "description": "Enable or Disable Phonehome for a Pure Storage FlashArray.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDefine state of phonehome",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     }
                  }
               },
               "purefa_pgsnap": {
                  "type": "object",
                  "description": "Create or delete protection group snapshots on Pure Storage FlashArray.\nRecovery of replicated snapshots on the replica target array is enabled.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name of the source protection group."
                     },
                     "suffix": {
                        "type": "string",
                        "description": "Suffix of snapshot name."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDefine whether the protection group snapshot should exist or not. Copy (added in 2.7) will create a full read/write clone of the snapshot.",
                        "enum": [
                           "absent",
                           "present",
                           "copy"
                        ]
                     },
                     "eradicate": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nDefine whether to eradicate the snapshot on delete or leave in trash."
                     },
                     "restore": {
                        "type": "string",
                        "description": "Restore a specific volume from a protection group snapshot."
                     },
                     "overwrite": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nDefine whether to overwrite the target volume if it already exists."
                     },
                     "target": {
                        "type": "string",
                        "description": "Volume to restore a specified volume to.\nIf not supplied this will default to the volume defined in I(restore)"
                     },
                     "now": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether to initiate a snapshot of the protection group immediately"
                     },
                     "apply_retention": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Apply retention schedule settings to the snapshot"
                     },
                     "remote": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Force immeadiate snapshot to remote targets"
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "purefa_pg": {
                  "type": "object",
                  "description": "Create, delete or modify protection groups on Pure Storage FlashArrays.\nIf a protection group exists and you try to add non-valid types, eg. a host to a volume protection group the module will ignore the invalid types.\nProtection Groups on Offload targets are supported.",
                  "properties": {
                     "pgroup": {
                        "type": "string",
                        "description": "The name of the protection group."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDefine whether the protection group should exist or not.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "volume": {
                        "type": "array",
                        "description": "List of existing volumes to add to protection group."
                     },
                     "host": {
                        "type": "array",
                        "description": "List of existing hosts to add to protection group."
                     },
                     "hostgroup": {
                        "type": "array",
                        "description": "List of existing hostgroups to add to protection group."
                     },
                     "eradicate": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nDefine whether to eradicate the protection group on delete and leave in trash."
                     },
                     "enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nDefine whether to enabled snapshots for the protection group."
                     },
                     "target": {
                        "type": "array",
                        "description": "List of remote arrays or offload target for replication protection group to connect to.\nNote that all replicated protection groups are asynchronous.\nTarget arrays or offload targets must already be connected to the source array.\nMaximum number of targets per Protection Group is 4, assuming your configuration supports this."
                     }
                  },
                  "required": [
                     "pgroup"
                  ]
               },
               "purefa_offload": {
                  "type": "object",
                  "description": "Create, modify and delete NFS or S3 offload targets.\nOnly supported on Purity v5.2.0 or higher.\nYou must have a correctly configured offload network for offload to work.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDefine state of offload",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the offload target"
                     },
                     "protocol": {
                        "type": "string",
                        "description": "Default: nfs\n\nDefine which protocol the offload engine uses",
                        "enum": [
                           "nfs",
                           "s3"
                        ]
                     },
                     "address": {
                        "type": "string",
                        "description": "The IP or FQDN address of the NFS server"
                     },
                     "share": {
                        "type": "string",
                        "description": "NFS export on the NFS server"
                     },
                     "options": {
                        "type": "string",
                        "description": "Additional mount options for the NFS share\nSupported mount options include I(port), I(rsize), I(wsize), I(nfsvers), and I(tcp) or I(udp)"
                     },
                     "access_key": {
                        "type": "string",
                        "description": "Access Key ID of the S3 target"
                     },
                     "bucket": {
                        "type": "string",
                        "description": "Name of the bucket for the S3 target"
                     },
                     "secret": {
                        "type": "string",
                        "description": "Secret Access Key for the S3 target"
                     },
                     "initialize": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nDefine whether to initialize the S3 bucket"
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "purefa_ntp": {
                  "type": "object",
                  "description": "Set or erase NTP configuration for Pure Storage FlashArrays.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nCreate or delete NTP servers configuration",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "ntp_servers": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "A list of up to 4 alternate NTP servers. These may include IPv4, IPv6 or FQDNs. Invalid IP addresses will cause the module to fail. No validation is performed for FQDNs.\nIf more than 4 servers are provided, only the first 4 unique nameservers will be used.\nif no servers are given a default of I(0.pool.ntp.org) will be used."
                     }
                  }
               },
               "purefa_info": {
                  "type": "object",
                  "description": "Collect information from a Pure Storage Flasharray running the Purity//FA operating system. By default, the module will collect basic information including hosts, host groups, protection groups and volume counts. Additional information can be collected based on the configured set of arguments.",
                  "properties": {
                     "gather_subset": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Default: minimum\n\nWhen supplied, this argument will define the information to be collected. Possible values for this include all, minimum, config, performance, capacity, network, subnet, interfaces, hgroups, pgroups, hosts, admins, volumes, snapshots, pods, vgroups, offload, apps, arrays, certs and kmip."
                     }
                  }
               },
               "purefa_host": {
                  "type": "object",
                  "description": "Create, delete or modify hosts on Pure Storage FlashArrays.",
                  "properties": {
                     "host": {
                        "type": "string",
                        "description": "The name of the host."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDefine whether the host should exist or not.\nWhen removing host all connected volumes will be disconnected.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "protocol": {
                        "type": "string",
                        "description": "Default: iscsi\n\nDefines the host connection protocol for volumes.",
                        "enum": [
                           "fc",
                           "iscsi",
                           "nvme",
                           "mixed"
                        ]
                     },
                     "wwns": {
                        "type": "array",
                        "description": "List of wwns of the host if protocol is fc or mixed."
                     },
                     "iqn": {
                        "type": "array",
                        "description": "List of IQNs of the host if protocol is iscsi or mixed."
                     },
                     "nqn": {
                        "type": "array",
                        "description": "List of NQNs of the host if protocol is nvme or mixed."
                     },
                     "volume": {
                        "type": "string",
                        "description": "Volume name to map to the host."
                     },
                     "lun": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "LUN ID to assign to volume for host. Must be unique.\nIf not provided the ID will be automatically assigned.\nRange for LUN ID is 1 to 4095."
                     },
                     "personality": {
                        "type": "string",
                        "description": "Define which operating system the host is. Recommended for ActiveCluster integration.",
                        "enum": [
                           "hpux",
                           "vms",
                           "aix",
                           "esxi",
                           "solaris",
                           "hitachi-vsp",
                           "oracle-vm-server",
                           "delete",
                           ""
                        ]
                     },
                     "preferred_array": {
                        "type": "array",
                        "description": "List of preferred arrays in an ActiveCluster environment.\nTo remove existing preferred arrays from the host, specify I(delete)."
                     }
                  },
                  "required": [
                     "host"
                  ]
               },
               "purefa_hg": {
                  "type": "object",
                  "description": "Create, delete or modify hostgroups on Pure Storage FlashArrays.",
                  "properties": {
                     "hostgroup": {
                        "type": "string",
                        "description": "The name of the hostgroup."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDefine whether the hostgroup should exist or not.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "host": {
                        "type": "array",
                        "description": "List of existing hosts to add to hostgroup."
                     },
                     "volume": {
                        "type": "array",
                        "description": "List of existing volumes to add to hostgroup."
                     }
                  },
                  "required": [
                     "hostgroup"
                  ]
               },
               "purefa_dsrole": {
                  "type": "object",
                  "description": "Set or erase directory services role configurations.\nOnly available for FlashArray running Purity 5.2.0 or higher",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nCreate or delete directory service role",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "role": {
                        "type": "string",
                        "description": "The directory service role to work on",
                        "enum": [
                           "array_admin",
                           "ops_admin",
                           "readonly",
                           "storage_admin"
                        ]
                     },
                     "group_base": {
                        "type": "string",
                        "description": "Specifies where the configured group is located in the directory tree. This field consists of Organizational Units (OUs) that combine with the base DN attribute and the configured group CNs to complete the full Distinguished Name of the groups. The group base should specify OU= for each OU and multiple OUs should be separated by commas. The order of OUs is important and should get larger in scope from left to right.\nEach OU should not exceed 64 characters in length."
                     },
                     "group": {
                        "type": "string",
                        "description": "Sets the common Name (CN) of the configured directory service group containing users for the FlashBlade. This name should be just the Common Name of the group without the CN= specifier.\nCommon Names should not exceed 64 characters in length."
                     }
                  }
               },
               "purefa_ds": {
                  "type": "object",
                  "description": "Set or erase configuration for the directory service. There is no facility to SSL certificates at this time. Use the FlashArray GUI for this additional configuration work.\nTo modify an existing directory service configuration you must first delete an existing configuration and then recreate with new settings.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nCreate or delete directory service configuration",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "enable": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether to enable or disable directory service support."
                     },
                     "uri": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "A list of up to 30 URIs of the directory servers. Each URI must include the scheme ldap:// or ldaps:// (for LDAP over SSL), a hostname, and a domain name or IP address. For example, ldap://ad.company.com configures the directory service with the hostname \"ad\" in the domain \"company.com\" while specifying the unencrypted LDAP protocol."
                     },
                     "base_dn": {
                        "type": "string",
                        "description": "Sets the base of the Distinguished Name (DN) of the directory service groups. The base should consist of only Domain Components (DCs). The base_dn will populate with a default value when a URI is entered by parsing domain components from the URI. The base DN should specify DC= for each domain component and multiple DCs should be separated by commas."
                     },
                     "bind_password": {
                        "type": "string",
                        "description": "Sets the password of the bind_user user name account."
                     },
                     "bind_user": {
                        "type": "string",
                        "description": "Sets the user name that can be used to bind to and query the directory.\nFor Active Directory, enter the username - often referred to as sAMAccountName or User Logon Name - of the account that is used to perform directory lookups.\nFor OpenLDAP, enter the full DN of the user."
                     },
                     "group_base": {
                        "type": "string",
                        "description": "Specifies where the configured groups are located in the directory tree. This field consists of Organizational Units (OUs) that combine with the base DN attribute and the configured group CNs to complete the full Distinguished Name of the groups. The group base should specify OU= for each OU and multiple OUs should be separated by commas. The order of OUs is important and should get larger in scope from left to right. Each OU should not exceed 64 characters in length.\nNot Supported from Purity 5.2.0 or higher. Use I(purefa_dsrole) module."
                     },
                     "ro_group": {
                        "type": "string",
                        "description": "Sets the common Name (CN) of the configured directory service group containing users with read-only privileges on the FlashArray. This name should be just the Common Name of the group without the CN= specifier. Common Names should not exceed 64 characters in length.\nNot Supported from Purity 5.2.0 or higher. Use I(purefa_dsrole) module."
                     },
                     "sa_group": {
                        "type": "string",
                        "description": "Sets the common Name (CN) of the configured directory service group containing administrators with storage-related privileges on the FlashArray. This name should be just the Common Name of the group without the CN= specifier. Common Names should not exceed 64 characters in length.\nNot Supported from Purity 5.2.0 or higher. Use I(purefa_dsrole) module."
                     },
                     "aa_group": {
                        "type": "string",
                        "description": "Sets the common Name (CN) of the directory service group containing administrators with full privileges when managing the FlashArray. The name should be just the Common Name of the group without the CN= specifier. Common Names should not exceed 64 characters in length.\nNot Supported from Purity 5.2.0 or higher. Use I(purefa_dsrole) module."
                     }
                  },
                  "required": [
                     "base_dn"
                  ]
               },
               "purefa_dns": {
                  "type": "object",
                  "description": "Set or erase configuration for the DNS settings.\nNameservers provided will overwrite any existing nameservers.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nSet or delete directory service configuration",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "domain": {
                        "type": "string",
                        "description": "Domain suffix to be appended when performing DNS lookups."
                     },
                     "nameservers": {
                        "type": "array",
                        "description": "List of up to 3 unique DNS server IP addresses. These can be IPv4 or IPv6 - No validation is done of the addresses is performed."
                     }
                  }
               },
               "purefa_connect": {
                  "type": "object",
                  "description": "Manage array connections to specified target array",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nCreate or delete array connection",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "target_url": {
                        "type": "string",
                        "description": "Management IP address of remote array."
                     },
                     "target_api": {
                        "type": "string",
                        "description": "API token for target array"
                     },
                     "connection": {
                        "type": "string",
                        "description": "Default: async\n\nType of connection between arrays.",
                        "enum": [
                           "sync",
                           "async"
                        ]
                     }
                  },
                  "required": [
                     "target_url"
                  ]
               },
               "purefa_banner": {
                  "type": "object",
                  "description": "Configure MOTD for Pure Storage FlashArrays.\nThis will be shown during an SSH or GUI login to the array.\nMultiple line messages can be achieved using \\\\n.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nSet ot delete the MOTD",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "banner": {
                        "type": "string",
                        "description": "Default: Welcome to the machine...\n\nBanner text, or MOTD, to use"
                     }
                  }
               },
               "purefa_arrayname": {
                  "type": "object",
                  "description": "Configure name of array for Pure Storage FlashArrays.\nIdeal for Day 0 initial configuration.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nSet the array name",
                        "enum": [
                           "present"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "Name of the array. Must conform to correct naming schema."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "purefa_alert": {
                  "type": "object",
                  "description": "Configure alert email configuration for Pure Storage FlashArrays.\nAdd or delete an individual syslog server to the existing list of serves.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nCreate or delete alert email",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "address": {
                        "type": "string",
                        "description": "Email address (valid format required)"
                     },
                     "enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nSet specified email address to be enabled or disabled"
                     }
                  },
                  "required": [
                     "address"
                  ]
               },
               "purefb_facts": {
                  "type": "object",
                  "description": "Collect facts information from a Pure Storage FlashBlade running the Purity//FB operating system. By default, the module will collect basic fact information including hosts, host groups, protection groups and volume counts. Additional fact information can be collected based on the configured set of arguments.",
                  "properties": {
                     "gather_subset": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Default: minimum\n\nWhen supplied, this argument will define the facts to be collected. Possible values for this include all, minimum, config, performance, capacity, network, subnets, lags, filesystems and snapshots."
                     }
                  }
               },
               "purefa_facts": {
                  "type": "object",
                  "description": "Collect facts information from a Pure Storage Flasharray running the Purity//FA operating system. By default, the module will collect basic fact information including hosts, host groups, protection groups and volume counts. Additional fact information can be collected based on the configured set of arguments.",
                  "properties": {
                     "gather_subset": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Default: minimum\n\nWhen supplied, this argument will define the facts to be collected. Possible values for this include all, minimum, config, performance, capacity, network, subnet, interfaces, hgroups, pgroups, hosts, admins, volumes, snapshots, pods, vgroups, offload, apps and arrays."
                     }
                  }
               },
               "netapp_e_volume_copy": {
                  "type": "object",
                  "description": "Create and delete snapshots images on volume groups for NetApp E-series storage arrays.",
                  "properties": {
                     "api_username": {
                        "type": "string",
                        "description": "The username to authenticate with the SANtricity WebServices Proxy or embedded REST API."
                     },
                     "api_password": {
                        "type": "string",
                        "description": "The password to authenticate with the SANtricity WebServices Proxy or embedded REST API."
                     },
                     "api_url": {
                        "type": "string",
                        "description": "The url to the SANtricity WebServices Proxy or embedded REST API, for example C(https://prod-1.wahoo.acme.com/devmgr/v2)."
                     },
                     "validate_certs": {
                        "type": "string",
                        "description": "Default: True\n\nShould https certificates be validated?"
                     },
                     "source_volume_id": {
                        "type": "string",
                        "description": "The id of the volume copy source.\nIf used, must be paired with destination_volume_id\nMutually exclusive with volume_copy_pair_id, and search_volume_id"
                     },
                     "destination_volume_id": {
                        "type": "string",
                        "description": "The id of the volume copy destination.\nIf used, must be paired with source_volume_id\nMutually exclusive with volume_copy_pair_id, and search_volume_id"
                     },
                     "volume_copy_pair_id": {
                        "type": "string",
                        "description": "The id of a given volume copy pair\nMutually exclusive with destination_volume_id, source_volume_id, and search_volume_id\nCan use to delete or check presence of volume pairs\nMust specify this or (destination_volume_id and source_volume_id)"
                     },
                     "state": {
                        "type": "string",
                        "description": "Whether the specified volume copy pair should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "create_copy_pair_if_does_not_exist": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nDefines if a copy pair will be created if it does not exist.\nIf set to True destination_volume_id and source_volume_id are required."
                     },
                     "start_stop_copy": {
                        "type": "string",
                        "description": "starts a re-copy or stops a copy in progress\nNote: If you stop the initial file copy before it it done the copy pair will be destroyed\nRequires volume_copy_pair_id"
                     },
                     "search_volume_id": {
                        "type": "string",
                        "description": "Searches for all valid potential target and source volumes that could be used in a copy_pair\nMutually exclusive with volume_copy_pair_id, destination_volume_id and source_volume_id"
                     }
                  },
                  "required": [
                     "api_username",
                     "api_password",
                     "api_url",
                     "state"
                  ]
               },
               "netapp_e_volume": {
                  "type": "object",
                  "description": "Create or remove volumes (standard and thin) for NetApp E/EF-series storage arrays.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Whether the specified volume should exist",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the volume to manage."
                     },
                     "storage_pool_name": {
                        "type": "string",
                        "description": "Required only when requested I(state=='present').\nName of the storage pool wherein the volume should reside."
                     },
                     "size_unit": {
                        "type": "string",
                        "description": "Default: gb\n\nThe unit used to interpret the size parameter",
                        "enum": [
                           "bytes",
                           "b",
                           "kb",
                           "mb",
                           "gb",
                           "tb",
                           "pb",
                           "eb",
                           "zb",
                           "yb"
                        ]
                     },
                     "size": {
                        "type": "string",
                        "description": "Required only when I(state=='present').\nSize of the volume in I(size_unit).\nSize of the virtual volume in the case of a thin volume in I(size_unit).\nMaximum virtual volume size of a thin provisioned volume is 256tb; however other OS-level restrictions may exist."
                     },
                     "segment_size_kb": {
                        "type": "string",
                        "description": "Default: 128\n\nSegment size of the volume\nAll values are in kibibytes.\nSome common choices include '8', '16', '32', '64', '128', '256', and '512' but options are system dependent.\nRetrieve the definitive system list from M(netapp_e_facts) under segment_sizes.\nWhen the storage pool is a raidDiskPool then the segment size must be 128kb.\nSegment size migrations are not allowed in this module"
                     },
                     "thin_provision": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether the volume should be thin provisioned.\nThin volumes can only be created when I(raid_level==\"raidDiskPool\").\nGenerally, use of thin-provisioning is not recommended due to performance impacts."
                     },
                     "thin_volume_repo_size": {
                        "type": "string",
                        "description": "This value (in size_unit) sets the allocated space for the thin provisioned repository.\nInitial value must between or equal to 4gb and 256gb in increments of 4gb.\nDuring expansion operations the increase must be between or equal to 4gb and 256gb in increments of 4gb.\nThis option has no effect during expansion if I(thin_volume_expansion_policy==\"automatic\").\nGenerally speaking you should almost always use I(thin_volume_expansion_policy==\"automatic)."
                     },
                     "thin_volume_max_repo_size": {
                        "type": "string",
                        "description": "Default: same as size (in size_unit)\n\nThis is the maximum amount the thin volume repository will be allowed to grow.\nOnly has significance when I(thin_volume_expansion_policy==\"automatic\").\nWhen the percentage I(thin_volume_repo_size) of I(thin_volume_max_repo_size) exceeds I(thin_volume_growth_alert_threshold) then a warning will be issued and the storage array will execute the I(thin_volume_expansion_policy) policy.\nExpansion operations when I(thin_volume_expansion_policy==\"automatic\") will increase the maximum repository size."
                     },
                     "thin_volume_expansion_policy": {
                        "type": "string",
                        "description": "Default: automatic\n\nThis is the thin volume expansion policy.\nWhen I(thin_volume_expansion_policy==\"automatic\") and I(thin_volume_growth_alert_threshold) is exceed the I(thin_volume_max_repo_size) will be automatically expanded.\nWhen I(thin_volume_expansion_policy==\"manual\") and I(thin_volume_growth_alert_threshold) is exceeded the storage system will wait for manual intervention.\nThe thin volume_expansion policy can not be modified on existing thin volumes in this module.\nGenerally speaking you should almost always use I(thin_volume_expansion_policy==\"automatic).",
                        "enum": [
                           "automatic",
                           "manual"
                        ]
                     },
                     "thin_volume_growth_alert_threshold": {
                        "type": "string",
                        "description": "Default: 95\n\nThis is the thin provision repository utilization threshold (in percent).\nWhen the percentage of used storage of the maximum repository size exceeds this value then a alert will be issued and the I(thin_volume_expansion_policy) will be executed.\nValues must be between or equal to 10 and 99."
                     },
                     "owning_controller": {
                        "type": "string",
                        "description": "Specifies which controller will be the primary owner of the volume\nNot specifying will allow the controller to choose ownership.",
                        "enum": [
                           "A",
                           "B"
                        ]
                     },
                     "ssd_cache_enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether an existing SSD cache should be enabled on the volume (fails if no SSD cache defined)\nThe default value is to ignore existing SSD cache setting."
                     },
                     "data_assurance_enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Determines whether data assurance (DA) should be enabled for the volume\nOnly available when creating a new volume and on a storage pool with drives supporting the DA capability."
                     },
                     "read_cache_enable": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nIndicates whether read caching should be enabled for the volume."
                     },
                     "read_ahead_enable": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nIndicates whether or not automatic cache read-ahead is enabled.\nThis option has no effect on thinly provisioned volumes since the architecture for thin volumes cannot benefit from read ahead caching."
                     },
                     "write_cache_enable": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nIndicates whether write-back caching should be enabled for the volume."
                     },
                     "cache_without_batteries": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Indicates whether caching should be used without battery backup.\nWarning, M(cache_without_batteries==true) and the storage system looses power and there is no battery backup, data will be lost!"
                     },
                     "workload_name": {
                        "type": "string",
                        "description": "Label for the workload defined by the metadata.\nWhen I(workload_name) and I(metadata) are specified then the defined workload will be added to the storage array.\nWhen I(workload_name) exists on the storage array but the metadata is different then the workload definition will be updated. (Changes will update all associated volumes!)\nExisting workloads can be retrieved using M(netapp_e_facts)."
                     },
                     "metadata": {
                        "type": "object",
                        "description": "Dictionary containing meta data for the use, user, location, etc of the volume (dictionary is arbitrarily defined for whatever the user deems useful)\nWhen I(workload_name) exists on the storage array but the metadata is different then the workload definition will be updated. (Changes will update all associated volumes!)\nI(workload_name) must be specified when I(metadata) are defined."
                     },
                     "wait_for_initialization": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Forces the module to wait for expansion operations to complete before continuing."
                     },
                     "initialization_timeout": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Duration in seconds before the wait_for_initialization operation will terminate.\nM(wait_for_initialization==True) to have any effect on module's operations."
                     }
                  },
                  "required": [
                     "state",
                     "name",
                     "size"
                  ]
               },
               "netapp_e_syslog": {
                  "type": "object",
                  "description": "Allow the syslog settings to be configured for an individual E-Series storage-system",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nAdd or remove the syslog server configuration for E-Series storage array.\nExisting syslog server configuration will be removed or updated when its address matches I(address).\nFully qualified hostname that resolve to an IPv4 address that matches I(address) will not be treated as a match.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "address": {
                        "type": "string",
                        "description": "The syslog server's IPv4 address or a fully qualified hostname.\nAll existing syslog configurations will be removed when I(state=absent) and I(address=None)."
                     },
                     "port": {
                        "type": "string",
                        "description": "Default: 514\n\nThis is the port the syslog server is using."
                     },
                     "protocol": {
                        "type": "string",
                        "description": "Default: udp\n\nThis is the transmission protocol the syslog server's using to receive syslog messages.",
                        "enum": [
                           "udp",
                           "tcp",
                           "tls"
                        ]
                     },
                     "components": {
                        "type": "string",
                        "description": "Default: ['auditLog']\n\nThe e-series logging components define the specific logs to transfer to the syslog server.\nAt the time of writing, 'auditLog' is the only logging component but more may become available."
                     },
                     "test": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "This forces a test syslog message to be sent to the stated syslog server.\nOnly attempts transmission when I(state=present)."
                     },
                     "log_path": {
                        "type": "string",
                        "description": "This argument specifies a local path for logging purposes."
                     }
                  }
               },
               "netapp_e_storagepool": {
                  "type": "object",
                  "description": "Create or remove volume groups and disk pools for NetApp E-series storage arrays.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Whether the specified storage pool should exist or not.\nNote that removing a storage pool currently requires the removal of all defined volumes first.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the storage pool to manage"
                     },
                     "criteria_drive_count": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "The number of disks to use for building the storage pool.\nWhen I(state==\"present\") then I(criteria_drive_count) or I(criteria_min_usable_capacity) must be specified.\nThe pool will be expanded if this number exceeds the number of disks already in place (See expansion note below)"
                     },
                     "criteria_min_usable_capacity": {
                        "type": "number",
                        "description": "The minimum size of the storage pool (in size_unit).\nWhen I(state==\"present\") then I(criteria_drive_count) or I(criteria_min_usable_capacity) must be specified.\nThe pool will be expanded if this value exceeds its current size. (See expansion note below)"
                     },
                     "criteria_drive_type": {
                        "type": "string",
                        "description": "The type of disk (hdd or ssd) to use when searching for candidates to use.\nWhen not specified each drive type will be evaluated until successful drive candidates are found starting with the most prevalent drive type.",
                        "enum": [
                           "hdd",
                           "ssd"
                        ]
                     },
                     "criteria_size_unit": {
                        "type": "string",
                        "description": "Default: gb\n\nThe unit used to interpret size parameters",
                        "enum": [
                           "bytes",
                           "b",
                           "kb",
                           "mb",
                           "gb",
                           "tb",
                           "pb",
                           "eb",
                           "zb",
                           "yb"
                        ]
                     },
                     "criteria_drive_min_size": {
                        "type": "string",
                        "description": "The minimum individual drive size (in size_unit) to consider when choosing drives for the storage pool."
                     },
                     "criteria_drive_interface_type": {
                        "type": "string",
                        "description": "The interface type to use when selecting drives for the storage pool\nIf not provided then all interface types will be considered.",
                        "enum": [
                           "sas",
                           "sas4k",
                           "fibre",
                           "fibre520b",
                           "scsi",
                           "sata",
                           "pata"
                        ]
                     },
                     "criteria_drive_require_da": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Ensures the storage pool will be created with only data assurance (DA) capable drives.\nOnly available for new storage pools; existing storage pools cannot be converted."
                     },
                     "criteria_drive_require_fde": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether full disk encryption ability is required for drives to be added to the storage pool"
                     },
                     "raid_level": {
                        "type": "string",
                        "description": "Default: raidDiskPool\n\nThe RAID level of the storage pool to be created.\nRequired only when I(state==\"present\").\nWhen I(raid_level==\"raidDiskPool\") then I(criteria_drive_count >= 10 or criteria_drive_count >= 11) is required depending on the storage array specifications.\nWhen I(raid_level==\"raid0\") then I(1<=criteria_drive_count) is required.\nWhen I(raid_level==\"raid1\") then I(2<=criteria_drive_count) is required.\nWhen I(raid_level==\"raid3\") then I(3<=criteria_drive_count<=30) is required.\nWhen I(raid_level==\"raid5\") then I(3<=criteria_drive_count<=30) is required.\nWhen I(raid_level==\"raid6\") then I(5<=criteria_drive_count<=30) is required.\nNote that raidAll will be treated as raidDiskPool and raid3 as raid5.",
                        "enum": [
                           "raidAll",
                           "raid0",
                           "raid1",
                           "raid3",
                           "raid5",
                           "raid6",
                           "raidDiskPool"
                        ]
                     },
                     "secure_pool": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Enables security at rest feature on the storage pool.\nWill only work if all drives in the pool are security capable (FDE, FIPS, or mix)\nWarning, once security is enabled it is impossible to disable without erasing the drives."
                     },
                     "reserve_drive_count": {
                        "type": "string",
                        "description": "Set the number of drives reserved by the storage pool for reconstruction operations.\nOnly valid on raid disk pools."
                     },
                     "remove_volumes": {
                        "type": "string",
                        "description": "Default: True\n\nPrior to removing a storage pool, delete all volumes in the pool."
                     },
                     "erase_secured_drives": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nIf I(state==\"absent\") then all storage pool drives will be erase\nIf I(state==\"present\") then delete all available storage array drives that have security enabled."
                     }
                  },
                  "required": [
                     "state",
                     "name"
                  ]
               },
               "netapp_e_storage_system": {
                  "type": "object",
                  "description": "Manage the arrays accessible via a NetApp Web Services Proxy for NetApp E-series storage arrays.",
                  "properties": {
                     "api_username": {
                        "type": "string",
                        "description": "The username to authenticate with the SANtricity WebServices Proxy or embedded REST API."
                     },
                     "api_password": {
                        "type": "string",
                        "description": "The password to authenticate with the SANtricity WebServices Proxy or embedded REST API."
                     },
                     "api_url": {
                        "type": "string",
                        "description": "The url to the SANtricity WebServices Proxy or embedded REST API."
                     },
                     "validate_certs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nShould https certificates be validated?"
                     },
                     "ssid": {
                        "type": "string",
                        "description": "The ID of the array to manage. This value must be unique for each array."
                     },
                     "state": {
                        "type": "string",
                        "description": "Whether the specified array should be configured on the Web Services Proxy or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "controller_addresses": {
                        "type": "string",
                        "description": "The list addresses for the out-of-band management adapter or the agent host. Mutually exclusive of array_wwn parameter."
                     },
                     "array_wwn": {
                        "type": "string",
                        "description": "The WWN of the array to manage. Only necessary if in-band managing multiple arrays on the same agent host.  Mutually exclusive of controller_addresses parameter."
                     },
                     "array_password": {
                        "type": "string",
                        "description": "The management password of the array to manage, if set."
                     },
                     "enable_trace": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nEnable trace logging for SYMbol calls to the storage system."
                     },
                     "meta_tags": {
                        "type": "string",
                        "description": "Optional meta tags to associate to this storage system"
                     }
                  },
                  "required": [
                     "api_username",
                     "api_password",
                     "api_url",
                     "ssid",
                     "state",
                     "controller_addresses"
                  ]
               },
               "netapp_e_snapshot_volume": {
                  "type": "object",
                  "description": "Create, update, remove snapshot volumes for NetApp E/EF-Series storage arrays.",
                  "properties": {
                     "api_username": {
                        "type": "string",
                        "description": "The username to authenticate with the SANtricity WebServices Proxy or embedded REST API."
                     },
                     "api_password": {
                        "type": "string",
                        "description": "The password to authenticate with the SANtricity WebServices Proxy or embedded REST API."
                     },
                     "api_url": {
                        "type": "string",
                        "description": "The url to the SANtricity WebServices Proxy or embedded REST API."
                     },
                     "validate_certs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nShould https certificates be validated?"
                     },
                     "ssid": {
                        "type": "string",
                        "description": "storage array ID"
                     },
                     "snapshot_image_id": {
                        "type": "string",
                        "description": "The identifier of the snapshot image used to create the new snapshot volume.\nNote: You'll likely want to use the M(netapp_e_facts) module to find the ID of the image you want."
                     },
                     "full_threshold": {
                        "type": "string",
                        "description": "Default: 85\n\nThe repository utilization warning threshold percentage"
                     },
                     "name": {
                        "type": "string",
                        "description": "The name you wish to give the snapshot volume"
                     },
                     "view_mode": {
                        "type": "string",
                        "description": "The snapshot volume access mode",
                        "enum": [
                           "modeUnknown",
                           "readWrite",
                           "readOnly",
                           "__UNDEFINED"
                        ]
                     },
                     "repo_percentage": {
                        "type": "string",
                        "description": "Default: 20\n\nThe size of the view in relation to the size of the base volume"
                     },
                     "storage_pool_name": {
                        "type": "string",
                        "description": "Name of the storage pool on which to allocate the repository volume."
                     },
                     "state": {
                        "type": "string",
                        "description": "Whether to create or remove the snapshot volume",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     }
                  },
                  "required": [
                     "api_username",
                     "api_password",
                     "api_url",
                     "ssid",
                     "snapshot_image_id",
                     "name",
                     "view_mode",
                     "storage_pool_name",
                     "state"
                  ]
               },
               "netapp_e_snapshot_images": {
                  "type": "object",
                  "description": "Create and delete snapshots images on snapshot groups for NetApp E-series storage arrays.\nOnly the oldest snapshot image can be deleted so consistency is preserved.\nRelated: Snapshot volumes are created from snapshot images.",
                  "properties": {
                     "api_username": {
                        "type": "string",
                        "description": "The username to authenticate with the SANtricity WebServices Proxy or embedded REST API."
                     },
                     "api_password": {
                        "type": "string",
                        "description": "The password to authenticate with the SANtricity WebServices Proxy or embedded REST API."
                     },
                     "api_url": {
                        "type": "string",
                        "description": "The url to the SANtricity WebServices Proxy or embedded REST API."
                     },
                     "validate_certs": {
                        "type": "string",
                        "description": "Default: True\n\nShould https certificates be validated?"
                     },
                     "snapshot_group": {
                        "type": "string",
                        "description": "The name of the snapshot group in which you want to create a snapshot image."
                     },
                     "state": {
                        "type": "string",
                        "description": "Whether a new snapshot image should be created or oldest be deleted.",
                        "enum": [
                           "create",
                           "remove"
                        ]
                     }
                  },
                  "required": [
                     "api_username",
                     "api_password",
                     "api_url",
                     "snapshot_group",
                     "state"
                  ]
               },
               "netapp_e_snapshot_group": {
                  "type": "object",
                  "description": "Create, update, delete snapshot groups for NetApp E-series storage arrays",
                  "properties": {
                     "api_username": {
                        "type": "string",
                        "description": "The username to authenticate with the SANtricity WebServices Proxy or embedded REST API."
                     },
                     "api_password": {
                        "type": "string",
                        "description": "The password to authenticate with the SANtricity WebServices Proxy or embedded REST API."
                     },
                     "api_url": {
                        "type": "string",
                        "description": "The url to the SANtricity WebServices Proxy or embedded REST API."
                     },
                     "validate_certs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nShould https certificates be validated?"
                     },
                     "state": {
                        "type": "string",
                        "description": "Whether to ensure the group is present or absent.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name to give the snapshot group"
                     },
                     "base_volume_name": {
                        "type": "string",
                        "description": "The name of the base volume or thin volume to use as the base for the new snapshot group.\nIf a snapshot group with an identical C(name) already exists but with a different base volume an error will be returned."
                     },
                     "repo_pct": {
                        "type": "string",
                        "description": "Default: 20\n\nThe size of the repository in relation to the size of the base volume"
                     },
                     "warning_threshold": {
                        "type": "string",
                        "description": "Default: 80\n\nThe repository utilization warning threshold, as a percentage of the repository volume capacity."
                     },
                     "delete_limit": {
                        "type": "string",
                        "description": "Default: 30\n\nThe automatic deletion indicator.\nIf non-zero, the oldest snapshot image will be automatically deleted when creating a new snapshot image to keep the total number of snapshot images limited to the number specified.\nThis value is overridden by the consistency group setting if this snapshot group is associated with a consistency group."
                     },
                     "full_policy": {
                        "type": "string",
                        "description": "Default: purgepit\n\nThe behavior on when the data repository becomes full.\nThis value is overridden by consistency group setting if this snapshot group is associated with a consistency group",
                        "enum": [
                           "purgepit",
                           "unknown",
                           "failbasewrites",
                           "__UNDEFINED"
                        ]
                     },
                     "storage_pool_name": {
                        "type": "string",
                        "description": "The name of the storage pool on which to allocate the repository volume."
                     },
                     "rollback_priority": {
                        "type": "string",
                        "description": "Default: medium\n\nThe importance of the rollback operation.\nThis value is overridden by consistency group setting if this snapshot group is associated with a consistency group",
                        "enum": [
                           "highest",
                           "high",
                           "medium",
                           "low",
                           "lowest",
                           "__UNDEFINED"
                        ]
                     }
                  },
                  "required": [
                     "api_username",
                     "api_password",
                     "api_url",
                     "state",
                     "name",
                     "base_volume_name",
                     "storage_pool_name"
                  ]
               },
               "netapp_e_mgmt_interface": {
                  "type": "object",
                  "description": "Configure the E-Series management interfaces",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Enable or disable IPv4 network interface configuration.\nEither IPv4 or IPv6 must be enabled otherwise error will occur.\nOnly required when enabling or disabling IPv4 network interface",
                        "enum": [
                           "enable",
                           "disable"
                        ]
                     },
                     "enable_interface": {
                        "type": "string",
                        "description": "Enable or disable IPv4 network interface configuration.\nEither IPv4 or IPv6 must be enabled otherwise error will occur.\nOnly required when enabling or disabling IPv4 network interface",
                        "enum": [
                           "enable",
                           "disable"
                        ]
                     },
                     "controller": {
                        "type": "string",
                        "description": "The controller that owns the port you want to configure.\nController names are represented alphabetically, with the first controller as A, the second as B, and so on.\nCurrent hardware models have either 1 or 2 available controllers, but that is not a guaranteed hard limitation and could change in the future.",
                        "enum": [
                           "A",
                           "B"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The port to modify the configuration for.\nThe list of choices is not necessarily comprehensive. It depends on the number of ports that are present in the system.\nThe name represents the port number (typically from left to right on the controller), beginning with a value of 1.\nMutually exclusive with I(channel)."
                     },
                     "port": {
                        "type": "string",
                        "description": "The port to modify the configuration for.\nThe list of choices is not necessarily comprehensive. It depends on the number of ports that are present in the system.\nThe name represents the port number (typically from left to right on the controller), beginning with a value of 1.\nMutually exclusive with I(channel)."
                     },
                     "iface": {
                        "type": "string",
                        "description": "The port to modify the configuration for.\nThe list of choices is not necessarily comprehensive. It depends on the number of ports that are present in the system.\nThe name represents the port number (typically from left to right on the controller), beginning with a value of 1.\nMutually exclusive with I(channel)."
                     },
                     "channel": {
                        "type": "string",
                        "description": "The port to modify the configuration for.\nThe channel represents the port number (typically from left to right on the controller), beginning with a value of 1.\nMutually exclusive with I(name)."
                     },
                     "address": {
                        "type": "string",
                        "description": "The IPv4 address to assign to the interface.\nShould be specified in xx.xx.xx.xx form.\nMutually exclusive with I(config_method=dhcp)"
                     },
                     "subnet_mask": {
                        "type": "string",
                        "description": "The subnet mask to utilize for the interface.\nShould be specified in xx.xx.xx.xx form.\nMutually exclusive with I(config_method=dhcp)"
                     },
                     "gateway": {
                        "type": "string",
                        "description": "The IPv4 gateway address to utilize for the interface.\nShould be specified in xx.xx.xx.xx form.\nMutually exclusive with I(config_method=dhcp)"
                     },
                     "config_method": {
                        "type": "string",
                        "description": "The configuration method type to use for network interface ports.\ndhcp is mutually exclusive with I(address), I(subnet_mask), and I(gateway).",
                        "enum": [
                           "dhcp",
                           "static"
                        ]
                     },
                     "dns_config_method": {
                        "type": "string",
                        "description": "The configuration method type to use for DNS services.\ndhcp is mutually exclusive with I(dns_address), and I(dns_address_backup).",
                        "enum": [
                           "dhcp",
                           "static"
                        ]
                     },
                     "dns_address": {
                        "type": "string",
                        "description": "Primary IPv4 DNS server address"
                     },
                     "dns_address_backup": {
                        "type": "string",
                        "description": "Backup IPv4 DNS server address\nQueried when primary DNS server fails"
                     },
                     "ntp_config_method": {
                        "type": "string",
                        "description": "The configuration method type to use for NTP services.\ndisable is mutually exclusive with I(ntp_address) and I(ntp_address_backup).\ndhcp is mutually exclusive with I(ntp_address) and I(ntp_address_backup).",
                        "enum": [
                           "disable",
                           "dhcp",
                           "static"
                        ]
                     },
                     "ntp_address": {
                        "type": "string",
                        "description": "Primary IPv4 NTP server address"
                     },
                     "ntp_address_backup": {
                        "type": "string",
                        "description": "Backup IPv4 NTP server address\nQueried when primary NTP server fails"
                     },
                     "ssh": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Enable ssh access to the controller for debug purposes.\nThis is a controller-level setting.\nrlogin/telnet will be enabled for ancient equipment where ssh is not available."
                     },
                     "log_path": {
                        "type": "string",
                        "description": "A local path to a file to be used for debug logging"
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "state",
                                    "enable_interface"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "port",
                                    "iface"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "netapp_e_lun_mapping": {
                  "type": "object",
                  "description": "Create, delete, or modify mappings between a volume and a targeted host/host+ group.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Present will ensure the mapping exists, absent will remove the mapping.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "target": {
                        "type": "string",
                        "description": "The name of host or hostgroup you wish to assign to the mapping\nIf omitted, the default hostgroup is used.\nIf the supplied I(volume_name) is associated with a different target, it will be updated to what is supplied here."
                     },
                     "volume_name": {
                        "type": "string",
                        "description": "The name of the volume you wish to include in the mapping."
                     },
                     "volume": {
                        "type": "string",
                        "description": "The name of the volume you wish to include in the mapping."
                     },
                     "lun": {
                        "type": "string",
                        "description": "The LUN value you wish to give the mapping.\nIf the supplied I(volume_name) is associated with a different LUN, it will be updated to what is supplied here.\nLUN value will be determine by the storage-system when not specified."
                     },
                     "target_type": {
                        "type": "string",
                        "description": "This option specifies the whether the target should be a host or a group of hosts\nOnly necessary when the target name is used for both a host and a group of hosts",
                        "enum": [
                           "host",
                           "group"
                        ]
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "volume_name",
                                    "volume"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "volume_name"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "volume"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "netapp_e_ldap": {
                  "type": "object",
                  "description": "Configure an E-Series system to allow authentication via an LDAP server",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nEnable/disable LDAP support on the system. Disabling will clear out any existing defined domains.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "identifier": {
                        "type": "string",
                        "description": "This is a unique identifier for the configuration (for cases where there are multiple domains configured).\nIf this is not specified, but I(state=present), we will utilize a default value of 'default'."
                     },
                     "username": {
                        "type": "string",
                        "description": "This is the user account that will be used for querying the LDAP server.\nExample: CN=MyBindAcct,OU=ServiceAccounts,DC=example,DC=com"
                     },
                     "bind_username": {
                        "type": "string",
                        "description": "This is the user account that will be used for querying the LDAP server.\nExample: CN=MyBindAcct,OU=ServiceAccounts,DC=example,DC=com"
                     },
                     "password": {
                        "type": "string",
                        "description": "This is the password for the bind user account."
                     },
                     "bind_password": {
                        "type": "string",
                        "description": "This is the password for the bind user account."
                     },
                     "attributes": {
                        "type": "string",
                        "description": "Default: memberOf\n\nThe user attributes that should be considered for the group to role mapping.\nTypically this is used with something like 'memberOf', and a user's access is tested against group membership or lack thereof."
                     },
                     "server": {
                        "type": "string",
                        "description": "This is the LDAP server url.\nThe connection string should be specified as using the ldap or ldaps protocol along with the port information."
                     },
                     "server_url": {
                        "type": "string",
                        "description": "This is the LDAP server url.\nThe connection string should be specified as using the ldap or ldaps protocol along with the port information."
                     },
                     "name": {
                        "type": "string",
                        "description": "The domain name[s] that will be utilized when authenticating to identify which domain to utilize.\nDefault to use the DNS name of the I(server).\nThe only requirement is that the name[s] be resolvable.\nExample: user@example.com"
                     },
                     "search_base": {
                        "type": "string",
                        "description": "The search base is used to find group memberships of the user.\nExample: ou=users,dc=example,dc=com"
                     },
                     "role_mappings": {
                        "type": "string",
                        "description": "This is where you specify which groups should have access to what permissions for the storage-system.\nFor example, all users in group A will be assigned all 4 available roles, which will allow access to all the management functionality of the system (super-user). Those in group B only have the storage.monitor role, which will allow only read-only access.\nThis is specified as a mapping of regular expressions to a list of roles. See the examples.\nThe roles that will be assigned to to the group/groups matching the provided regex.\nstorage.admin allows users full read/write access to storage objects and operations.\nstorage.monitor allows users read-only access to storage objects and operations.\nsupport.admin allows users access to hardware, diagnostic information, the Major Event Log, and other critical support-related functionality, but not the storage configuration.\nsecurity.admin allows users access to authentication/authorization configuration, as well as the audit log configuration, and certification management."
                     },
                     "user_attribute": {
                        "type": "string",
                        "description": "Default: sAMAccountName\n\nThis is the attribute we will use to match the provided username when a user attempts to authenticate."
                     },
                     "log_path": {
                        "type": "string",
                        "description": "A local path to a file to be used for debug logging"
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "username",
                                    "bind_username"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "username"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "bind_username"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "password",
                                    "bind_password"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "password"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "bind_password"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "server",
                                    "server_url"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "server"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "server_url"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "netapp_e_iscsi_target": {
                  "type": "object",
                  "description": "Configure the settings of an E-Series iSCSI target",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name/alias to assign to the iSCSI target.\nThis alias is often used by the initiator software in order to make an iSCSI target easier to identify."
                     },
                     "alias": {
                        "type": "string",
                        "description": "The name/alias to assign to the iSCSI target.\nThis alias is often used by the initiator software in order to make an iSCSI target easier to identify."
                     },
                     "ping": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nEnable ICMP ping responses from the configured iSCSI ports."
                     },
                     "chap_secret": {
                        "type": "string",
                        "description": "Enable Challenge-Handshake Authentication Protocol (CHAP), utilizing this value as the password.\nWhen this value is specified, we will always trigger an update (changed=True). We have no way of verifying whether or not the password has changed.\nThe chap secret may only use ascii characters with values between 32 and 126 decimal.\nThe chap secret must be no less than 12 characters, but no greater than 57 characters in length.\nThe chap secret is cleared when not specified or an empty string."
                     },
                     "chap": {
                        "type": "string",
                        "description": "Enable Challenge-Handshake Authentication Protocol (CHAP), utilizing this value as the password.\nWhen this value is specified, we will always trigger an update (changed=True). We have no way of verifying whether or not the password has changed.\nThe chap secret may only use ascii characters with values between 32 and 126 decimal.\nThe chap secret must be no less than 12 characters, but no greater than 57 characters in length.\nThe chap secret is cleared when not specified or an empty string."
                     },
                     "password": {
                        "type": "string",
                        "description": "Enable Challenge-Handshake Authentication Protocol (CHAP), utilizing this value as the password.\nWhen this value is specified, we will always trigger an update (changed=True). We have no way of verifying whether or not the password has changed.\nThe chap secret may only use ascii characters with values between 32 and 126 decimal.\nThe chap secret must be no less than 12 characters, but no greater than 57 characters in length.\nThe chap secret is cleared when not specified or an empty string."
                     },
                     "unnamed_discovery": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nWhen an initiator initiates a discovery session to an initiator port, it is considered an unnamed discovery session if the iSCSI target iqn is not specified in the request.\nThis option may be disabled to increase security if desired."
                     },
                     "log_path": {
                        "type": "string",
                        "description": "A local path (on the Ansible controller), to a file to be used for debug logging."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "alias"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "chap_secret",
                                    "chap",
                                    "password"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "netapp_e_iscsi_interface": {
                  "type": "object",
                  "description": "Configure settings of an E-Series iSCSI interface",
                  "properties": {
                     "controller": {
                        "type": "string",
                        "description": "The controller that owns the port you want to configure.\nController names are presented alphabetically, with the first controller as A, the second as B, and so on.\nCurrent hardware models have either 1 or 2 available controllers, but that is not a guaranteed hard limitation and could change in the future.",
                        "enum": [
                           "A",
                           "B"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The channel of the port to modify the configuration of.\nThe list of choices is not necessarily comprehensive. It depends on the number of ports that are available in the system.\nThe numerical value represents the number of the channel (typically from left to right on the HIC), beginning with a value of 1."
                     },
                     "channel": {
                        "type": "string",
                        "description": "The channel of the port to modify the configuration of.\nThe list of choices is not necessarily comprehensive. It depends on the number of ports that are available in the system.\nThe numerical value represents the number of the channel (typically from left to right on the HIC), beginning with a value of 1."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: enabled\n\nWhen enabled, the provided configuration will be utilized.\nWhen disabled, the IPv4 configuration will be cleared and IPv4 connectivity disabled.",
                        "enum": [
                           "enabled",
                           "disabled"
                        ]
                     },
                     "address": {
                        "type": "string",
                        "description": "The IPv4 address to assign to the interface.\nShould be specified in xx.xx.xx.xx form.\nMutually exclusive with I(config_method=dhcp)"
                     },
                     "subnet_mask": {
                        "type": "string",
                        "description": "The subnet mask to utilize for the interface.\nShould be specified in xx.xx.xx.xx form.\nMutually exclusive with I(config_method=dhcp)"
                     },
                     "gateway": {
                        "type": "string",
                        "description": "The IPv4 gateway address to utilize for the interface.\nShould be specified in xx.xx.xx.xx form.\nMutually exclusive with I(config_method=dhcp)"
                     },
                     "config_method": {
                        "type": "string",
                        "description": "Default: dhcp\n\nThe configuration method type to use for this interface.\ndhcp is mutually exclusive with I(address), I(subnet_mask), and I(gateway).",
                        "enum": [
                           "dhcp",
                           "static"
                        ]
                     },
                     "mtu": {
                        "type": "string",
                        "description": "Default: 1500\n\nThe maximum transmission units (MTU), in bytes.\nThis allows you to configure a larger value for the MTU, in order to enable jumbo frames (any value > 1500).\nGenerally, it is necessary to have your host, switches, and other components not only support jumbo frames, but also have it configured properly. Therefore, unless you know what you're doing, it's best to leave this at the default."
                     },
                     "max_frame_size": {
                        "type": "string",
                        "description": "Default: 1500\n\nThe maximum transmission units (MTU), in bytes.\nThis allows you to configure a larger value for the MTU, in order to enable jumbo frames (any value > 1500).\nGenerally, it is necessary to have your host, switches, and other components not only support jumbo frames, but also have it configured properly. Therefore, unless you know what you're doing, it's best to leave this at the default."
                     },
                     "log_path": {
                        "type": "string",
                        "description": "A local path to a file to be used for debug logging"
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "channel"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "channel"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "mtu",
                                    "max_frame_size"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "netapp_e_hostgroup": {
                  "type": "object",
                  "description": "Create, update or destroy host groups on a NetApp E-Series storage array.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Whether the specified host group should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "Name of the host group to manage\nThis option is mutually exclusive with I(id)."
                     },
                     "new_name": {
                        "type": "string",
                        "description": "Specify this when you need to update the name of a host group"
                     },
                     "id": {
                        "type": "string",
                        "description": "Host reference identifier for the host group to manage.\nThis option is mutually exclusive with I(name)."
                     },
                     "hosts": {
                        "type": "array",
                        "description": "List of host names/labels to add to the group"
                     }
                  },
                  "required": [
                     "state"
                  ]
               },
               "netapp_e_host": {
                  "type": "object",
                  "description": "Create, update, remove hosts on NetApp E-series storage arrays",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "If the host doesn't yet exist, the label/name to assign at creation time.\nIf the hosts already exists, this will be used to uniquely identify the host to make any required changes"
                     },
                     "label": {
                        "type": "string",
                        "description": "If the host doesn't yet exist, the label/name to assign at creation time.\nIf the hosts already exists, this will be used to uniquely identify the host to make any required changes"
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nSet to absent to remove an existing host\nSet to present to modify or create a new host definition",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "host_type": {
                        "type": "string",
                        "description": "This is the type of host to be mapped\nRequired when C(state=present)\nEither one of the following names can be specified, Linux DM-MP, VMWare, Windows, Windows Clustered, or a host type index which can be found in M(netapp_e_facts)"
                     },
                     "host_type_index": {
                        "type": "string",
                        "description": "This is the type of host to be mapped\nRequired when C(state=present)\nEither one of the following names can be specified, Linux DM-MP, VMWare, Windows, Windows Clustered, or a host type index which can be found in M(netapp_e_facts)"
                     },
                     "ports": {
                        "type": "string",
                        "description": "A list of host ports you wish to associate with the host.\nHost ports are uniquely identified by their WWN or IQN. Their assignments to a particular host are uniquely identified by a label and these must be unique."
                     },
                     "force_port": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Allow ports that are already assigned to be re-assigned to your current host"
                     },
                     "group": {
                        "type": "string",
                        "description": "The unique identifier of the host-group you want the host to be a member of; this is used for clustering."
                     },
                     "cluster": {
                        "type": "string",
                        "description": "The unique identifier of the host-group you want the host to be a member of; this is used for clustering."
                     },
                     "log_path": {
                        "type": "string",
                        "description": "A local path to a file to be used for debug logging"
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "label"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "label"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "host_type",
                                    "host_type_index"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "group",
                                    "cluster"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "netapp_e_global": {
                  "type": "object",
                  "description": "Allow the user to configure several of the global settings associated with an E-Series storage-system",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Set the name of the E-Series storage-system\nThis label/name doesn't have to be unique.\nMay be up to 30 characters in length."
                     },
                     "label": {
                        "type": "string",
                        "description": "Set the name of the E-Series storage-system\nThis label/name doesn't have to be unique.\nMay be up to 30 characters in length."
                     },
                     "log_path": {
                        "type": "string",
                        "description": "A local path to a file to be used for debug logging"
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "label"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "netapp_e_flashcache": {
                  "type": "object",
                  "description": "Create or remove SSD caches on a NetApp E-Series storage array.",
                  "properties": {
                     "api_username": {
                        "type": "string",
                        "description": "The username to authenticate with the SANtricity WebServices Proxy or embedded REST API."
                     },
                     "api_password": {
                        "type": "string",
                        "description": "The password to authenticate with the SANtricity WebServices Proxy or embedded REST API."
                     },
                     "api_url": {
                        "type": "string",
                        "description": "The url to the SANtricity WebServices Proxy or embedded REST API."
                     },
                     "validate_certs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nShould https certificates be validated?"
                     },
                     "ssid": {
                        "type": "string",
                        "description": "The ID of the array to manage (as configured on the web services proxy)."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified SSD cache should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the SSD cache to manage"
                     },
                     "io_type": {
                        "type": "string",
                        "description": "Default: filesystem\n\nThe type of workload to optimize the cache for.",
                        "enum": [
                           "filesystem",
                           "database",
                           "media"
                        ]
                     },
                     "disk_count": {
                        "type": "string",
                        "description": "The minimum number of disks to use for building the cache. The cache will be expanded if this number exceeds the number of disks already in place"
                     },
                     "size_unit": {
                        "type": "string",
                        "description": "Default: gb\n\nThe unit to be applied to size arguments",
                        "enum": [
                           "bytes",
                           "b",
                           "kb",
                           "mb",
                           "gb",
                           "tb",
                           "pb",
                           "eb",
                           "zb",
                           "yb"
                        ]
                     },
                     "cache_size_min": {
                        "type": "string",
                        "description": "The minimum size (in size_units) of the ssd cache. The cache will be expanded if this exceeds the current size of the cache."
                     }
                  },
                  "required": [
                     "api_username",
                     "api_password",
                     "api_url",
                     "ssid",
                     "state",
                     "name"
                  ]
               },
               "netapp_e_firmware": {
                  "type": "object",
                  "description": "Ensure specific firmware versions are activated on E-Series storage system.",
                  "properties": {
                     "nvsram": {
                        "type": "string",
                        "description": "Path to the NVSRAM file."
                     },
                     "firmware": {
                        "type": "string",
                        "description": "Path to the firmware file."
                     },
                     "wait_for_completion": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "This flag will cause module to wait for any upgrade actions to complete."
                     },
                     "ignore_health_check": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "This flag will force firmware to be activated in spite of the health check.\nUse at your own risk. Certain non-optimal states could result in data loss."
                     }
                  },
                  "required": [
                     "nvsram",
                     "firmware"
                  ]
               },
               "netapp_e_facts": {
                  "type": "object",
                  "description": "The netapp_e_facts module returns a collection of facts regarding NetApp E-Series storage arrays.\nWhen contacting a storage array directly the collection includes details about the array, controllers, management interfaces, hostside interfaces, driveside interfaces, disks, storage pools, volumes, snapshots, and features.\nWhen contacting a web services proxy the collection will include basic information regarding the storage systems that are under its management.",
                  "properties": {}
               },
               "netapp_e_drive_firmware": {
                  "type": "object",
                  "description": "Ensure drive firmware version is activated on specified drive model.",
                  "properties": {
                     "firmware": {
                        "type": "array",
                        "description": "list of drive firmware file paths.\nNetApp E-Series drives require special firmware which can be downloaded from https://mysupport.netapp.com/NOW/download/tools/diskfw_eseries/"
                     },
                     "wait_for_completion": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "This flag will cause module to wait for any upgrade actions to complete."
                     },
                     "ignore_inaccessible_drives": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "This flag will determine whether drive firmware upgrade should fail if any affected drives are inaccessible."
                     },
                     "upgrade_drives_online": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nThis flag will determine whether drive firmware can be upgrade while drives are accepting I/O.\nWhen I(upgrade_drives_online==False) stop all I/O before running task."
                     }
                  },
                  "required": [
                     "firmware"
                  ]
               },
               "netapp_e_auth": {
                  "type": "object",
                  "description": "Sets or updates the password for a storage array.  When the password is updated on the storage array, it must be updated on the SANtricity Web Services proxy. Note, all storage arrays do not have a Monitor or RO role.",
                  "properties": {
                     "validate_certs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nShould https certificates be validated?"
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the storage array. Note that if more than one storage array with this name is detected, the task will fail and you'll have to use the ID instead."
                     },
                     "ssid": {
                        "type": "string",
                        "description": "the identifier of the storage array in the Web Services Proxy."
                     },
                     "set_admin": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Boolean value on whether to update the admin password. If set to false then the RO account is updated."
                     },
                     "current_password": {
                        "type": "string",
                        "description": "The current admin password. This is not required if the password hasn't been set before."
                     },
                     "new_password": {
                        "type": "string",
                        "description": "The password you would like to set. Cannot be more than 30 characters."
                     },
                     "api_url": {
                        "type": "string",
                        "description": "The full API url.\nExample: http://ENDPOINT:8080/devmgr/v2\nThis can optionally be set via an environment variable, API_URL"
                     },
                     "api_username": {
                        "type": "string",
                        "description": "The username used to authenticate against the API\nThis can optionally be set via an environment variable, API_USERNAME"
                     },
                     "api_password": {
                        "type": "string",
                        "description": "The password used to authenticate against the API\nThis can optionally be set via an environment variable, API_PASSWORD"
                     }
                  },
                  "required": [
                     "new_password"
                  ]
               },
               "netapp_e_auditlog": {
                  "type": "object",
                  "description": "This module allows an e-series storage system owner to set audit-log configuration parameters.",
                  "properties": {
                     "max_records": {
                        "type": "string",
                        "description": "Default: 50000\n\nThe maximum number log messages audit-log will retain.\nMax records must be between and including 100 and 50000."
                     },
                     "log_level": {
                        "type": "string",
                        "description": "Default: writeOnly\n\nFilters the log messages according to the specified log level selection.",
                        "enum": [
                           "all",
                           "writeOnly"
                        ]
                     },
                     "full_policy": {
                        "type": "string",
                        "description": "Default: overWrite\n\nSpecifies what audit-log should do once the number of entries approach the record limit.",
                        "enum": [
                           "overWrite",
                           "preventSystemAccess"
                        ]
                     },
                     "threshold": {
                        "type": "string",
                        "description": "Default: 90\n\nThis is the memory full percent threshold that audit-log will start issuing warning messages.\nPercent range must be between and including 60 and 90."
                     },
                     "force": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Forces the audit-log configuration to delete log history when log messages fullness cause immediate warning or full condition.\nWarning! This will cause any existing audit-log messages to be deleted.\nThis is only applicable for I(full_policy=preventSystemAccess)."
                     },
                     "log_path": {
                        "type": "string",
                        "description": "A local path to a file to be used for debug logging."
                     }
                  }
               },
               "netapp_e_asup": {
                  "type": "object",
                  "description": "Allow the auto-support settings to be configured for an individual E-Series storage-system",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: enabled\n\nEnable/disable the E-Series auto-support configuration.\nWhen this option is enabled, configuration, logs, and other support-related information will be relayed to NetApp to help better support your system. No personally identifiable information, passwords, etc, will be collected.",
                        "enum": [
                           "enabled",
                           "disabled"
                        ]
                     },
                     "asup": {
                        "type": "string",
                        "description": "Default: enabled\n\nEnable/disable the E-Series auto-support configuration.\nWhen this option is enabled, configuration, logs, and other support-related information will be relayed to NetApp to help better support your system. No personally identifiable information, passwords, etc, will be collected.",
                        "enum": [
                           "enabled",
                           "disabled"
                        ]
                     },
                     "auto_support": {
                        "type": "string",
                        "description": "Default: enabled\n\nEnable/disable the E-Series auto-support configuration.\nWhen this option is enabled, configuration, logs, and other support-related information will be relayed to NetApp to help better support your system. No personally identifiable information, passwords, etc, will be collected.",
                        "enum": [
                           "enabled",
                           "disabled"
                        ]
                     },
                     "autosupport": {
                        "type": "string",
                        "description": "Default: enabled\n\nEnable/disable the E-Series auto-support configuration.\nWhen this option is enabled, configuration, logs, and other support-related information will be relayed to NetApp to help better support your system. No personally identifiable information, passwords, etc, will be collected.",
                        "enum": [
                           "enabled",
                           "disabled"
                        ]
                     },
                     "active": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nEnable active/proactive monitoring for ASUP. When a problem is detected by our monitoring systems, it's possible that the bundle did not contain all of the required information at the time of the event. Enabling this option allows NetApp support personnel to manually request transmission or re-transmission of support data in order ot resolve the problem.\nOnly applicable if I(state=enabled)."
                     },
                     "start": {
                        "type": "string",
                        "description": "A start hour may be specified in a range from 0 to 23 hours.\nASUP bundles will be sent daily between the provided start and end time (UTC).\nI(start) must be less than I(end)."
                     },
                     "start_time": {
                        "type": "string",
                        "description": "A start hour may be specified in a range from 0 to 23 hours.\nASUP bundles will be sent daily between the provided start and end time (UTC).\nI(start) must be less than I(end)."
                     },
                     "end": {
                        "type": "string",
                        "description": "Default: 24\n\nAn end hour may be specified in a range from 1 to 24 hours.\nASUP bundles will be sent daily between the provided start and end time (UTC).\nI(start) must be less than I(end)."
                     },
                     "end_time": {
                        "type": "string",
                        "description": "Default: 24\n\nAn end hour may be specified in a range from 1 to 24 hours.\nASUP bundles will be sent daily between the provided start and end time (UTC).\nI(start) must be less than I(end)."
                     },
                     "days": {
                        "type": "string",
                        "description": "A list of days of the week that ASUP bundles will be sent. A larger, weekly bundle will be sent on one of the provided days.",
                        "enum": [
                           "monday",
                           "tuesday",
                           "wednesday",
                           "thursday",
                           "friday",
                           "saturday",
                           "sunday"
                        ]
                     },
                     "days_of_week": {
                        "type": "string",
                        "description": "A list of days of the week that ASUP bundles will be sent. A larger, weekly bundle will be sent on one of the provided days.",
                        "enum": [
                           "monday",
                           "tuesday",
                           "wednesday",
                           "thursday",
                           "friday",
                           "saturday",
                           "sunday"
                        ]
                     },
                     "schedule_days": {
                        "type": "string",
                        "description": "A list of days of the week that ASUP bundles will be sent. A larger, weekly bundle will be sent on one of the provided days.",
                        "enum": [
                           "monday",
                           "tuesday",
                           "wednesday",
                           "thursday",
                           "friday",
                           "saturday",
                           "sunday"
                        ]
                     },
                     "verbose": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Provide the full ASUP configuration in the return."
                     },
                     "log_path": {
                        "type": "string",
                        "description": "A local path to a file to be used for debug logging"
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "state",
                                    "asup",
                                    "auto_support",
                                    "autosupport"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "start",
                                    "start_time"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "end",
                                    "end_time"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "days",
                                    "days_of_week",
                                    "schedule_days"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "netapp_e_amg_sync": {
                  "type": "object",
                  "description": "Allows for the initialization, suspension and resumption of an asynchronous mirror group's synchronization for NetApp E-series storage arrays.",
                  "properties": {
                     "api_username": {
                        "type": "string",
                        "description": "The username to authenticate with the SANtricity WebServices Proxy or embedded REST API."
                     },
                     "api_password": {
                        "type": "string",
                        "description": "The password to authenticate with the SANtricity WebServices Proxy or embedded REST API."
                     },
                     "api_url": {
                        "type": "string",
                        "description": "The url to the SANtricity WebServices Proxy or embedded REST API."
                     },
                     "validate_certs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nShould https certificates be validated?"
                     },
                     "ssid": {
                        "type": "string",
                        "description": "The ID of the storage array containing the AMG you wish to target"
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the async mirror group you wish to target"
                     },
                     "state": {
                        "type": "string",
                        "description": "The synchronization action you'd like to take.\nIf C(running) then it will begin syncing if there is no active sync or will resume a suspended sync. If there is already a sync in progress, it will return with an OK status.\nIf C(suspended) it will suspend any ongoing sync action, but return OK if there is no active sync or if the sync is already suspended",
                        "enum": [
                           "running",
                           "suspended"
                        ]
                     },
                     "delete_recovery_point": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Indicates whether the failures point can be deleted on the secondary if necessary to achieve the synchronization.\nIf true, and if the amount of unsynchronized data exceeds the CoW repository capacity on the secondary for any member volume, the last failures point will be deleted and synchronization will continue.\nIf false, the synchronization will be suspended if the amount of unsynchronized data exceeds the CoW Repository capacity on the secondary and the failures point will be preserved.\nNOTE: This only has impact for newly launched syncs."
                     }
                  },
                  "required": [
                     "api_username",
                     "api_password",
                     "api_url",
                     "name",
                     "state"
                  ]
               },
               "netapp_e_amg_role": {
                  "type": "object",
                  "description": "Update a storage array to become the primary or secondary instance in an asynchronous mirror group",
                  "properties": {
                     "api_username": {
                        "type": "string",
                        "description": "The username to authenticate with the SANtricity WebServices Proxy or embedded REST API."
                     },
                     "api_password": {
                        "type": "string",
                        "description": "The password to authenticate with the SANtricity WebServices Proxy or embedded REST API."
                     },
                     "api_url": {
                        "type": "string",
                        "description": "The url to the SANtricity WebServices Proxy or embedded REST API."
                     },
                     "validate_certs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nShould https certificates be validated?"
                     },
                     "ssid": {
                        "type": "string",
                        "description": "The ID of the primary storage array for the async mirror action"
                     },
                     "role": {
                        "type": "string",
                        "description": "Whether the array should be the primary or secondary array for the AMG",
                        "enum": [
                           "primary",
                           "secondary"
                        ]
                     },
                     "noSync": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether to avoid synchronization prior to role reversal"
                     },
                     "force": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether to force the role reversal regardless of the online-state of the primary"
                     }
                  },
                  "required": [
                     "api_username",
                     "api_password",
                     "api_url",
                     "ssid",
                     "role"
                  ]
               },
               "netapp_e_amg": {
                  "type": "object",
                  "description": "Allows for the creation, removal and updating of Asynchronous Mirror Groups for NetApp E-series storage arrays",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name of the async array you wish to target, or create.\nIf C(state) is present and the name isn't found, it will attempt to create."
                     },
                     "secondaryArrayId": {
                        "type": "string",
                        "description": "The ID of the secondary array to be used in mirroring process"
                     },
                     "syncIntervalMinutes": {
                        "type": "string",
                        "description": "Default: 10\n\nThe synchronization interval in minutes"
                     },
                     "manualSync": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nSetting this to true will cause other synchronization values to be ignored"
                     },
                     "recoveryWarnThresholdMinutes": {
                        "type": "string",
                        "description": "Default: 20\n\nRecovery point warning threshold (minutes). The user will be warned when the age of the last good failures point exceeds this value"
                     },
                     "repoUtilizationWarnThreshold": {
                        "type": "string",
                        "description": "Default: 80\n\nRecovery point warning threshold"
                     },
                     "interfaceType": {
                        "type": "string",
                        "description": "The intended protocol to use if both Fibre and iSCSI are available.",
                        "enum": [
                           "iscsi",
                           "fibre"
                        ]
                     },
                     "syncWarnThresholdMinutes": {
                        "type": "string",
                        "description": "Default: 10\n\nThe threshold (in minutes) for notifying the user that periodic synchronization has taken too long to complete."
                     },
                     "state": {
                        "type": "string",
                        "description": "A C(state) of present will either create or update the async mirror group.\nA C(state) of absent will remove the async mirror group.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     }
                  },
                  "required": [
                     "name",
                     "secondaryArrayId",
                     "state"
                  ]
               },
               "netapp_e_alerts": {
                  "type": "object",
                  "description": "Certain E-Series systems have the capability to send email notifications on potentially critical events.\nThis module will allow the owner of the system to specify email recipients for these messages.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: enabled\n\nEnable/disable the sending of email-based alerts.",
                        "enum": [
                           "enabled",
                           "disabled"
                        ]
                     },
                     "server": {
                        "type": "string",
                        "description": "A fully qualified domain name, IPv4 address, or IPv6 address of a mail server.\nTo use a fully qualified domain name, you must configure a DNS server on both controllers using M(netapp_e_mgmt_interface). - Required when I(state=enabled)."
                     },
                     "sender": {
                        "type": "string",
                        "description": "This is the sender that the recipient will see. It doesn't necessarily need to be a valid email account.\nRequired when I(state=enabled)."
                     },
                     "contact": {
                        "type": "string",
                        "description": "Allows the owner to specify some free-form contact information to be included in the emails.\nThis is typically utilized to provide a contact phone number."
                     },
                     "recipients": {
                        "type": "string",
                        "description": "The email addresses that will receive the email notifications.\nRequired when I(state=enabled)."
                     },
                     "test": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "When a change is detected in the configuration, a test email will be sent.\nThis may take a few minutes to process.\nOnly applicable if I(state=enabled)."
                     },
                     "log_path": {
                        "type": "string",
                        "description": "Path to a file on the Ansible control node to be used for debug logging"
                     }
                  }
               },
               "na_ontap_vserver_peer": {
                  "type": "object",
                  "description": "Create/Delete vserver peer",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified vserver peer should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "vserver": {
                        "type": "string",
                        "description": "Specifies name of the source Vserver in the relationship."
                     },
                     "applications": {
                        "type": "array",
                        "description": "List of applications which can make use of the peering relationship.\nFlexCache supported from ONTAP 9.5 onwards."
                     },
                     "peer_vserver": {
                        "type": "string",
                        "description": "Specifies name of the peer Vserver in the relationship."
                     },
                     "peer_cluster": {
                        "type": "string",
                        "description": "Specifies name of the peer Cluster.\nRequired for creating the vserver peer relationship with a remote cluster"
                     },
                     "dest_hostname": {
                        "type": "string",
                        "description": "Destination hostname or IP address.\nRequired for creating the vserver peer relationship with a remote cluster"
                     },
                     "dest_username": {
                        "type": "string",
                        "description": "Destination username.\nOptional if this is same as source username."
                     },
                     "dest_password": {
                        "type": "string",
                        "description": "Destination password.\nOptional if this is same as source password."
                     }
                  }
               },
               "na_ontap_vserver_cifs_security": {
                  "type": "object",
                  "description": "modify vserver CIFS security.",
                  "properties": {
                     "vserver": {
                        "type": "string",
                        "description": "name of the vserver."
                     },
                     "kerberos_clock_skew": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "The clock skew in minutes is the tolerance for accepting tickets with time stamps that do not exactly match the host's system clock."
                     },
                     "kerberos_ticket_age": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Determine the maximum amount of time in hours that a user's ticket may be used for the purpose of Kerberos authentication."
                     },
                     "kerberos_renew_age": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Determine the maximum amount of time in days for which a ticket can be renewed."
                     },
                     "kerberos_kdc_timeout": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Determine the timeout value in seconds for KDC connections."
                     },
                     "is_signing_required": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Determine whether signing is required for incoming CIFS traffic."
                     },
                     "is_password_complexity_required": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Determine whether password complexity is required for local users."
                     },
                     "is_aes_encryption_enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Determine whether AES-128 and AES-256 encryption mechanisms are enabled for Kerberos-related CIFS communication."
                     },
                     "is_smb_encryption_required": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Determine whether SMB encryption is required for incoming CIFS traffic."
                     },
                     "lm_compatibility_level": {
                        "type": "string",
                        "description": "Determine the LM compatibility level.",
                        "enum": [
                           "lm_ntlm_ntlmv2_krb",
                           "ntlm_ntlmv2_krb",
                           "ntlmv2_krb",
                           "krb"
                        ]
                     },
                     "referral_enabled_for_ad_ldap": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Determine whether LDAP referral chasing is enabled or not for AD LDAP connections."
                     },
                     "session_security_for_ad_ldap": {
                        "type": "string",
                        "description": "Determine the level of security required for LDAP communications.",
                        "enum": [
                           "none",
                           "sign",
                           "seal"
                        ]
                     },
                     "smb1_enabled_for_dc_connections": {
                        "type": "string",
                        "description": "Determine if SMB version 1 is used for connections to domain controllers.",
                        "enum": [
                           "false",
                           "true",
                           "system_default"
                        ]
                     },
                     "smb2_enabled_for_dc_connections": {
                        "type": "string",
                        "description": "Determine if SMB version 2 is used for connections to domain controllers.",
                        "enum": [
                           "false",
                           "true",
                           "system_default"
                        ]
                     },
                     "use_start_tls_for_ad_ldap": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Determine whether to use start_tls for AD LDAP connections."
                     }
                  },
                  "required": [
                     "vserver"
                  ]
               },
               "na_ontap_vscan_scanner_pool": {
                  "type": "object",
                  "description": "Configure a Vscan Scanner Pool",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether a Vscan Scanner pool is present or not",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "vserver": {
                        "type": "string",
                        "description": "the name of the data vserver to use."
                     },
                     "hostnames": {
                        "type": "array",
                        "description": "List of hostnames of Vscan servers which are allowed to connect to Data ONTAP"
                     },
                     "privileged_users": {
                        "type": "array",
                        "description": "List of privileged usernames. Username must be in the form \"domain-name\\user-name\""
                     },
                     "scanner_pool": {
                        "type": "string",
                        "description": "the name of the virus scanner pool"
                     },
                     "scanner_policy": {
                        "type": "string",
                        "description": "The name of the Virus scanner Policy",
                        "enum": [
                           "primary",
                           "secondary",
                           "idle"
                        ]
                     }
                  },
                  "required": [
                     "vserver",
                     "scanner_pool"
                  ]
               },
               "na_ontap_vscan_on_demand_task": {
                  "type": "object",
                  "description": "Configure on demand task for Vscan",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether a Vscan on demand task is present or not",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "vserver": {
                        "type": "string",
                        "description": "the name of the data vserver to use."
                     },
                     "cross_junction": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Specifies whether the On-Demand task is allowed to cross volume junctions"
                     },
                     "directory_recursion": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Specifies whether the On-Demand task is allowed to recursively scan through sub-directories."
                     },
                     "file_ext_to_exclude": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "File-Extensions for which scanning must not be performed.\nFile whose extension matches with both inclusion and exclusion list is not considered for scanning."
                     },
                     "file_ext_to_include": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "File extensions for which scanning is considered.\nThe default value is '*', which means that all files are considered for scanning except those which are excluded from scanning.\nFile whose extension matches with both inclusion and exclusion list is not considered for scanning."
                     },
                     "max_file_size": {
                        "type": "string",
                        "description": "Max file-size (in bytes) allowed for scanning. The default value of 10737418240 (10GB) is taken if not provided at the time of creating a task."
                     },
                     "paths_to_exclude": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "File-paths for which scanning must not be performed."
                     },
                     "report_directory": {
                        "type": "string",
                        "description": "Path from the vserver root where task report is created. The path must be a directory and provided in unix-format from the root of the Vserver.\nExample /vol1/on-demand-reports."
                     },
                     "report_log_level": {
                        "type": "string",
                        "description": "Default: error\n\nLog level for the On-Demand report.",
                        "enum": [
                           "verbose",
                           "info",
                           "error"
                        ]
                     },
                     "request_timeout": {
                        "type": "string",
                        "description": "Total request-service time-limit in seconds. If the virus-scanner does not respond within the provided time, scan will be timed out."
                     },
                     "scan_files_with_no_ext": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nSpecifies whether files without any extension are considered for scanning or not."
                     },
                     "scan_paths": {
                        "type": "array",
                        "description": "List of paths that need to be scanned. The path must be provided in unix-format and from the root of the Vserver.\nExample /vol1/large_files."
                     },
                     "scan_priority": {
                        "type": "string",
                        "description": "Default: low\n\nPriority of the On-Demand scan requests generated by this task.",
                        "enum": [
                           "low",
                           "normal"
                        ]
                     },
                     "schedule": {
                        "type": "string",
                        "description": "Schedule of the task. The task will be run as per the schedule.\nFor running the task immediately, vscan-on-demand-task-run api must be used after creating a task."
                     },
                     "task_name": {
                        "type": "string",
                        "description": "Name of the task."
                     }
                  },
                  "required": [
                     "vserver",
                     "task_name"
                  ]
               },
               "na_ontap_vscan_on_access_policy": {
                  "type": "object",
                  "description": "Configure on access policy for Vscan (virus scan)",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether a Vscan on Access policy is present or not",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "vserver": {
                        "type": "string",
                        "description": "the name of the data vserver to use."
                     },
                     "policy_name": {
                        "type": "string",
                        "description": "The name of the policy"
                     },
                     "file_ext_to_exclude": {
                        "type": "string",
                        "description": "File extensions for which On-Access scanning must not be performed."
                     },
                     "file_ext_to_include": {
                        "type": "string",
                        "description": "File extensions for which On-Access scanning is considered. The default value is '*', which means that all files are considered for scanning except\nthose which are excluded from scanning."
                     },
                     "filters": {
                        "type": "string",
                        "description": "A list of filters which can be used to define the scope of the On-Access policy more precisely. The filters can be added in any order. Possible values\nscan_ro_volume  Enable scans for read-only volume,\nscan_execute_access  Scan only files opened with execute-access (CIFS only)"
                     },
                     "is_scan_mandatory": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Specifies whether access to a file is allowed if there are no external virus-scanning servers available for virus scanning. It is true if not provided at the time of creating a policy."
                     },
                     "max_file_size": {
                        "type": "string",
                        "description": "Max file-size (in bytes) allowed for scanning. The default value of 2147483648 (2GB) is taken if not provided at the time of creating a policy."
                     },
                     "paths_to_exclude": {
                        "type": "string",
                        "description": "File paths for which On-Access scanning must not be performed."
                     },
                     "scan_files_with_no_ext": {
                        "type": "string",
                        "description": "Default: True\n\nSpecifies whether files without any extension are considered for scanning or not."
                     }
                  },
                  "required": [
                     "vserver",
                     "policy_name"
                  ]
               },
               "na_ontap_vscan": {
                  "type": "object",
                  "description": "Enable and Disable Vscan",
                  "properties": {
                     "enable": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nWhether to enable to disable a Vscan"
                     },
                     "vserver": {
                        "type": "string",
                        "description": "the name of the data vserver to use."
                     }
                  },
                  "required": [
                     "vserver"
                  ]
               },
               "na_ontap_volume_clone": {
                  "type": "object",
                  "description": "Create NetApp ONTAP volume clones.\nA FlexClone License is required to use this module",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether volume clone should be created.",
                        "enum": [
                           "present"
                        ]
                     },
                     "parent_volume": {
                        "type": "string",
                        "description": "The parent volume of the volume clone being created."
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the volume clone being created."
                     },
                     "volume": {
                        "type": "string",
                        "description": "The name of the volume clone being created."
                     },
                     "vserver": {
                        "type": "string",
                        "description": "Vserver in which the volume clone should be created."
                     },
                     "parent_snapshot": {
                        "type": "string",
                        "description": "Parent snapshot in which volume clone is created off."
                     },
                     "parent_vserver": {
                        "type": "string",
                        "description": "Vserver of parent volume in which clone is created off."
                     },
                     "qos_policy_group_name": {
                        "type": "string",
                        "description": "The qos-policy-group-name which should be set for volume clone."
                     },
                     "space_reserve": {
                        "type": "string",
                        "description": "The space_reserve setting which should be used for the volume clone.",
                        "enum": [
                           "volume",
                           "none"
                        ]
                     },
                     "volume_type": {
                        "type": "string",
                        "description": "The volume-type setting which should be used for the volume clone.",
                        "enum": [
                           "rw",
                           "dp"
                        ]
                     },
                     "junction_path": {
                        "type": "string",
                        "description": "Junction path of the volume."
                     },
                     "uid": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "The UNIX user ID for the clone volume."
                     },
                     "gid": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "The UNIX group ID for the clone volume."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "volume"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "volume"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "na_ontap_volume_autosize": {
                  "type": "object",
                  "description": "Modify Volume AutoSize",
                  "properties": {
                     "volume": {
                        "type": "string",
                        "description": "The name of the flexible volume for which we want to set autosize."
                     },
                     "mode": {
                        "type": "string",
                        "description": "Specify the flexible volume's autosize mode of operation.",
                        "enum": [
                           "grow",
                           "grow_shrink",
                           "off"
                        ]
                     },
                     "vserver": {
                        "type": "string",
                        "description": "Name of the vserver to use."
                     },
                     "grow_threshold_percent": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Specifies the percentage of the flexible volume's capacity at which autogrow is initiated.\nThe default grow threshold varies from 85% to 98%, depending on the volume size.\nIt is an error for the grow threshold to be less than or equal to the shrink threshold.\nRange between 0 and 100"
                     },
                     "increment_size": {
                        "type": "string",
                        "description": "Specify the flexible volume's increment size using the following format < number > [k|m|g|t]\nThe amount is the absolute size to set.\nThe trailing 'k', 'm', 'g', and 't' indicates the desired units, namely 'kilobytes', 'megabytes', 'gigabytes', and 'terabytes' (respectively)."
                     },
                     "maximum_size": {
                        "type": "string",
                        "description": "Specify the flexible volume's maximum allowed size using the following format < number > [k|m|g|t]\nThe amount is the absolute size to set.\nThe trailing 'k', 'm', 'g', and 't' indicates the desired units, namely 'kilobytes', 'megabytes', 'gigabytes', and 'terabytes' (respectively).\nThe default value is 20% greater than the volume size at the time autosize was enabled.\nIt is an error for the maximum volume size to be less than the current volume size.\nIt is also an error for the maximum size to be less than or equal to the minimum size."
                     },
                     "minimum_size": {
                        "type": "string",
                        "description": "Specify the flexible volume's minimum allowed size using the following format < number > [k|m|g|t] The amount is the absolute size to set.\nThe trailing 'k', 'm', 'g', and 't' indicates the desired units, namely 'kilobytes', 'megabytes', 'gigabytes', and 'terabytes' (respectively).\nThe default value is the size of the volume at the time the 'grow_shrink' mode was enabled.\nIt is an error for the minimum size to be greater than or equal to the maximum size."
                     },
                     "reset": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Sets the values of maximum_size, increment_size, minimum_size, grow_threshold_percent, shrink_threshold_percent and mode to their defaults"
                     },
                     "shrink_threshold_percent": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Specifies the percentage of the flexible volume's capacity at which autoshrink is initiated.\nThe default shrink threshold is 50%. It is an error for the shrink threshold to be greater than or equal to the grow threshold.\nRange between 0 and 100"
                     }
                  },
                  "required": [
                     "volume",
                     "vserver"
                  ]
               },
               "na_ontap_volume": {
                  "type": "object",
                  "description": "Create or destroy or modify volumes on NetApp ONTAP.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified volume should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the volume to manage."
                     },
                     "vserver": {
                        "type": "string",
                        "description": "Name of the vserver to use."
                     },
                     "from_name": {
                        "type": "string",
                        "description": "Name of the existing volume to be renamed to name."
                     },
                     "is_infinite": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Set True if the volume is an Infinite Volume. Deleting an infinite volume is asynchronous."
                     },
                     "is_online": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nWhether the specified volume is online, or not."
                     },
                     "aggregate_name": {
                        "type": "string",
                        "description": "The name of the aggregate the flexvol should exist on.\nRequired when C(state=present)."
                     },
                     "size": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "The size of the volume in (size_unit). Required when C(state=present)."
                     },
                     "size_unit": {
                        "type": "string",
                        "description": "Default: gb\n\nThe unit used to interpret the size parameter.",
                        "enum": [
                           "bytes",
                           "b",
                           "kb",
                           "mb",
                           "gb",
                           "tb",
                           "pb",
                           "eb",
                           "zb",
                           "yb"
                        ]
                     },
                     "type": {
                        "type": "string",
                        "description": "The volume type, either read-write (RW) or data-protection (DP)."
                     },
                     "policy": {
                        "type": "string",
                        "description": "Name of the export policy."
                     },
                     "junction_path": {
                        "type": "string",
                        "description": "Junction path of the volume.\nTo unmount, use junction path C('')."
                     },
                     "space_guarantee": {
                        "type": "string",
                        "description": "Space guarantee style for the volume.",
                        "enum": [
                           "none",
                           "file",
                           "volume"
                        ]
                     },
                     "percent_snapshot_space": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Amount of space reserved for snapshot copies of the volume."
                     },
                     "volume_security_style": {
                        "type": "string",
                        "description": "Default: mixed\n\nThe security style associated with this volume.",
                        "enum": [
                           "mixed",
                           "ntfs",
                           "unified",
                           "unix"
                        ]
                     },
                     "encrypt": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether or not to enable Volume Encryption."
                     },
                     "efficiency_policy": {
                        "type": "string",
                        "description": "Allows a storage efficiency policy to be set on volume creation."
                     },
                     "unix_permissions": {
                        "type": "string",
                        "description": "Unix permission bits in octal or symbolic format.\nFor example, 0 is equivalent to ------------, 777 is equivalent to ---rwxrwxrwx,both formats are accepted.\nThe valid octal value ranges between 0 and 777 inclusive."
                     },
                     "snapshot_policy": {
                        "type": "string",
                        "description": "The name of the snapshot policy.\nthe default policy name is 'default'."
                     },
                     "aggr_list": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "an array of names of aggregates to be used for FlexGroup constituents."
                     },
                     "aggr_list_multiplier": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "The number of times to iterate over the aggregates listed with the aggr_list parameter when creating a FlexGroup."
                     },
                     "auto_provision_as": {
                        "type": "string",
                        "description": "Automatically provision a FlexGroup volume.",
                        "enum": [
                           "flexgroup"
                        ]
                     },
                     "snapdir_access": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "This is an advanced option, the default is False.\nEnable the visible '.snapshot' directory that is normally present at system internal mount points.\nThis value also turns on access to all other '.snapshot' directories in the volume."
                     },
                     "atime_update": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "This is an advanced option, the default is True.\nIf false, prevent the update of inode access times when a file is read.\nThis value is useful for volumes with extremely high read traffic, since it prevents writes to the inode file for the volume from contending with reads from other files.\nThis field should be used carefully.\nThat is, use this field when you know in advance that the correct access time for inodes will not be needed for files on that volume."
                     },
                     "wait_for_completion": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Set this parameter to 'true' for synchronous execution during create (wait until volume status is online)\nSet this parameter to 'false' for asynchronous execution\nFor asynchronous, execution exits as soon as the request is sent, without checking volume status"
                     },
                     "time_out": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 180\n\ntime to wait for flexGroup creation, modification, or deletion in seconds.\nError out if task is not completed in defined time.\nif 0, the request is asynchronous.\ndefault is set to 3 minutes."
                     },
                     "language": {
                        "type": "string",
                        "description": "Language to use for Volume\nDefault uses SVM language\nPossible values   Language\nc                 POSIX\nar                Arabic\ncs                Czech\nda                Danish\nde                German\nen                English\nen_us             English (US)\nes                Spanish\nfi                Finnish\nfr                French\nhe                Hebrew\nhr                Croatian\nhu                Hungarian\nit                Italian\nja                Japanese euc-j\nja_v1             Japanese euc-j\nja_jp.pck         Japanese PCK (sjis)\nja_jp.932         Japanese cp932\nja_jp.pck_v2      Japanese PCK (sjis)\nko                Korean\nno                Norwegian\nnl                Dutch\npl                Polish\npt                Portuguese\nro                Romanian\nru                Russian\nsk                Slovak\nsl                Slovenian\nsv                Swedish\ntr                Turkish\nzh                Simplified Chinese\nzh.gbk            Simplified Chinese (GBK)\nzh_tw             Traditional Chinese euc-tw\nzh_tw.big5        Traditional Chinese Big 5\nTo use UTF-8 as the NFS character set, append '.UTF-8' to the language code"
                     },
                     "qos_policy_group": {
                        "type": "string",
                        "description": "Specifies a QoS policy group to be set on volume."
                     },
                     "qos_adaptive_policy_group": {
                        "type": "string",
                        "description": "Specifies a QoS adaptive policy group to be set on volume."
                     },
                     "tiering_policy": {
                        "type": "string",
                        "description": "The tiering policy that is to be associated with the volume.\nThis policy decides whether the blocks of a volume will be tiered to the capacity tier.\nsnapshot-only policy allows tiering of only the volume snapshot copies not associated with the active file system.\nauto policy allows tiering of both snapshot and active file system user data to the capacity tier.\nbackup policy on DP volumes allows all transferred user data blocks to start in the capacity tier.\nWhen set to none, the Volume blocks will not be tiered to the capacity tier.\nIf no value specified, the volume is assigned snapshot only by default.",
                        "enum": [
                           "snapshot-only",
                           "auto",
                           "backup",
                           "none"
                        ]
                     },
                     "space_slo": {
                        "type": "string",
                        "description": "Specifies the space SLO type for the volume. The space SLO type is the Service Level Objective for space management for the volume.\nThe space SLO value is used to enforce existing volume settings so that sufficient space is set aside on the aggregate to meet the space SLO.\nThis parameter is not supported on Infinite Volumes.",
                        "enum": [
                           "none",
                           "thick",
                           "semi-thick"
                        ]
                     },
                     "nvfail_enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "If true, the controller performs additional work at boot and takeover times if it finds that there has been any potential data loss in the volume's constituents due to an NVRAM failure.\nThe volume's constituents would be put in a special state called 'in-nvfailed-state' such that protocol access is blocked.\nThis will cause the client applications to crash and thus prevent access to stale data.\nTo get out of this situation, the admin needs to manually clear the 'in-nvfailed-state' on the volume's constituents."
                     },
                     "vserver_dr_protection": {
                        "type": "string",
                        "description": "Specifies the protection type for the volume in a Vserver DR setup.",
                        "enum": [
                           "protected",
                           "unprotected"
                        ]
                     },
                     "comment": {
                        "type": "string",
                        "description": "Sets a comment associated with the volume."
                     }
                  },
                  "required": [
                     "name",
                     "vserver"
                  ]
               },
               "na_ontap_user_role": {
                  "type": "object",
                  "description": "Create or destroy user roles",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified user should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the role to manage."
                     },
                     "command_directory_name": {
                        "type": "string",
                        "description": "The command or command directory to which the role has an access."
                     },
                     "access_level": {
                        "type": "string",
                        "description": "Default: all\n\nThe name of the role to manage.",
                        "enum": [
                           "none",
                           "readonly",
                           "all"
                        ]
                     },
                     "query": {
                        "type": "string",
                        "description": "A query for the role. The query must apply to the specified command or directory name.\nUse double quotes \"\" for modifying a existing query to none."
                     },
                     "vserver": {
                        "type": "string",
                        "description": "The name of the vserver to use."
                     }
                  },
                  "required": [
                     "name",
                     "command_directory_name",
                     "vserver"
                  ]
               },
               "na_ontap_user": {
                  "type": "object",
                  "description": "Create or destroy users.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified user should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the user to manage."
                     },
                     "applications": {
                        "type": "array",
                        "description": "List of application to grant access to."
                     },
                     "application": {
                        "type": "array",
                        "description": "List of application to grant access to."
                     },
                     "authentication_method": {
                        "type": "string",
                        "description": "Authentication method for the application.\nNot all authentication methods are valid for an application.\nValid authentication methods for each application are as denoted in I(authentication_choices_description).\nPassword for console application\nPassword, domain, nsswitch, cert for http application.\nPassword, domain, nsswitch, cert for ontapi application.\nCommunity for snmp application (when creating SNMPv1 and SNMPv2 users).\nThe usm and community for snmp application (when creating SNMPv3 users).\nPassword for sp application.\nPassword for rsh application.\nPassword for telnet application.\nPassword, publickey, domain, nsswitch for ssh application.",
                        "enum": [
                           "community",
                           "password",
                           "publickey",
                           "domain",
                           "nsswitch",
                           "usm",
                           "cert"
                        ]
                     },
                     "set_password": {
                        "type": "string",
                        "description": "Password for the user account.\nIt is ignored for creating snmp users, but is required for creating non-snmp users.\nFor an existing user, this value will be used as the new password."
                     },
                     "role_name": {
                        "type": "string",
                        "description": "The name of the role. Required when C(state=present)"
                     },
                     "lock_user": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether the specified user account is locked."
                     },
                     "vserver": {
                        "type": "string",
                        "description": "The name of the vserver to use."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "applications",
                                    "application"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "applications"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "application"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "na_ontap_unix_user": {
                  "type": "object",
                  "description": "Create, delete or modify UNIX users local to ONTAP.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified user should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "Specifies user's UNIX account name.\nNon-modifiable."
                     },
                     "group_id": {
                        "type": "string",
                        "description": "Specifies the primary group identification number for the UNIX user\nRequired for create, modifiable."
                     },
                     "vserver": {
                        "type": "string",
                        "description": "Specifies the Vserver for the UNIX user.\nNon-modifiable."
                     },
                     "id": {
                        "type": "string",
                        "description": "Specifies an identification number for the UNIX user.\nRequired for create, modifiable."
                     },
                     "full_name": {
                        "type": "string",
                        "description": "Specifies the full name of the UNIX user\nOptional for create, modifiable."
                     }
                  },
                  "required": [
                     "name",
                     "vserver"
                  ]
               },
               "na_ontap_unix_group": {
                  "type": "object",
                  "description": "Create/Delete Unix user group",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified group should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "Specifies UNIX group's name, unique for each group.\nNon-modifiable."
                     },
                     "id": {
                        "type": "string",
                        "description": "Specifies an identification number for the UNIX group.\nGroup ID is unique for each UNIX group.\nRequired for create, modifiable."
                     },
                     "vserver": {
                        "type": "string",
                        "description": "Specifies the Vserver for the UNIX group.\nNon-modifiable."
                     },
                     "skip_name_validation": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Specifies if group name validation is skipped."
                     },
                     "users": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Specifies the users associated with this group. Should be comma separated.\nIt represents the expected state of a list of users at any time.\nAdd a user into group if it is specified in expected state but not in current state.\nDelete a user from group if it is specified in current state but not in expected state.\nTo delete all current users, use '' as value."
                     }
                  },
                  "required": [
                     "name",
                     "vserver"
                  ]
               },
               "na_ontap_ucadapter": {
                  "type": "object",
                  "description": "modify the UC adapter mode and type taking pending type and mode into account.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified adapter should exist.",
                        "enum": [
                           "present"
                        ]
                     },
                     "adapter_name": {
                        "type": "string",
                        "description": "Specifies the adapter name."
                     },
                     "node_name": {
                        "type": "string",
                        "description": "Specifies the adapter home node."
                     },
                     "mode": {
                        "type": "string",
                        "description": "Specifies the mode of the adapter."
                     },
                     "type": {
                        "type": "string",
                        "description": "Specifies the fc4 type of the adapter."
                     }
                  },
                  "required": [
                     "adapter_name",
                     "node_name"
                  ]
               },
               "na_ontap_svm_options": {
                  "type": "object",
                  "description": "Modify ONTAP SVM Options\nOnly Options that appear on \"vserver options show\" can be set",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the option."
                     },
                     "value": {
                        "type": "string",
                        "description": "Value of the option.\nValue must be in quote"
                     },
                     "vserver": {
                        "type": "string",
                        "description": "The name of the vserver to which this option belongs to."
                     }
                  },
                  "required": [
                     "vserver"
                  ]
               },
               "na_ontap_svm": {
                  "type": "object",
                  "description": "Create, modify or delete SVM on NetApp ONTAP",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified SVM should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the SVM to manage."
                     },
                     "from_name": {
                        "type": "string",
                        "description": "Name of the SVM to be renamed"
                     },
                     "root_volume": {
                        "type": "string",
                        "description": "Root volume of the SVM.\nCannot be modified after creation."
                     },
                     "root_volume_aggregate": {
                        "type": "string",
                        "description": "The aggregate on which the root volume will be created.\nCannot be modified after creation."
                     },
                     "root_volume_security_style": {
                        "type": "string",
                        "description": "Security Style of the root volume.\nWhen specified as part of the vserver-create, this field represents the security style for the Vserver root volume.\nWhen specified as part of vserver-get-iter call, this will return the list of matching Vservers.\nThe 'unified' security style, which applies only to Infinite Volumes, cannot be applied to a Vserver's root volume.\nCannot be modified after creation.",
                        "enum": [
                           "unix",
                           "ntfs",
                           "mixed",
                           "unified"
                        ]
                     },
                     "allowed_protocols": {
                        "type": "string",
                        "description": "Allowed Protocols.\nWhen specified as part of a vserver-create, this field represent the list of protocols allowed on the Vserver.\nWhen part of vserver-get-iter call, this will return the list of Vservers which have any of the protocols specified as part of the allowed-protocols.\nWhen part of vserver-modify, this field should include the existing list along with new protocol list to be added to prevent data disruptions.\nPossible values\nnfs   NFS protocol,\ncifs   CIFS protocol,\nfcp   FCP protocol,\niscsi   iSCSI protocol,\nndmp   NDMP protocol,\nhttp   HTTP protocol,\nnvme   NVMe protocol"
                     },
                     "aggr_list": {
                        "type": "array",
                        "description": "List of aggregates assigned for volume operations.\nThese aggregates could be shared for use with other Vservers.\nWhen specified as part of a vserver-create, this field represents the list of aggregates that are assigned to the Vserver for volume operations.\nWhen part of vserver-get-iter call, this will return the list of Vservers which have any of the aggregates specified as part of the aggr list."
                     },
                     "ipspace": {
                        "type": "string",
                        "description": "IPSpace name\nCannot be modified after creation."
                     },
                     "snapshot_policy": {
                        "type": "string",
                        "description": "Default snapshot policy setting for all volumes of the Vserver. This policy will be assigned to all volumes created in this Vserver unless the volume create request explicitly provides a snapshot policy or volume is modified later with a specific snapshot policy. A volume-level snapshot policy always overrides the default Vserver-wide snapshot policy."
                     },
                     "language": {
                        "type": "string",
                        "description": "Language to use for the SVM\nDefault to C.UTF-8\nPossible values   Language\nc                 POSIX\nar                Arabic\ncs                Czech\nda                Danish\nde                German\nen                English\nen_us             English (US)\nes                Spanish\nfi                Finnish\nfr                French\nhe                Hebrew\nhr                Croatian\nhu                Hungarian\nit                Italian\nja                Japanese euc-j\nja_v1             Japanese euc-j\nja_jp.pck         Japanese PCK (sjis)\nja_jp.932         Japanese cp932\nja_jp.pck_v2      Japanese PCK (sjis)\nko                Korean\nno                Norwegian\nnl                Dutch\npl                Polish\npt                Portuguese\nro                Romanian\nru                Russian\nsk                Slovak\nsl                Slovenian\nsv                Swedish\ntr                Turkish\nzh                Simplified Chinese\nzh.gbk            Simplified Chinese (GBK)\nzh_tw             Traditional Chinese euc-tw\nzh_tw.big5        Traditional Chinese Big 5"
                     },
                     "subtype": {
                        "type": "string",
                        "description": "The subtype for vserver to be created.\nCannot be modified after creation.",
                        "enum": [
                           "default",
                           "dp_destination",
                           "sync_source",
                           "sync_destination"
                        ]
                     },
                     "comment": {
                        "type": "string",
                        "description": "When specified as part of a vserver-create, this field represents the comment associated with the Vserver.\nWhen part of vserver-get-iter call, this will return the list of matching Vservers."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "na_ontap_software_update": {
                  "type": "object",
                  "description": "Update ONTAP software\nRequires an https connection and is not supported over http",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified ONTAP package should update or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "nodes": {
                        "type": "array",
                        "description": "List of nodes to be updated, the nodes have to be a part of a HA Pair."
                     },
                     "node": {
                        "type": "array",
                        "description": "List of nodes to be updated, the nodes have to be a part of a HA Pair."
                     },
                     "package_version": {
                        "type": "string",
                        "description": "Specifies the package version to update software."
                     },
                     "package_url": {
                        "type": "string",
                        "description": "Specifies the package URL to download the package."
                     },
                     "ignore_validation_warning": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Allows the update to continue if warnings are encountered during the validation phase."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "nodes",
                                    "node"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "na_ontap_snmp": {
                  "type": "object",
                  "description": "Create/Delete SNMP community",
                  "properties": {
                     "access_control": {
                        "type": "string",
                        "description": "Access control for the community. The only supported value is 'ro' (read-only)"
                     },
                     "community_name": {
                        "type": "string",
                        "description": "The name of the SNMP community to manage."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified SNMP community should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     }
                  },
                  "required": [
                     "access_control",
                     "community_name"
                  ]
               },
               "na_ontap_snapshot_policy": {
                  "type": "object",
                  "description": "Create/Modify/Delete ONTAP snapshot policies",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIf you want to create, modify or delete a snapshot policy.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "Name of the snapshot policy to be managed. The maximum string length is 256 characters."
                     },
                     "enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Status of the snapshot policy indicating whether the policy will be enabled or disabled."
                     },
                     "comment": {
                        "type": "string",
                        "description": "A human readable comment attached with the snapshot. The size of the comment can be at most 255 characters."
                     },
                     "count": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Retention count for the snapshots created by the schedule."
                     },
                     "schedule": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Schedule to be added inside the policy."
                     },
                     "snapmirror_label": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "SnapMirror label assigned to each schedule inside the policy. Use an empty string ('') for no label."
                     },
                     "vserver": {
                        "type": "string",
                        "description": "The name of the vserver to use. In a multi-tenanted environment, assigning a Snapshot Policy to a vserver will restrict its use to that vserver."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "na_ontap_snapshot": {
                  "type": "object",
                  "description": "Create/Modify/Delete ONTAP snapshots",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIf you want to create/modify a snapshot, or delete it.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "snapshot": {
                        "type": "string",
                        "description": "Name of the snapshot to be managed. The maximum string length is 256 characters."
                     },
                     "from_name": {
                        "type": "string",
                        "description": "Name of the existing snapshot to be renamed to."
                     },
                     "volume": {
                        "type": "string",
                        "description": "Name of the volume on which the snapshot is to be created."
                     },
                     "async_bool": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "If true, the snapshot is to be created asynchronously."
                     },
                     "comment": {
                        "type": "string",
                        "description": "A human readable comment attached with the snapshot. The size of the comment can be at most 255 characters."
                     },
                     "snapmirror_label": {
                        "type": "string",
                        "description": "A human readable SnapMirror Label attached with the snapshot. Size of the label can be at most 31 characters."
                     },
                     "ignore_owners": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "if this field is true, snapshot will be deleted even if some other processes are accessing it."
                     },
                     "snapshot_instance_uuid": {
                        "type": "string",
                        "description": "The 128 bit unique snapshot identifier expressed in the form of UUID."
                     },
                     "vserver": {
                        "type": "string",
                        "description": "The Vserver name"
                     }
                  },
                  "required": [
                     "snapshot",
                     "volume",
                     "vserver"
                  ]
               },
               "na_ontap_snapmirror": {
                  "type": "object",
                  "description": "Create/Delete/Initialize SnapMirror volume/vserver relationships for ONTAP/ONTAP\nCreate/Delete/Initialize SnapMirror volume relationship between ElementSW and ONTAP\nModify schedule for a SnapMirror relationship for ONTAP/ONTAP and ElementSW/ONTAP\nPre-requisite for ElementSW to ONTAP relationship or vice-versa is an established SnapMirror endpoint for ONTAP cluster with ElementSW UI\nPre-requisite for ElementSW to ONTAP relationship or vice-versa is to have SnapMirror enabled in the ElementSW volume\nFor creating a SnapMirror ElementSW/ONTAP relationship, an existing ONTAP/ElementSW relationship should be present",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified relationship should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "source_volume": {
                        "type": "string",
                        "description": "Specifies the name of the source volume for the SnapMirror."
                     },
                     "destination_volume": {
                        "type": "string",
                        "description": "Specifies the name of the destination volume for the SnapMirror."
                     },
                     "source_vserver": {
                        "type": "string",
                        "description": "Name of the source vserver for the SnapMirror."
                     },
                     "destination_vserver": {
                        "type": "string",
                        "description": "Name of the destination vserver for the SnapMirror."
                     },
                     "source_path": {
                        "type": "string",
                        "description": "Specifies the source endpoint of the SnapMirror relationship.\nIf the source is an ONTAP volume, format should be <[vserver:][volume]> or <[[cluster:]//vserver/]volume>\nIf the source is an ElementSW volume, format should be <[Element_SVIP]:/lun/[Element_VOLUME_ID]>\nIf the source is an ElementSW volume, the volume should have SnapMirror enabled."
                     },
                     "destination_path": {
                        "type": "string",
                        "description": "Specifies the destination endpoint of the SnapMirror relationship."
                     },
                     "relationship_type": {
                        "type": "string",
                        "description": "Specify the type of SnapMirror relationship.",
                        "enum": [
                           "data_protection",
                           "load_sharing",
                           "vault",
                           "restore",
                           "transition_data_protection",
                           "extended_data_protection"
                        ]
                     },
                     "schedule": {
                        "type": "string",
                        "description": "Specify the name of the current schedule, which is used to update the SnapMirror relationship.\nOptional for create, modifiable."
                     },
                     "policy": {
                        "type": "string",
                        "description": "Specify the name of the SnapMirror policy that applies to this relationship."
                     },
                     "source_hostname": {
                        "type": "string",
                        "description": "Source hostname or management IP address for ONTAP or ElementSW cluster.\nRequired for SnapMirror delete"
                     },
                     "source_username": {
                        "type": "string",
                        "description": "Source username for ONTAP or ElementSW cluster.\nOptional if this is same as destination username."
                     },
                     "source_password": {
                        "type": "string",
                        "description": "Source password for ONTAP or ElementSW cluster.\nOptional if this is same as destination password."
                     },
                     "connection_type": {
                        "type": "string",
                        "description": "Default: ontap_ontap\n\nType of SnapMirror relationship.\nPre-requisite for either elementsw_ontap or ontap_elementsw the ElementSW volume should have enableSnapmirror option set to true.\nFor using ontap_elementsw, elementsw_ontap snapmirror relationship should exist.",
                        "enum": [
                           "ontap_ontap",
                           "elementsw_ontap",
                           "ontap_elementsw"
                        ]
                     },
                     "max_transfer_rate": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Specifies the upper bound, in kilobytes per second, at which data is transferred.\nDefault is unlimited, it can be explicitly set to 0 as unlimited."
                     },
                     "identity_preserve": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Specifies whether or not the identity of the source Vserver is replicated to the destination Vserver.\nIf this parameter is set to true, the source Vserver's configuration will additionally be replicated to the destination.\nIf the parameter is set to false, then only the source Vserver's volumes and RBAC configuration are replicated to the destination."
                     }
                  }
               },
               "na_ontap_service_processor_network": {
                  "type": "object",
                  "description": "Modify a ONTAP service processor network",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified service processor network should exist or not.",
                        "enum": [
                           "present"
                        ]
                     },
                     "address_type": {
                        "type": "string",
                        "description": "Specify address class.",
                        "enum": [
                           "ipv4",
                           "ipv6"
                        ]
                     },
                     "is_enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Specify whether to enable or disable the service processor network."
                     },
                     "node": {
                        "type": "string",
                        "description": "The node where the service processor network should be enabled"
                     },
                     "dhcp": {
                        "type": "string",
                        "description": "Specify dhcp type.",
                        "enum": [
                           "v4",
                           "none"
                        ]
                     },
                     "gateway_ip_address": {
                        "type": "string",
                        "description": "Specify the gateway ip."
                     },
                     "ip_address": {
                        "type": "string",
                        "description": "Specify the service processor ip address."
                     },
                     "netmask": {
                        "type": "string",
                        "description": "Specify the service processor netmask."
                     },
                     "prefix_length": {
                        "type": "string",
                        "description": "Specify the service processor prefix_length."
                     },
                     "wait_for_completion": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Set this parameter to 'true' for synchronous execution (wait until SP status is successfully updated)\nSet this parameter to 'false' for asynchronous execution\nFor asynchronous, execution exits as soon as the request is sent, without checking SP status"
                     }
                  },
                  "required": [
                     "address_type",
                     "is_enabled",
                     "node"
                  ]
               },
               "na_ontap_security_key_manager": {
                  "type": "object",
                  "description": "Add or delete or setup key management on NetApp ONTAP.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified key manager should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "ip_address": {
                        "type": "string",
                        "description": "The IP address of the key management server."
                     },
                     "tcp_port": {
                        "type": "string",
                        "description": "Default: 5696\n\nThe TCP port on which the key management server listens for incoming connections."
                     },
                     "node": {
                        "type": "string",
                        "description": "The node which key management server runs on."
                     }
                  },
                  "required": [
                     "ip_address"
                  ]
               },
               "na_ontap_quotas": {
                  "type": "object",
                  "description": "Set/Modify/Delete quota on ONTAP",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified quota should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "vserver": {
                        "type": "string",
                        "description": "Name of the vserver to use."
                     },
                     "volume": {
                        "type": "string",
                        "description": "The name of the volume that the quota resides on."
                     },
                     "quota_target": {
                        "type": "string",
                        "description": "The quota target of the type specified."
                     },
                     "qtree": {
                        "type": "string",
                        "description": "Name of the qtree for the quota.\nFor user or group rules, it can be the qtree name or \"\" if no qtree.\nFor tree type rules, this field must be \"\"."
                     },
                     "type": {
                        "type": "string",
                        "description": "The type of quota rule",
                        "enum": [
                           "user",
                           "group",
                           "tree"
                        ]
                     },
                     "policy": {
                        "type": "string",
                        "description": "Name of the quota policy from which the quota rule should be obtained."
                     },
                     "set_quota_status": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether the specified volume should have quota status on or off."
                     },
                     "file_limit": {
                        "type": "string",
                        "description": "Default: -\n\nThe number of files that the target can have."
                     },
                     "disk_limit": {
                        "type": "string",
                        "description": "Default: -\n\nThe amount of disk space that is reserved for the target."
                     },
                     "threshold": {
                        "type": "string",
                        "description": "Default: -\n\nThe amount of disk space the target would have to exceed before a message is logged."
                     }
                  },
                  "required": [
                     "vserver",
                     "volume",
                     "quota_target",
                     "type"
                  ]
               },
               "na_ontap_qtree": {
                  "type": "object",
                  "description": "Create or destroy Qtrees.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified qtree should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the qtree to manage."
                     },
                     "from_name": {
                        "type": "string",
                        "description": "Name of the qtree to be renamed."
                     },
                     "flexvol_name": {
                        "type": "string",
                        "description": "The name of the FlexVol the qtree should exist on. Required when C(state=present)."
                     },
                     "vserver": {
                        "type": "string",
                        "description": "The name of the vserver to use."
                     },
                     "export_policy": {
                        "type": "string",
                        "description": "The name of the export policy to apply."
                     },
                     "security_style": {
                        "type": "string",
                        "description": "The security style for the qtree.",
                        "enum": [
                           "unix",
                           "ntfs",
                           "mixed"
                        ]
                     },
                     "oplocks": {
                        "type": "string",
                        "description": "Whether the oplocks should be enabled or not for the qtree.",
                        "enum": [
                           "enabled",
                           "disabled"
                        ]
                     },
                     "unix_permissions": {
                        "type": "string",
                        "description": "File permissions bits of the qtree."
                     }
                  },
                  "required": [
                     "name",
                     "flexvol_name",
                     "vserver"
                  ]
               },
               "na_ontap_qos_policy_group": {
                  "type": "object",
                  "description": "Create, destroy, modify, or rename QoS policy group on NetApp ONTAP.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified policy group should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the policy group to manage."
                     },
                     "vserver": {
                        "type": "string",
                        "description": "Name of the vserver to use."
                     },
                     "from_name": {
                        "type": "string",
                        "description": "Name of the existing policy group to be renamed to name."
                     },
                     "max_throughput": {
                        "type": "string",
                        "description": "Maximum throughput defined by this policy."
                     },
                     "min_throughput": {
                        "type": "string",
                        "description": "Minimum throughput defined by this policy."
                     },
                     "force": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Setting to 'true' forces the deletion of the workloads associated with the policy group along with the policy group."
                     }
                  }
               },
               "na_ontap_qos_adaptive_policy_group": {
                  "type": "object",
                  "description": "Create, destroy, modify, or rename an Adaptive QoS policy group on NetApp ONTAP. Module is based on the standard QoS policy group module.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified policy group should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the policy group to manage."
                     },
                     "vserver": {
                        "type": "string",
                        "description": "Name of the vserver to use."
                     },
                     "from_name": {
                        "type": "string",
                        "description": "Name of the existing policy group to be renamed to name."
                     },
                     "absolute_min_iops": {
                        "type": "string",
                        "description": "Absolute minimum IOPS defined by this policy."
                     },
                     "expected_iops": {
                        "type": "string",
                        "description": "Minimum expected IOPS defined by this policy."
                     },
                     "peak_iops": {
                        "type": "string",
                        "description": "Maximum possible IOPS per allocated or used TB|GB."
                     },
                     "peak_iops_allocation": {
                        "type": "string",
                        "description": "Default: used_space\n\nWhether peak_iops is specified by allocated or used space.",
                        "enum": [
                           "allocated_space",
                           "used_space"
                        ]
                     },
                     "force": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Setting to 'true' forces the deletion of the workloads associated with the policy group along with the policy group."
                     }
                  },
                  "required": [
                     "name",
                     "vserver"
                  ]
               },
               "na_ontap_portset": {
                  "type": "object",
                  "description": "Create/Delete ONTAP portset, modify ports in a portset.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIf you want to create a portset."
                     },
                     "vserver": {
                        "type": "string",
                        "description": "Name of the SVM."
                     },
                     "name": {
                        "type": "string",
                        "description": "Name of the port set to create."
                     },
                     "type": {
                        "type": "string",
                        "description": "Required for create.\nProtocols accepted for this portset.",
                        "enum": [
                           "fcp",
                           "iscsi",
                           "mixed"
                        ]
                     },
                     "force": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "If 'false' or not specified, the request will fail if there are any igroups bound to this portset.\nIf 'true', forcibly destroy the portset, even if there are existing igroup bindings."
                     },
                     "ports": {
                        "type": "string",
                        "description": "Specify the ports associated with this portset. Should be comma separated.\nIt represents the expected state of a list of ports at any time, and replaces the current value of ports.\nAdds a port if it is specified in expected state but not in current state.\nDeletes a port if it is in current state but not in expected state."
                     }
                  },
                  "required": [
                     "vserver",
                     "name"
                  ]
               },
               "na_ontap_ports": {
                  "type": "object",
                  "description": "Add or remove ports for broadcast domain and portset.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified port should be added or removed.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "vserver": {
                        "type": "string",
                        "description": "Name of the SVM.\nSpecify this option when operating on portset."
                     },
                     "names": {
                        "type": "array",
                        "description": "List of ports."
                     },
                     "resource_name": {
                        "type": "string",
                        "description": "name of the portset or broadcast domain."
                     },
                     "resource_type": {
                        "type": "string",
                        "description": "type of the resource to add a port to or remove a port from.",
                        "enum": [
                           "broadcast_domain",
                           "portset"
                        ]
                     },
                     "ipspace": {
                        "type": "string",
                        "description": "Specify the required ipspace for the broadcast domain.\nA domain ipspace can not be modified after the domain has been created."
                     },
                     "portset_type": {
                        "type": "string",
                        "description": "Protocols accepted for portset.",
                        "enum": [
                           "fcp",
                           "iscsi",
                           "mixed"
                        ]
                     }
                  },
                  "required": [
                     "names",
                     "resource_name",
                     "resource_type"
                  ]
               },
               "na_ontap_object_store": {
                  "type": "object",
                  "description": "Create or delete object store config on ONTAP.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified object store config should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the object store config to manage."
                     },
                     "provider_type": {
                        "type": "string",
                        "description": "The name of the object store config provider."
                     },
                     "server": {
                        "type": "string",
                        "description": "Fully qualified domain name of the object store config."
                     },
                     "container": {
                        "type": "string",
                        "description": "Data bucket/container name used in S3 requests."
                     },
                     "access_key": {
                        "type": "string",
                        "description": "Access key ID for AWS_S3 and SGWS provider types."
                     },
                     "secret_password": {
                        "type": "string",
                        "description": "Secret access key for AWS_S3 and SGWS provider types."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "na_ontap_nvme_subsystem": {
                  "type": "object",
                  "description": "Create/Delete NVME subsystem\nAssociate(modify) host/map to NVME subsystem\nNVMe service should be existing in the data vserver with NVMe protocol as a pre-requisite",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified subsystem should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "vserver": {
                        "type": "string",
                        "description": "Name of the vserver to use."
                     },
                     "subsystem": {
                        "type": "string",
                        "description": "Specifies the subsystem"
                     },
                     "ostype": {
                        "type": "string",
                        "description": "Specifies the ostype for initiators",
                        "enum": [
                           "windows",
                           "linux",
                           "vmware",
                           "xen",
                           "hyper_v"
                        ]
                     },
                     "skip_host_check": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Skip host check\nRequired to delete an NVMe Subsystem with attached NVMe namespaces"
                     },
                     "skip_mapped_check": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Skip mapped namespace check\nRequired to delete an NVMe Subsystem with attached NVMe namespaces"
                     },
                     "hosts": {
                        "type": "array",
                        "description": "List of host NQNs (NVMe Qualification Name) associated to the controller."
                     },
                     "paths": {
                        "type": "array",
                        "description": "List of Namespace paths to be associated with the subsystem."
                     }
                  },
                  "required": [
                     "vserver",
                     "subsystem"
                  ]
               },
               "na_ontap_nvme_namespace": {
                  "type": "object",
                  "description": "Create/Delete NVME namespace",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified namespace should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "vserver": {
                        "type": "string",
                        "description": "Name of the vserver to use."
                     },
                     "ostype": {
                        "type": "string",
                        "description": "Specifies the ostype for initiators",
                        "enum": [
                           "windows",
                           "linux",
                           "vmware",
                           "xen",
                           "hyper_v"
                        ]
                     },
                     "size": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Size in bytes. Range is [0..2^63-1]."
                     },
                     "path": {
                        "type": "string",
                        "description": "Namespace path."
                     }
                  },
                  "required": [
                     "vserver"
                  ]
               },
               "na_ontap_nvme": {
                  "type": "object",
                  "description": "Create/Delete NVMe Service",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified NVMe should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "vserver": {
                        "type": "string",
                        "description": "Name of the vserver to use."
                     },
                     "status_admin": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether the status of NVMe should be up or down"
                     }
                  },
                  "required": [
                     "vserver"
                  ]
               },
               "na_ontap_ntp": {
                  "type": "object",
                  "description": "Create or delete or modify NTP server in ONTAP",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified NTP server should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "server_name": {
                        "type": "string",
                        "description": "The name of the NTP server to manage."
                     },
                     "version": {
                        "type": "string",
                        "description": "Default: auto\n\ngive version for NTP server",
                        "enum": [
                           "auto",
                           "3",
                           "4"
                        ]
                     }
                  },
                  "required": [
                     "server_name"
                  ]
               },
               "na_ontap_node": {
                  "type": "object",
                  "description": "Rename an ONTAP node.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The new name for the node"
                     },
                     "from_name": {
                        "type": "string",
                        "description": "The name of the node to be renamed.  If I(name) already exists, no action will be performed."
                     }
                  },
                  "required": [
                     "name",
                     "from_name"
                  ]
               },
               "na_ontap_nfs": {
                  "type": "object",
                  "description": "Enable or disable NFS on ONTAP",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether NFS should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "service_state": {
                        "type": "string",
                        "description": "Whether the specified NFS should be enabled or disabled. Creates NFS service if does not exist.",
                        "enum": [
                           "started",
                           "stopped"
                        ]
                     },
                     "vserver": {
                        "type": "string",
                        "description": "Name of the vserver to use."
                     },
                     "nfsv3": {
                        "type": "string",
                        "description": "status of NFSv3.",
                        "enum": [
                           "enabled",
                           "disabled"
                        ]
                     },
                     "nfsv3_fsid_change": {
                        "type": "string",
                        "description": "status of if NFSv3 clients see change in FSID as they traverse filesystems.",
                        "enum": [
                           "enabled",
                           "disabled"
                        ]
                     },
                     "nfsv4_fsid_change": {
                        "type": "string",
                        "description": "status of if NFSv4 clients see change in FSID as they traverse filesystems.",
                        "enum": [
                           "enabled",
                           "disabled"
                        ]
                     },
                     "nfsv4": {
                        "type": "string",
                        "description": "status of NFSv4.",
                        "enum": [
                           "enabled",
                           "disabled"
                        ]
                     },
                     "nfsv41": {
                        "type": "string",
                        "description": "status of NFSv41.",
                        "enum": [
                           "enabled",
                           "disabled"
                        ]
                     },
                     "nfsv4.1": {
                        "type": "string",
                        "description": "status of NFSv41.",
                        "enum": [
                           "enabled",
                           "disabled"
                        ]
                     },
                     "nfsv41_pnfs": {
                        "type": "string",
                        "description": "status of NFSv41 pNFS.",
                        "enum": [
                           "enabled",
                           "disabled"
                        ]
                     },
                     "nfsv4_numeric_ids": {
                        "type": "string",
                        "description": "status of NFSv4 numeric ID's.",
                        "enum": [
                           "enabled",
                           "disabled"
                        ]
                     },
                     "vstorage_state": {
                        "type": "string",
                        "description": "status of vstorage_state.",
                        "enum": [
                           "enabled",
                           "disabled"
                        ]
                     },
                     "nfsv4_id_domain": {
                        "type": "string",
                        "description": "Name of the nfsv4_id_domain to use."
                     },
                     "nfsv40_acl": {
                        "type": "string",
                        "description": "status of NFS v4.0 ACL feature",
                        "enum": [
                           "enabled",
                           "disabled"
                        ]
                     },
                     "nfsv40_read_delegation": {
                        "type": "string",
                        "description": "status for NFS v4.0 read delegation feature.",
                        "enum": [
                           "enabled",
                           "disabled"
                        ]
                     },
                     "nfsv40_write_delegation": {
                        "type": "string",
                        "description": "status for NFS v4.0 write delegation feature.",
                        "enum": [
                           "enabled",
                           "disabled"
                        ]
                     },
                     "nfsv41_acl": {
                        "type": "string",
                        "description": "status of NFS v4.1 ACL feature",
                        "enum": [
                           "enabled",
                           "disabled"
                        ]
                     },
                     "nfsv41_read_delegation": {
                        "type": "string",
                        "description": "status for NFS v4.1 read delegation feature.",
                        "enum": [
                           "enabled",
                           "disabled"
                        ]
                     },
                     "nfsv41_write_delegation": {
                        "type": "string",
                        "description": "status for NFS v4.1 write delegation feature.",
                        "enum": [
                           "enabled",
                           "disabled"
                        ]
                     },
                     "nfsv40_referrals": {
                        "type": "string",
                        "description": "status for NFS v4.0 referrals.",
                        "enum": [
                           "enabled",
                           "disabled"
                        ]
                     },
                     "nfsv41_referrals": {
                        "type": "string",
                        "description": "status for NFS v4.1 referrals.",
                        "enum": [
                           "enabled",
                           "disabled"
                        ]
                     },
                     "tcp": {
                        "type": "string",
                        "description": "Enable TCP (support from ONTAP 9.3 onward).",
                        "enum": [
                           "enabled",
                           "disabled"
                        ]
                     },
                     "udp": {
                        "type": "string",
                        "description": "Enable UDP (support from ONTAP 9.3 onward).",
                        "enum": [
                           "enabled",
                           "disabled"
                        ]
                     },
                     "showmount": {
                        "type": "string",
                        "description": "Whether SVM allows showmount",
                        "enum": [
                           "enabled",
                           "disabled"
                        ]
                     },
                     "tcp_max_xfer_size": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "TCP Maximum Transfer Size (bytes). The default value is 65536."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "nfsv41",
                                    "nfsv4.1"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "na_ontap_net_vlan": {
                  "type": "object",
                  "description": "Create or Delete a network VLAN",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified network VLAN should exist or not",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "parent_interface": {
                        "type": "string",
                        "description": "The interface that hosts the VLAN interface."
                     },
                     "vlanid": {
                        "type": "string",
                        "description": "The VLAN id. Ranges from 1 to 4094."
                     },
                     "node": {
                        "type": "string",
                        "description": "Node name of VLAN interface."
                     }
                  },
                  "required": [
                     "parent_interface",
                     "vlanid",
                     "node"
                  ]
               },
               "na_ontap_net_subnet": {
                  "type": "object",
                  "description": "Create, modify, destroy the network subnet",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified network interface group should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "broadcast_domain": {
                        "type": "string",
                        "description": "Specify the required broadcast_domain name for the subnet.\nA broadcast domain can not be modified after the subnet has been created"
                     },
                     "name": {
                        "type": "string",
                        "description": "Specify the subnet name."
                     },
                     "from_name": {
                        "type": "string",
                        "description": "Name of the subnet to be renamed"
                     },
                     "gateway": {
                        "type": "string",
                        "description": "Specify the gateway for the default route of the subnet."
                     },
                     "ipspace": {
                        "type": "string",
                        "description": "Specify the ipspace for the subnet.\nThe default value for this parameter is the default IPspace, named 'Default'."
                     },
                     "ip_ranges": {
                        "type": "string",
                        "description": "Specify the list of IP address ranges associated with the subnet."
                     },
                     "subnet": {
                        "type": "string",
                        "description": "Specify the subnet (ip and mask)."
                     }
                  },
                  "required": [
                     "broadcast_domain",
                     "name",
                     "subnet"
                  ]
               },
               "na_ontap_net_routes": {
                  "type": "object",
                  "description": "Modify ONTAP network routes.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether you want to create or delete a network route.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "vserver": {
                        "type": "string",
                        "description": "The name of the vserver."
                     },
                     "destination": {
                        "type": "string",
                        "description": "Specify the route destination.\nExample 10.7.125.5/20, fd20:13::/64."
                     },
                     "gateway": {
                        "type": "string",
                        "description": "Specify the route gateway.\nExample 10.7.125.1, fd20:13::1."
                     },
                     "metric": {
                        "type": "string",
                        "description": "Specify the route metric.\nIf this field is not provided the default will be set to 20."
                     },
                     "from_destination": {
                        "type": "string",
                        "description": "Specify the route destination that should be changed.\nnew_destination was removed to fix idempotency issues. To rename destination the original goes to from_destination and the new goes to destination."
                     },
                     "from_gateway": {
                        "type": "string",
                        "description": "Specify the route gateway that should be changed."
                     },
                     "from_metric": {
                        "type": "string",
                        "description": "Specify the route metric that should be changed."
                     }
                  },
                  "required": [
                     "vserver",
                     "destination",
                     "gateway"
                  ]
               },
               "na_ontap_net_port": {
                  "type": "object",
                  "description": "Modify a ONTAP network port.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified net port should exist or not.",
                        "enum": [
                           "present"
                        ]
                     },
                     "node": {
                        "type": "string",
                        "description": "Specifies the name of node."
                     },
                     "ports": {
                        "type": "string",
                        "description": "Specifies the name of port(s)."
                     },
                     "port": {
                        "type": "string",
                        "description": "Specifies the name of port(s)."
                     },
                     "mtu": {
                        "type": "string",
                        "description": "Specifies the maximum transmission unit (MTU) reported by the port."
                     },
                     "autonegotiate_admin": {
                        "type": "string",
                        "description": "Enables or disables Ethernet auto-negotiation of speed, duplex and flow control."
                     },
                     "duplex_admin": {
                        "type": "string",
                        "description": "Specifies the user preferred duplex setting of the port.\nValid values auto, half, full"
                     },
                     "speed_admin": {
                        "type": "string",
                        "description": "Specifies the user preferred speed setting of the port."
                     },
                     "flowcontrol_admin": {
                        "type": "string",
                        "description": "Specifies the user preferred flow control setting of the port."
                     },
                     "ipspace": {
                        "type": "string",
                        "description": "Specifies the port's associated IPspace name.\nThe 'Cluster' ipspace is reserved for cluster ports."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "ports",
                                    "port"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "ports"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "port"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "na_ontap_net_ifgrp": {
                  "type": "object",
                  "description": "Create, modify ports, destroy the network interface group",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified network interface group should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "distribution_function": {
                        "type": "string",
                        "description": "Specifies the traffic distribution function for the ifgrp.",
                        "enum": [
                           "mac",
                           "ip",
                           "sequential",
                           "port"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "Specifies the interface group name."
                     },
                     "mode": {
                        "type": "string",
                        "description": "Specifies the link policy for the ifgrp."
                     },
                     "node": {
                        "type": "string",
                        "description": "Specifies the name of node."
                     },
                     "ports": {
                        "type": "array",
                        "description": "List of expected ports to be present in the interface group.\nIf a port is present in this list, but not on the target, it will be added.\nIf a port is not in the list, but present on the target, it will be removed.\nMake sure the list contains all ports you want to see on the target."
                     },
                     "port": {
                        "type": "array",
                        "description": "List of expected ports to be present in the interface group.\nIf a port is present in this list, but not on the target, it will be added.\nIf a port is not in the list, but present on the target, it will be removed.\nMake sure the list contains all ports you want to see on the target."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "ports",
                                    "port"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "na_ontap_ndmp": {
                  "type": "object",
                  "description": "Modify NDMP Services.",
                  "properties": {
                     "vserver": {
                        "type": "string",
                        "description": "Name of the vserver."
                     },
                     "abort_on_disk_error": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Enable abort on disk error."
                     },
                     "authtype": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Authentication type."
                     },
                     "backup_log_enable": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Enable backup log."
                     },
                     "data_port_range": {
                        "type": "string",
                        "description": "Data port range."
                     },
                     "debug_enable": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Enable debug."
                     },
                     "debug_filter": {
                        "type": "string",
                        "description": "Debug filter."
                     },
                     "dump_detailed_stats": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Enable logging of VM stats for dump."
                     },
                     "dump_logical_find": {
                        "type": "string",
                        "description": "Enable logical find for dump."
                     },
                     "enable": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Enable NDMP on vserver."
                     },
                     "fh_dir_retry_interval": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "FH throttle value for dir."
                     },
                     "fh_node_retry_interval": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "FH throttle value for node."
                     },
                     "ignore_ctime_enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Ignore ctime."
                     },
                     "is_secure_control_connection_enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Is secure control connection enabled."
                     },
                     "offset_map_enable": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Enable offset map."
                     },
                     "per_qtree_exclude_enable": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Enable per qtree exclusion."
                     },
                     "preferred_interface_role": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Preferred interface role."
                     },
                     "restore_vm_cache_size": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Restore VM file cache size."
                     },
                     "secondary_debug_filter": {
                        "type": "string",
                        "description": "Secondary debug filter."
                     },
                     "tcpnodelay": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Enable TCP nodelay."
                     },
                     "tcpwinsize": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "TCP window size."
                     }
                  },
                  "required": [
                     "vserver"
                  ]
               },
               "na_ontap_motd": {
                  "type": "object",
                  "description": "This module allows you to manipulate motd for a vserver\nIt also allows to manipulate motd at the cluster level by using the cluster vserver (cserver)",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIf C(state=present) sets MOTD given in I(message) C(state=absent) removes it.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "message": {
                        "type": "string",
                        "description": "MOTD Text message, required when C(state=present)."
                     },
                     "vserver": {
                        "type": "string",
                        "description": "The name of the SVM motd should be set for."
                     },
                     "show_cluster_motd": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nSet to I(false) if Cluster-level Message of the Day should not be shown"
                     }
                  },
                  "required": [
                     "vserver"
                  ]
               },
               "na_ontap_lun_map": {
                  "type": "object",
                  "description": "Map and unmap LUNs on NetApp ONTAP.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified LUN should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "initiator_group_name": {
                        "type": "string",
                        "description": "Initiator group to map to the given LUN."
                     },
                     "path": {
                        "type": "string",
                        "description": "Path of the LUN.."
                     },
                     "vserver": {
                        "type": "string",
                        "description": "The name of the vserver to use."
                     },
                     "lun_id": {
                        "type": "string",
                        "description": "LUN ID assigned for the map."
                     }
                  },
                  "required": [
                     "initiator_group_name",
                     "path",
                     "vserver"
                  ]
               },
               "na_ontap_lun_copy": {
                  "type": "object",
                  "description": "Copy LUNs on NetApp ONTAP.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified LUN should exist or not.",
                        "enum": [
                           "present"
                        ]
                     },
                     "destination_vserver": {
                        "type": "string",
                        "description": "the name of the Vserver that will host the new LUN."
                     },
                     "destination_path": {
                        "type": "string",
                        "description": "Specifies the full path to the new LUN."
                     },
                     "source_path": {
                        "type": "string",
                        "description": "Specifies the full path to the source LUN."
                     },
                     "source_vserver": {
                        "type": "string",
                        "description": "Specifies the name of the vserver hosting the LUN to be copied."
                     }
                  },
                  "required": [
                     "destination_vserver",
                     "destination_path",
                     "source_path"
                  ]
               },
               "na_ontap_lun": {
                  "type": "object",
                  "description": "Create, destroy, resize LUNs on NetApp ONTAP.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified LUN should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the LUN to manage."
                     },
                     "flexvol_name": {
                        "type": "string",
                        "description": "The name of the FlexVol the LUN should exist on."
                     },
                     "size": {
                        "type": "string",
                        "description": "The size of the LUN in C(size_unit).\nRequired when C(state=present)."
                     },
                     "size_unit": {
                        "type": "string",
                        "description": "Default: gb\n\nThe unit used to interpret the size parameter.",
                        "enum": [
                           "bytes",
                           "b",
                           "kb",
                           "mb",
                           "gb",
                           "tb",
                           "pb",
                           "eb",
                           "zb",
                           "yb"
                        ]
                     },
                     "force_resize": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Forcibly reduce the size. This is required for reducing the size of the LUN to avoid accidentally reducing the LUN size."
                     },
                     "force_remove": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "If \"true\", override checks that prevent a LUN from being destroyed if it is online and mapped.\nIf \"false\", destroying an online and mapped LUN will fail."
                     },
                     "force_remove_fenced": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "If \"true\", override checks that prevent a LUN from being destroyed while it is fenced.\nIf \"false\", attempting to destroy a fenced LUN will fail.\nThe default if not specified is \"false\". This field is available in Data ONTAP 8.2 and later."
                     },
                     "vserver": {
                        "type": "string",
                        "description": "The name of the vserver to use."
                     },
                     "ostype": {
                        "type": "string",
                        "description": "Default: image\n\nThe os type for the LUN."
                     },
                     "space_reserve": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nThis can be set to \"false\" which will create a LUN without any space being reserved."
                     },
                     "space_allocation": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "This enables support for the SCSI Thin Provisioning features.  If the Host and file system do not support this do not enable it."
                     }
                  },
                  "required": [
                     "name",
                     "flexvol_name",
                     "vserver"
                  ]
               },
               "na_ontap_license": {
                  "type": "object",
                  "description": "Add or remove licenses on NetApp ONTAP.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified license should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "remove_unused": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Remove licenses that have no controller affiliation in the cluster."
                     },
                     "remove_expired": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Remove licenses that have expired in the cluster."
                     },
                     "serial_number": {
                        "type": "string",
                        "description": "Serial number of the node associated with the license. This parameter is used primarily when removing license for a specific service."
                     },
                     "license_names": {
                        "type": "array",
                        "description": "List of license-names to delete."
                     },
                     "license_codes": {
                        "type": "array",
                        "description": "List of license codes to be added."
                     }
                  }
               },
               "na_ontap_ldap_client": {
                  "type": "object",
                  "description": "Create, modify or delete LDAP client on NetApp ONTAP",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified LDAP client configuration exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "vserver": {
                        "type": "string",
                        "description": "vserver/svm that holds LDAP client configuration"
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of LDAP client configuration"
                     },
                     "ldap_servers": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Comma separated list of LDAP servers. FQDN's or IP addresses\nRequired if I(state=present)."
                     },
                     "schema": {
                        "type": "string",
                        "description": "LDAP schema\nRequired if I(state=present).",
                        "enum": [
                           "AD-IDMU",
                           "AD-SFU",
                           "MS-AD-BIS",
                           "RFC-2307"
                        ]
                     },
                     "base_dn": {
                        "type": "string",
                        "description": "LDAP base DN"
                     },
                     "base_scope": {
                        "type": "string",
                        "description": "LDAP search scope",
                        "enum": [
                           "subtree",
                           "onelevel",
                           "base"
                        ]
                     },
                     "port": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "LDAP server port"
                     },
                     "query_timeout": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "LDAP server query timeout"
                     },
                     "min_bind_level": {
                        "type": "string",
                        "description": "Minimal LDAP server bind level.",
                        "enum": [
                           "anonymous",
                           "simple",
                           "sasl"
                        ]
                     },
                     "bind_dn": {
                        "type": "string",
                        "description": "LDAP bind user DN"
                     },
                     "bind_password": {
                        "type": "string",
                        "description": "LDAP bind user password"
                     },
                     "use_start_tls": {
                        "type": "string",
                        "description": "Start TLS on LDAP connection",
                        "enum": [
                           "true",
                           "false"
                        ]
                     },
                     "referral_enabled": {
                        "type": "string",
                        "description": "LDAP Referral Chasing",
                        "enum": [
                           "true",
                           "false"
                        ]
                     },
                     "session_security": {
                        "type": "string",
                        "description": "Client Session Security",
                        "enum": [
                           "true",
                           "false"
                        ]
                     }
                  },
                  "required": [
                     "vserver",
                     "name"
                  ]
               },
               "na_ontap_ldap": {
                  "type": "object",
                  "description": "Create, modify or delete LDAP on NetApp ONTAP SVM/vserver",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the LDAP is present or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "vserver": {
                        "type": "string",
                        "description": "vserver/svm configured to use LDAP"
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of LDAP client configuration"
                     },
                     "skip_config_validation": {
                        "type": "string",
                        "description": "Skip LDAP validation",
                        "enum": [
                           "true",
                           "false"
                        ]
                     }
                  },
                  "required": [
                     "vserver",
                     "name"
                  ]
               },
               "na_ontap_kerberos_realm": {
                  "type": "object",
                  "description": "Create, modify or delete vserver kerberos realm configuration",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the Kerberos realm is present or absent.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "vserver": {
                        "type": "string",
                        "description": "vserver/svm with kerberos realm configured"
                     },
                     "realm": {
                        "type": "string",
                        "description": "Kerberos realm name"
                     },
                     "kdc_vendor": {
                        "type": "string",
                        "description": "The vendor of the Key Distribution Centre (KDC) server\nRequired if I(state=present)",
                        "enum": [
                           "Other",
                           "Microsoft"
                        ]
                     },
                     "kdc_ip": {
                        "type": "string",
                        "description": "IP address of the Key Distribution Centre (KDC) server\nRequired if I(state=present)"
                     },
                     "kdc_port": {
                        "type": "string",
                        "description": "TCP port on the KDC to be used for Kerberos communication.\nThe default for this parameter is '88'."
                     },
                     "clock_skew": {
                        "type": "string",
                        "description": "The clock skew in minutes is the tolerance for accepting tickets with time stamps that do not exactly match the host's system clock.\nThe default for this parameter is '5' minutes."
                     },
                     "comment": {
                        "type": "string",
                        "description": "Optional comment"
                     },
                     "admin_server_ip": {
                        "type": "string",
                        "description": "IP address of the host where the Kerberos administration daemon is running. This is usually the master KDC.\nIf this parameter is omitted, the address specified in kdc_ip is used."
                     },
                     "admin_server_port": {
                        "type": "string",
                        "description": "The TCP port on the Kerberos administration server where the Kerberos administration service is running.\nThe default for this parameter is '749'"
                     },
                     "pw_server_ip": {
                        "type": "string",
                        "description": "IP address of the host where the Kerberos password-changing server is running.\nTypically, this is the same as the host indicated in the adminserver-ip.\nIf this parameter is omitted, the IP address in kdc-ip is used."
                     },
                     "pw_server_port": {
                        "type": "string",
                        "description": "The TCP port on the Kerberos password-changing server where the Kerberos password-changing service is running.\nThe default for this parameter is '464'."
                     }
                  },
                  "required": [
                     "vserver",
                     "realm"
                  ]
               },
               "na_ontap_job_schedule": {
                  "type": "object",
                  "description": "Create/Delete/Modify job-schedules on ONTAP",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified job schedule should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the job-schedule to manage."
                     },
                     "job_minutes": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "The minute(s) of each hour when the job should be run. Job Manager cron scheduling minute. -1 represents all minutes and is only supported for cron schedule create and modify. Range is [-1..59]"
                     },
                     "job_hours": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "The hour(s) of the day when the job should be run. Job Manager cron scheduling hour. -1 represents all hours and is only supported for cron schedule create and modify. Range is [-1..23]"
                     },
                     "job_months": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "The month(s) when the job should be run. Job Manager cron scheduling month. -1 represents all months and is only supported for cron schedule create and modify. Range is [-1..11]"
                     },
                     "job_days_of_month": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "The day(s) of the month when the job should be run. Job Manager cron scheduling day of month. -1 represents all days of a month from 1 to 31, and is only supported for cron schedule create and modify. Range is [-1..31]"
                     },
                     "job_days_of_week": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "The day(s) in the week when the job should be run. Job Manager cron scheduling day of week. Zero represents Sunday. -1 represents all days of a week and is only supported for cron schedule create and modify. Range is [-1..6]"
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "na_ontap_iscsi": {
                  "type": "object",
                  "description": "create, delete, start, stop iSCSI service on SVM.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the service should be present or deleted.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "service_state": {
                        "type": "string",
                        "description": "Whether the specified service should running .",
                        "enum": [
                           "started",
                           "stopped"
                        ]
                     },
                     "vserver": {
                        "type": "string",
                        "description": "The name of the vserver to use."
                     }
                  },
                  "required": [
                     "vserver"
                  ]
               },
               "na_ontap_ipspace": {
                  "type": "object",
                  "description": "Manage an ipspace for an Ontap Cluster",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified ipspace should exist or not",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the ipspace to manage"
                     },
                     "from_name": {
                        "type": "string",
                        "description": "Name of the existing ipspace to be renamed to name"
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "na_ontap_interface": {
                  "type": "object",
                  "description": "Creating / deleting and modifying the LIF.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified interface should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "interface_name": {
                        "type": "string",
                        "description": "Specifies the logical interface (LIF) name."
                     },
                     "home_node": {
                        "type": "string",
                        "description": "Specifies the LIF's home node.\nBy default, the first node from the cluster is considered as home node"
                     },
                     "home_port": {
                        "type": "string",
                        "description": "Specifies the LIF's home port.\nRequired when C(state=present)"
                     },
                     "role": {
                        "type": "string",
                        "description": "Specifies the role of the LIF.\nWhen setting role as \"intercluster\", setting protocol is not supported.\nRequired when C(state=present)."
                     },
                     "address": {
                        "type": "string",
                        "description": "Specifies the LIF's IP address.\nRequired when C(state=present)"
                     },
                     "netmask": {
                        "type": "string",
                        "description": "Specifies the LIF's netmask.\nRequired when C(state=present)."
                     },
                     "vserver": {
                        "type": "string",
                        "description": "The name of the vserver to use."
                     },
                     "firewall_policy": {
                        "type": "string",
                        "description": "Specifies the firewall policy for the LIF."
                     },
                     "failover_policy": {
                        "type": "string",
                        "description": "Specifies the failover policy for the LIF.",
                        "enum": [
                           "disabled",
                           "system-defined",
                           "local-only",
                           "sfo-partner-only",
                           "broadcast-domain-wide"
                        ]
                     },
                     "subnet_name": {
                        "type": "string",
                        "description": "Subnet where the interface address is allocated from. If the option is not used, the IP address will need to be provided by the administrator during configuration."
                     },
                     "admin_status": {
                        "type": "string",
                        "description": "Specifies the administrative status of the LIF.",
                        "enum": [
                           "up",
                           "down"
                        ]
                     },
                     "is_auto_revert": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "If true, data LIF will revert to its home node under certain circumstances such as startup, and load balancing migration capability is disabled automatically"
                     },
                     "force_subnet_association": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Set this to true to acquire the address from the named subnet and assign the subnet to the LIF."
                     },
                     "protocols": {
                        "type": "string",
                        "description": "Specifies the list of data protocols configured on the LIF. By default, the values in this element are nfs, cifs and fcache.\nOther supported protocols are iscsi and fcp. A LIF can be configured to not support any data protocols by specifying 'none'.\nProtocol values of none, iscsi, fc-nvme or fcp can't be combined with any other data protocol(s).\naddress, netmask and firewall_policy parameters are not supported for 'fc-nvme' option."
                     },
                     "dns_domain_name": {
                        "type": "string",
                        "description": "Specifies the unique, fully qualified domain name of the DNS zone of this LIF."
                     },
                     "listen_for_dns_query": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "If True, this IP address will listen for DNS queries for the dnszone specified."
                     },
                     "is_dns_update_enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Specifies if DNS update is enabled for this LIF. Dynamic updates will be sent for this LIF if updates are enabled at Vserver level."
                     }
                  },
                  "required": [
                     "interface_name",
                     "vserver"
                  ]
               },
               "na_ontap_info": {
                  "type": "object",
                  "description": "This module allows you to gather various information about ONTAP configuration",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: info\n\nReturns \"info\"",
                        "enum": [
                           "info"
                        ]
                     },
                     "gather_subset": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Default: all\n\nWhen supplied, this argument will restrict the information collected to a given subset.  Possible values for this argument include \"aggregate_info\", \"cluster_node_info\", \"igroup_info\", \"lun_info\", \"net_dns_info\", \"net_ifgrp_info\", \"net_interface_info\", \"net_port_info\", \"nvme_info\", \"nvme_interface_info\", \"nvme_namespace_info\", \"nvme_subsystem_info\", \"ontap_version\", \"qos_adaptive_policy_info\", \"qos_policy_info\", \"security_key_manager_key_info\", \"security_login_account_info\", \"storage_failover_info\", \"volume_info\", \"vserver_info\", \"vserver_login_banner_info\", \"vserver_motd_info\", \"vserver_nfs_info\" Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected.\nnvme is supported with ONTAP 9.4 onwards.\nuse \"help\" to get a list of supported information for your system."
                     }
                  }
               },
               "na_ontap_igroup_initiator": {
                  "type": "object",
                  "description": "Add/Remove initiators from an igroup",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified initiator should exist or not in an igroup.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "names": {
                        "type": "array",
                        "description": "List of initiators to manage."
                     },
                     "name": {
                        "type": "array",
                        "description": "List of initiators to manage."
                     },
                     "initiator_group": {
                        "type": "string",
                        "description": "Name of the initiator group to which the initiator belongs."
                     },
                     "vserver": {
                        "type": "string",
                        "description": "The name of the vserver to use."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "names",
                                    "name"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "names"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "na_ontap_igroup": {
                  "type": "object",
                  "description": "Create/Delete/Rename Igroups and Modify initiators belonging to an igroup",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified Igroup should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the igroup to manage."
                     },
                     "initiator_group_type": {
                        "type": "string",
                        "description": "Type of the initiator group.\nRequired when C(state=present).",
                        "enum": [
                           "fcp",
                           "iscsi",
                           "mixed"
                        ]
                     },
                     "from_name": {
                        "type": "string",
                        "description": "Name of igroup to rename to name."
                     },
                     "ostype": {
                        "type": "string",
                        "description": "OS type of the initiators within the group."
                     },
                     "initiators": {
                        "type": "array",
                        "description": "List of initiators to be mapped to the igroup.\nWWPN, WWPN Alias, or iSCSI name of Initiator to add or remove.\nFor a modify operation, this list replaces the existing initiators\nThis module does not add or remove specific initiator(s) in an igroup"
                     },
                     "initiator": {
                        "type": "array",
                        "description": "List of initiators to be mapped to the igroup.\nWWPN, WWPN Alias, or iSCSI name of Initiator to add or remove.\nFor a modify operation, this list replaces the existing initiators\nThis module does not add or remove specific initiator(s) in an igroup"
                     },
                     "bind_portset": {
                        "type": "string",
                        "description": "Name of a current portset to bind to the newly created igroup."
                     },
                     "force_remove_initiator": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Forcibly remove the initiator even if there are existing LUNs mapped to this initiator group."
                     },
                     "vserver": {
                        "type": "string",
                        "description": "The name of the vserver to use."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "initiators",
                                    "initiator"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "na_ontap_flexcache": {
                  "type": "object",
                  "description": "Create/Delete FlexCache volume relationships",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified relationship should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "origin_volume": {
                        "type": "string",
                        "description": "Name of the origin volume for the FlexCache.\nRequired for creation."
                     },
                     "origin_vserver": {
                        "type": "string",
                        "description": "Name of the origin vserver for the FlexCache.\nRequired for creation."
                     },
                     "origin_cluster": {
                        "type": "string",
                        "description": "Name of the origin cluster for the FlexCache.\nDefaults to cluster associated with target vserver if absent.\nNot used for creation."
                     },
                     "volume": {
                        "type": "string",
                        "description": "Name of the target volume for the FlexCache."
                     },
                     "junction_path": {
                        "type": "string",
                        "description": "Junction path of the cache volume."
                     },
                     "auto_provision_as": {
                        "type": "string",
                        "description": "Use this parameter to automatically select existing aggregates for volume provisioning.Eg flexgroup\nNote that the fastest aggregate type with at least one aggregate on each node of the cluster will be selected."
                     },
                     "size": {
                        "type": "string",
                        "description": "Size of cache volume."
                     },
                     "size_unit": {
                        "type": "string",
                        "description": "Default: gb\n\nThe unit used to interpret the size parameter.",
                        "enum": [
                           "bytes",
                           "b",
                           "kb",
                           "mb",
                           "gb",
                           "tb",
                           "pb",
                           "eb",
                           "zb",
                           "yb"
                        ]
                     },
                     "vserver": {
                        "type": "string",
                        "description": "Name of the target vserver for the FlexCache.\nNote that hostname, username, password are intended for the target vserver."
                     },
                     "aggr_list": {
                        "type": "array",
                        "description": "List of aggregates to host target FlexCache volume."
                     },
                     "aggr_list_multiplier": {
                        "type": "string",
                        "description": "Aggregate list repeat count."
                     },
                     "force_unmount": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Unmount FlexCache volume. Delete the junction path at which the volume is mounted before deleting the FlexCache relationship."
                     },
                     "force_offline": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Offline FlexCache volume before deleting the FlexCache relationship.\nThe volume will be destroyed and data can be lost."
                     },
                     "time_out": {
                        "type": "string",
                        "description": "Default: 180\n\ntime to wait for flexcache creation or deletion in seconds\nif 0, the request is asynchronous\ndefault is set to 3 minutes"
                     }
                  },
                  "required": [
                     "volume",
                     "vserver"
                  ]
               },
               "na_ontap_firmware_upgrade": {
                  "type": "object",
                  "description": "Update ONTAP service-prosessor firmware",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified ONTAP firmware should  be upgraded or not."
                     },
                     "node": {
                        "type": "string",
                        "description": "Node on which the device is located."
                     },
                     "clear_logs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nClear logs on the device after update. Default value is true"
                     },
                     "package": {
                        "type": "string",
                        "description": "Name of the package file containing the firmware to be installed. Not required when -baseline is true."
                     },
                     "shelf_module_fw": {
                        "type": "string",
                        "description": "Shelf module firmware to be updated to."
                     },
                     "disk_fw": {
                        "type": "string",
                        "description": "disk firmware to be updated to."
                     },
                     "update_type": {
                        "type": "string",
                        "description": "Type of firmware update to be performed. Options include serial_full, serial_differential, network_full."
                     },
                     "install_baseline_image": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Install the version packaged with ONTAP if this parameter is set to true. Otherwise, package must be used to specify the package to install."
                     },
                     "firmware_type": {
                        "type": "string",
                        "description": "Type of firmware to be upgraded. Options include shelf, ACP, service-processor, and disk.\nFor shelf firmware upgrade the operation is asynchronous, and therefore returns no errors that might occur during the download process.\nShelf firmware upgrade is idempotent if shelf_module_fw is provided .\ndisk firmware upgrade is idempotent if disk_fw is provided .\nWith check mode, SP, ACP, disk, and shelf firmware upgrade is not idempotent.\nThis operation will only update firmware on shelves/disk that do not have the latest firmware-revision.",
                        "enum": [
                           "service-processor",
                           "shelf",
                           "acp",
                           "disk"
                        ]
                     }
                  },
                  "required": [
                     "node"
                  ]
               },
               "na_ontap_firewall_policy": {
                  "type": "object",
                  "description": "Configure firewall on an ONTAP node and manage firewall policy for an ONTAP SVM",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether to set up a firewall policy or not",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "allow_list": {
                        "type": "string",
                        "description": "A list of IPs and masks to use.\nThe host bits of the IP addresses used in this list must be set to 0."
                     },
                     "policy": {
                        "type": "string",
                        "description": "A policy name for the firewall policy"
                     },
                     "service": {
                        "type": "string",
                        "description": "The service to apply the policy to",
                        "enum": [
                           "dns",
                           "http",
                           "https",
                           "ndmp",
                           "ndmps",
                           "ntp",
                           "rsh",
                           "snmp",
                           "ssh",
                           "telnet"
                        ]
                     },
                     "vserver": {
                        "type": "string",
                        "description": "The Vserver to apply the policy to."
                     },
                     "enable": {
                        "type": "string",
                        "description": "enable firewall on a node",
                        "enum": [
                           "enable",
                           "disable"
                        ]
                     },
                     "logging": {
                        "type": "string",
                        "description": "enable logging for firewall on a node",
                        "enum": [
                           "enable",
                           "disable"
                        ]
                     },
                     "node": {
                        "type": "string",
                        "description": "The node to run the firewall configuration on"
                     }
                  }
               },
               "na_ontap_fcp": {
                  "type": "object",
                  "description": "Start, Stop and Enable FCP services.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the FCP should be enabled or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "status": {
                        "type": "string",
                        "description": "Default: up\n\nWhether the FCP should be up or down",
                        "enum": [
                           "up",
                           "down"
                        ]
                     },
                     "vserver": {
                        "type": "string",
                        "description": "The name of the vserver to use."
                     }
                  },
                  "required": [
                     "vserver"
                  ]
               },
               "na_ontap_export_policy_rule": {
                  "type": "object",
                  "description": "Create or delete or modify export rules in ONTAP",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified export policy rule should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the export rule to manage."
                     },
                     "policy_name": {
                        "type": "string",
                        "description": "The name of the export rule to manage."
                     },
                     "client_match": {
                        "type": "array",
                        "description": "List of Client Match host names, IP Addresses, Netgroups, or Domains\nIf rule_index is not provided, client_match is used as a key to fetch current rule to determine create,delete,modify actions. If a rule with provided client_match exists, a new rule will not be created, but the existing rule will be modified or deleted. If a rule with provided client_match doesn't exist, a new rule will be created if state is present."
                     },
                     "ro_rule": {
                        "type": "array",
                        "description": "List of Read only access specifications for the rule"
                     },
                     "rw_rule": {
                        "type": "array",
                        "description": "List of Read Write access specifications for the rule"
                     },
                     "super_user_security": {
                        "type": "array",
                        "description": "List of Read Write access specifications for the rule"
                     },
                     "allow_suid": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "If 'true', NFS server will honor SetUID bits in SETATTR operation. Default value on creation is 'true'"
                     },
                     "protocol": {
                        "type": "array",
                        "description": "List of Client access protocols.\nDefault value is set to 'any' during create."
                     },
                     "rule_index": {
                        "type": "string",
                        "description": "rule index of the export policy"
                     },
                     "vserver": {
                        "type": "string",
                        "description": "Name of the vserver to use."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "policy_name"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "policy_name"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "na_ontap_export_policy": {
                  "type": "object",
                  "description": "Create or destroy or rename export-policies on ONTAP",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified export policy should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the export-policy to manage."
                     },
                     "from_name": {
                        "type": "string",
                        "description": "The name of the export-policy to be renamed."
                     },
                     "vserver": {
                        "type": "string",
                        "description": "Name of the vserver to use."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "na_ontap_dns": {
                  "type": "object",
                  "description": "Create, delete, modify DNS servers.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the DNS servers should be enabled for the given vserver.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "vserver": {
                        "type": "string",
                        "description": "The name of the vserver to use."
                     },
                     "domains": {
                        "type": "array",
                        "description": "List of DNS domains such as 'sales.bar.com'. The first domain is the one that the Vserver belongs to."
                     },
                     "nameservers": {
                        "type": "array",
                        "description": "List of IPv4 addresses of name servers such as '123.123.123.123'."
                     },
                     "skip_validation": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "By default, all nameservers are checked to validate they are available to resolve.\nIf you DNS servers are not yet installed or momentarily not available, you can set this option to 'true'\nto bypass the check for all servers specified in nameservers field."
                     }
                  },
                  "required": [
                     "vserver"
                  ]
               },
               "na_ontap_disks": {
                  "type": "object",
                  "description": "Assign all or part of disks to nodes.",
                  "properties": {
                     "node": {
                        "type": "string",
                        "description": "It specifies the node to assign all visible unowned disks."
                     },
                     "disk_count": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Total number of disks a node should own"
                     }
                  },
                  "required": [
                     "node"
                  ]
               },
               "na_ontap_command": {
                  "type": "object",
                  "description": "Run system-cli commands on ONTAP",
                  "properties": {
                     "command": {
                        "type": "string",
                        "description": "a comma separated list containing the command and arguments."
                     },
                     "privilege": {
                        "type": "string",
                        "description": "Default: admin\n\nprivilege level at which to run the command.",
                        "enum": [
                           "admin",
                           "advanced"
                        ]
                     },
                     "return_dict": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "returns a parsesable dictionary instead of raw XML output"
                     }
                  },
                  "required": [
                     "command"
                  ]
               },
               "na_ontap_cluster_peer": {
                  "type": "object",
                  "description": "Create/Delete cluster peer relations on ONTAP",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified cluster peer should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "source_intercluster_lifs": {
                        "type": "array",
                        "description": "List of intercluster addresses of the source cluster.\nUsed as peer-addresses in destination cluster.\nAll these intercluster lifs should belong to the source cluster."
                     },
                     "source_intercluster_lif": {
                        "type": "array",
                        "description": "List of intercluster addresses of the source cluster.\nUsed as peer-addresses in destination cluster.\nAll these intercluster lifs should belong to the source cluster."
                     },
                     "dest_intercluster_lifs": {
                        "type": "array",
                        "description": "List of intercluster addresses of the destination cluster.\nUsed as peer-addresses in source cluster.\nAll these intercluster lifs should belong to the destination cluster."
                     },
                     "dest_intercluster_lif": {
                        "type": "array",
                        "description": "List of intercluster addresses of the destination cluster.\nUsed as peer-addresses in source cluster.\nAll these intercluster lifs should belong to the destination cluster."
                     },
                     "passphrase": {
                        "type": "string",
                        "description": "The arbitrary passphrase that matches the one given to the peer cluster."
                     },
                     "source_cluster_name": {
                        "type": "string",
                        "description": "The name of the source cluster name in the peer relation to be deleted."
                     },
                     "dest_cluster_name": {
                        "type": "string",
                        "description": "The name of the destination cluster name in the peer relation to be deleted.\nRequired for delete"
                     },
                     "dest_hostname": {
                        "type": "string",
                        "description": "Destination cluster IP or hostname which needs to be peered\nRequired to complete the peering process at destination cluster."
                     },
                     "dest_username": {
                        "type": "string",
                        "description": "Destination username.\nOptional if this is same as source username."
                     },
                     "dest_password": {
                        "type": "string",
                        "description": "Destination password.\nOptional if this is same as source password."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "source_intercluster_lifs",
                                    "source_intercluster_lif"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "dest_intercluster_lifs",
                                    "dest_intercluster_lif"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "na_ontap_cluster_ha": {
                  "type": "object",
                  "description": "Enable or disable HA on a cluster",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether HA on cluster should be enabled or disabled.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     }
                  }
               },
               "na_ontap_cluster": {
                  "type": "object",
                  "description": "Create or join or apply licenses to ONTAP clusters\nCluster join can be performed using only one of the parameters, either cluster_name or cluster_ip_address",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified cluster should exist or not.",
                        "enum": [
                           "present"
                        ]
                     },
                     "cluster_name": {
                        "type": "string",
                        "description": "The name of the cluster to manage."
                     },
                     "cluster_ip_address": {
                        "type": "string",
                        "description": "IP address of cluster to be joined"
                     },
                     "license_code": {
                        "type": "string",
                        "description": "License code to be applied to the cluster"
                     },
                     "license_package": {
                        "type": "string",
                        "description": "License package name of the license to be removed"
                     },
                     "node_serial_number": {
                        "type": "string",
                        "description": "Serial number of the cluster node"
                     }
                  }
               },
               "na_ontap_cifs_server": {
                  "type": "object",
                  "description": "Creating / deleting and modifying the CIFS server .",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified cifs_server should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "service_state": {
                        "type": "string",
                        "description": "CIFS Server Administrative Status.",
                        "enum": [
                           "stopped",
                           "started"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "Specifies the cifs_server name."
                     },
                     "cifs_server_name": {
                        "type": "string",
                        "description": "Specifies the cifs_server name."
                     },
                     "admin_user_name": {
                        "type": "string",
                        "description": "Specifies the cifs server admin username."
                     },
                     "admin_password": {
                        "type": "string",
                        "description": "Specifies the cifs server admin password."
                     },
                     "domain": {
                        "type": "string",
                        "description": "The Fully Qualified Domain Name of the Windows Active Directory this CIFS server belongs to."
                     },
                     "workgroup": {
                        "type": "string",
                        "description": "The NetBIOS name of the domain or workgroup this CIFS server belongs to."
                     },
                     "ou": {
                        "type": "string",
                        "description": "The Organizational Unit (OU) within the Windows Active Directory this CIFS server belongs to."
                     },
                     "force": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "If this is set and a machine account with the same name as specified in 'name' exists in the Active Directory, it will be overwritten and reused."
                     },
                     "vserver": {
                        "type": "string",
                        "description": "The name of the vserver to use."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "cifs_server_name"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "cifs_server_name"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "na_ontap_cifs_acl": {
                  "type": "object",
                  "description": "Create or destroy or modify cifs-share-access-controls on ONTAP",
                  "properties": {
                     "permission": {
                        "type": "string",
                        "description": "-\"The access rights that the user or group has on the defined CIFS share.\"",
                        "enum": [
                           "no_access",
                           "read",
                           "change",
                           "full_control"
                        ]
                     },
                     "share_name": {
                        "type": "string",
                        "description": "The name of the cifs-share-access-control to manage."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified CIFS share acl should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "vserver": {
                        "type": "string",
                        "description": "Name of the vserver to use."
                     },
                     "user_or_group": {
                        "type": "string",
                        "description": "The user or group name for which the permissions are listed."
                     }
                  },
                  "required": [
                     "share_name",
                     "vserver",
                     "user_or_group"
                  ]
               },
               "na_ontap_cifs": {
                  "type": "object",
                  "description": "Create or destroy or modify(path) cifs-share on ONTAP",
                  "properties": {
                     "path": {
                        "type": "string",
                        "description": "The file system path that is shared through this CIFS share. The path is the full, user visible path relative to the vserver root, and it might be crossing junction mount points. The path is in UTF8 and uses forward slash as directory separator"
                     },
                     "vserver": {
                        "type": "string",
                        "description": "Vserver containing the CIFS share."
                     },
                     "share_name": {
                        "type": "string",
                        "description": "The name of the CIFS share. The CIFS share name is a UTF-8 string with the following characters being illegal; control characters from 0x00 to 0x1F, both inclusive, 0x22 (double quotes)"
                     },
                     "share_properties": {
                        "type": "string",
                        "description": "The list of properties for the CIFS share"
                     },
                     "symlink_properties": {
                        "type": "string",
                        "description": "The list of symlink properties for this CIFS share"
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified CIFS share should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "vscan_fileop_profile": {
                        "type": "string",
                        "description": "Profile_set of file_ops to which vscan on access scanning is applicable.",
                        "enum": [
                           "no_scan",
                           "standard",
                           "strict",
                           "writes_only"
                        ]
                     }
                  },
                  "required": [
                     "vserver",
                     "share_name"
                  ]
               },
               "na_ontap_cg_snapshot": {
                  "type": "object",
                  "description": "Create consistency group snapshot for ONTAP volumes.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIf you want to create a snapshot."
                     },
                     "vserver": {
                        "type": "string",
                        "description": "Name of the vserver."
                     },
                     "volumes": {
                        "type": "string",
                        "description": "A list of volumes in this filer that is part of this CG operation."
                     },
                     "snapshot": {
                        "type": "string",
                        "description": "The provided name of the snapshot that is created in each volume."
                     },
                     "timeout": {
                        "type": "string",
                        "description": "Default: medium\n\nTimeout selector.",
                        "enum": [
                           "urgent",
                           "medium",
                           "relaxed"
                        ]
                     },
                     "snapmirror_label": {
                        "type": "string",
                        "description": "A human readable SnapMirror label to be attached with the consistency group snapshot copies."
                     }
                  },
                  "required": [
                     "vserver",
                     "volumes",
                     "snapshot"
                  ]
               },
               "na_ontap_broadcast_domain_ports": {
                  "type": "object",
                  "description": "Add or remove ONTAP broadcast domain ports.  Existing ports that are not listed are kept.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified broadcast domain should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "broadcast_domain": {
                        "type": "string",
                        "description": "Specify the broadcast_domain name"
                     },
                     "ipspace": {
                        "type": "string",
                        "description": "Specify the ipspace for the broadcast domain"
                     },
                     "ports": {
                        "type": "string",
                        "description": "Specify the list of ports to add to or remove from this broadcast domain."
                     }
                  },
                  "required": [
                     "broadcast_domain"
                  ]
               },
               "na_ontap_broadcast_domain": {
                  "type": "object",
                  "description": "Modify a ONTAP broadcast domain.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified broadcast domain should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "Specify the broadcast domain name."
                     },
                     "broadcast_domain": {
                        "type": "string",
                        "description": "Specify the broadcast domain name."
                     },
                     "from_name": {
                        "type": "string",
                        "description": "Specify the  broadcast domain name to be split into new broadcast domain."
                     },
                     "mtu": {
                        "type": "string",
                        "description": "Specify the required mtu for the broadcast domain."
                     },
                     "ipspace": {
                        "type": "string",
                        "description": "Specify the required ipspace for the broadcast domain.\nA domain ipspace can not be modified after the domain has been created."
                     },
                     "ports": {
                        "type": "string",
                        "description": "Specify the ports associated with this broadcast domain. Should be comma separated.\nIt represents the expected state of a list of ports at any time.\nAdd a port if it is specified in expected state but not in current state.\nDelete a port if it is specified in current state but not in expected state.\nFor split action, it represents the ports to be split from current broadcast domain and added to the new broadcast domain.\nif all ports are removed or split from a broadcast domain, the broadcast domain will be deleted automatically."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "broadcast_domain"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "broadcast_domain"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "na_ontap_autosupport": {
                  "type": "object",
                  "description": "Enable/Disable Autosupport",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nSpecifies whether the AutoSupport daemon is present or absent.\nWhen this setting is absent, delivery of all AutoSupport messages is turned off.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "node_name": {
                        "type": "string",
                        "description": "The name of the filer that owns the AutoSupport Configuration."
                     },
                     "transport": {
                        "type": "string",
                        "description": "The name of the transport protocol used to deliver AutoSupport messages",
                        "enum": [
                           "http",
                           "https",
                           "smtp"
                        ]
                     },
                     "noteto": {
                        "type": "string",
                        "description": "Specifies up to five recipients of short AutoSupport e-mail messages."
                     },
                     "post_url": {
                        "type": "string",
                        "description": "The URL used to deliver AutoSupport messages via HTTP POST"
                     },
                     "mail_hosts": {
                        "type": "array",
                        "description": "List of mail server(s) used to deliver AutoSupport messages via SMTP.\nBoth host names and IP addresses may be used as valid input."
                     },
                     "support": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Specifies whether AutoSupport notification to technical support is enabled."
                     },
                     "from_address": {
                        "type": "string",
                        "description": "specify the e-mail address from which the node sends AutoSupport messages"
                     },
                     "partner_addresses": {
                        "type": "string",
                        "description": "Specifies up to five partner vendor recipients of full AutoSupport e-mail messages."
                     },
                     "to_addresses": {
                        "type": "string",
                        "description": "Specifies up to five recipients of full AutoSupport e-mail messages."
                     },
                     "proxy_url": {
                        "type": "string",
                        "description": "specify an HTTP or HTTPS proxy if the 'transport' parameter is set to HTTP or HTTPS and your organization uses a proxy.\nIf authentication is required, use the format \"username:password@host:port\"."
                     },
                     "hostname_in_subject": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Specify whether the hostname of the node is included in the subject line of the AutoSupport message."
                     }
                  },
                  "required": [
                     "node_name"
                  ]
               },
               "na_ontap_aggregate": {
                  "type": "object",
                  "description": "Create, delete, or manage aggregates on ONTAP.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified aggregate should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "service_state": {
                        "type": "string",
                        "description": "Whether the specified aggregate should be enabled or disabled. Creates aggregate if doesnt exist.",
                        "enum": [
                           "online",
                           "offline"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the aggregate to manage."
                     },
                     "from_name": {
                        "type": "string",
                        "description": "Name of the aggregate to be renamed."
                     },
                     "nodes": {
                        "type": "string",
                        "description": "Node(s) for the aggregate to be created on.  If no node specified, mgmt lif home will be used.\nIf multiple nodes specified an aggr stripe will be made."
                     },
                     "disk_type": {
                        "type": "string",
                        "description": "Type of disk to use to build aggregate",
                        "enum": [
                           "ATA",
                           "BSAS",
                           "FCAL",
                           "FSAS",
                           "LUN",
                           "MSATA",
                           "SAS",
                           "SSD",
                           "VMDISK"
                        ]
                     },
                     "disk_count": {
                        "type": "string",
                        "description": "Number of disks to place into the aggregate, including parity disks.\nThe disks in this newly-created aggregate come from the spare disk pool.\nThe smallest disks in this pool join the aggregate first, unless the C(disk-size) argument is provided.\nEither C(disk-count) or C(disks) must be supplied. Range [0..2^31-1].\nRequired when C(state=present)."
                     },
                     "disk_size": {
                        "type": "string",
                        "description": "Disk size to use in 4K block size.  Disks within 10% of specified size will be used."
                     },
                     "raid_size": {
                        "type": "string",
                        "description": "Sets the maximum number of drives per raid group."
                     },
                     "raid_type": {
                        "type": "string",
                        "description": "Specifies the type of RAID groups to use in the new aggregate.",
                        "enum": [
                           "raid4",
                           "raid_dp",
                           "raid_tec"
                        ]
                     },
                     "unmount_volumes": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "If set to \"TRUE\", this option specifies that all of the volumes hosted by the given aggregate are to be unmounted\nbefore the offline operation is executed.\nBy default, the system will reject any attempt to offline an aggregate that hosts one or more online volumes."
                     },
                     "disks": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Specific list of disks to use for the new aggregate.\nTo create a \"mirrored\" aggregate with a specific list of disks, both 'disks' and 'mirror_disks' options must be supplied. Additionally, the same number of disks must be supplied in both lists."
                     },
                     "is_mirrored": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Specifies that the new aggregate be mirrored (have two plexes).\nIf set to true, then the indicated disks will be split across the two plexes. By default, the new aggregate will not be mirrored.\nThis option cannot be used when a specific list of disks is supplied with either the 'disks' or 'mirror_disks' options."
                     },
                     "mirror_disks": {
                        "type": "array",
                        "description": "List of mirror disks to use. It must contain the same number of disks specified in 'disks'."
                     },
                     "spare_pool": {
                        "type": "string",
                        "description": "Specifies the spare pool from which to select spare disks to use in creation of a new aggregate.",
                        "enum": [
                           "Pool0",
                           "Pool1"
                        ]
                     },
                     "wait_for_online": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Set this parameter to 'true' for synchronous execution during create (wait until aggregate status is online)\nSet this parameter to 'false' for asynchronous execution\nFor asynchronous, execution exits as soon as the request is sent, without checking aggregate status"
                     },
                     "time_out": {
                        "type": "string",
                        "description": "Default: 100\n\ntime to wait for aggregate creation in seconds\ndefault is set to 100 seconds"
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "na_elementsw_volume_pair": {
                  "type": "object",
                  "description": "Create, delete volume pair",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified volume pair should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "src_volume": {
                        "type": "string",
                        "description": "Source volume name or volume ID"
                     },
                     "src_account": {
                        "type": "string",
                        "description": "Source account name or ID"
                     },
                     "dest_volume": {
                        "type": "string",
                        "description": "Destination volume name or volume ID"
                     },
                     "dest_account": {
                        "type": "string",
                        "description": "Destination account name or ID"
                     },
                     "mode": {
                        "type": "string",
                        "description": "Default: async\n\nMode to start the volume pairing",
                        "enum": [
                           "async",
                           "sync",
                           "snapshotsonly"
                        ]
                     },
                     "dest_mvip": {
                        "type": "string",
                        "description": "Destination IP address of the paired cluster."
                     },
                     "dest_username": {
                        "type": "string",
                        "description": "Destination username for the paired cluster\nOptional if this is same as source cluster username."
                     },
                     "dest_password": {
                        "type": "string",
                        "description": "Destination password for the paired cluster\nOptional if this is same as source cluster password."
                     }
                  },
                  "required": [
                     "src_volume",
                     "src_account",
                     "dest_volume",
                     "dest_account",
                     "dest_mvip"
                  ]
               },
               "na_elementsw_volume_clone": {
                  "type": "object",
                  "description": "Create volume clones on Element OS",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The name of the clone."
                     },
                     "src_volume_id": {
                        "type": "string",
                        "description": "The id of the src volume to clone. id may be a numeric identifier or a volume name."
                     },
                     "src_snapshot_id": {
                        "type": "string",
                        "description": "The id of the snapshot to clone. id may be a numeric identifier or a snapshot name."
                     },
                     "account_id": {
                        "type": "string",
                        "description": "Account ID for the owner of this cloned volume. id may be a numeric identifier or an account name."
                     },
                     "attributes": {
                        "type": "string",
                        "description": "A YAML dictionary of attributes that you would like to apply on this cloned volume."
                     },
                     "size": {
                        "type": "string",
                        "description": "The size of the cloned volume in (size_unit)."
                     },
                     "size_unit": {
                        "type": "string",
                        "description": "Default: gb\n\nThe unit used to interpret the size parameter.",
                        "enum": [
                           "bytes",
                           "b",
                           "kb",
                           "mb",
                           "gb",
                           "tb",
                           "pb",
                           "eb",
                           "zb",
                           "yb"
                        ]
                     },
                     "access": {
                        "type": "string",
                        "description": "Access allowed for the volume.\nIf unspecified, the access settings of the clone will be the same as the source.\nreadOnly - Only read operations are allowed.\nreadWrite - Reads and writes are allowed.\nlocked - No reads or writes are allowed.\nreplicationTarget - Identify a volume as the target volume for a paired set of volumes. If the volume is not paired, the access status is locked.",
                        "enum": [
                           "readOnly",
                           "readWrite",
                           "locked",
                           "replicationTarget"
                        ]
                     }
                  },
                  "required": [
                     "name",
                     "src_volume_id",
                     "account_id"
                  ]
               },
               "na_elementsw_volume": {
                  "type": "object",
                  "description": "Create, destroy, or update volumes on ElementSW",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Whether the specified volume should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the volume to manage.\nIt accepts volume_name or volume_id"
                     },
                     "account_id": {
                        "type": "string",
                        "description": "Account ID for the owner of this volume.\nIt accepts Account_id or Account_name"
                     },
                     "enable512e": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Required when C(state=present)\nShould the volume provide 512-byte sector emulation?"
                     },
                     "512emulation": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Required when C(state=present)\nShould the volume provide 512-byte sector emulation?"
                     },
                     "qos": {
                        "type": "string",
                        "description": "Initial quality of service settings for this volume. Configure as dict in playbooks."
                     },
                     "attributes": {
                        "type": "string",
                        "description": "A YAML dictionary of attributes that you would like to apply on this volume."
                     },
                     "size": {
                        "type": "string",
                        "description": "The size of the volume in (size_unit).\nRequired when C(state = present)."
                     },
                     "size_unit": {
                        "type": "string",
                        "description": "Default: gb\n\nThe unit used to interpret the size parameter.",
                        "enum": [
                           "bytes",
                           "b",
                           "kb",
                           "mb",
                           "gb",
                           "tb",
                           "pb",
                           "eb",
                           "zb",
                           "yb"
                        ]
                     },
                     "access": {
                        "type": "string",
                        "description": "Access allowed for the volume.\nreadOnly           Only read operations are allowed.\nreadWrite          Reads and writes are allowed.\nlocked             No reads or writes are allowed.\nreplicationTarget  Identify a volume as the target volume for a paired set of volumes.\nIf the volume is not paired, the access status is locked.\nIf unspecified, the access settings of the clone will be the same as the source.",
                        "enum": [
                           "readOnly",
                           "readWrite",
                           "locked",
                           "replicationTarget"
                        ]
                     },
                     "password": {
                        "type": "string",
                        "description": "ElementSW access account password"
                     },
                     "pass": {
                        "type": "string",
                        "description": "ElementSW access account password"
                     },
                     "username": {
                        "type": "string",
                        "description": "ElementSW access account user-name"
                     },
                     "user": {
                        "type": "string",
                        "description": "ElementSW access account user-name"
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "enable512e",
                                    "512emulation"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "password",
                                    "pass"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "username",
                                    "user"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "na_elementsw_vlan": {
                  "type": "object",
                  "description": "Create, delete, modify VLAN",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified vlan should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "vlan_tag": {
                        "type": "string",
                        "description": "Virtual Network Tag"
                     },
                     "name": {
                        "type": "string",
                        "description": "User defined name for the new VLAN\nName of the vlan is unique\nRequired for create"
                     },
                     "svip": {
                        "type": "string",
                        "description": "Storage virtual IP which is unique\nRequired for create"
                     },
                     "address_blocks": {
                        "type": "array",
                        "description": "List of address blocks for the VLAN\nEach address block contains the starting IP address and size for the block\nRequired for create"
                     },
                     "netmask": {
                        "type": "string",
                        "description": "Netmask for the VLAN\nRequired for create"
                     },
                     "gateway": {
                        "type": "string",
                        "description": "Gateway for the VLAN"
                     },
                     "namespace": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Enable or disable namespaces"
                     },
                     "attributes": {
                        "type": "object",
                        "description": "Dictionary of attributes with name and value for each attribute"
                     }
                  },
                  "required": [
                     "vlan_tag"
                  ]
               },
               "na_elementsw_snapshot_schedule": {
                  "type": "object",
                  "description": "Create, destroy, or update accounts on ElementSW",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Whether the specified schedule should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "paused": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Pause / Resume a schedule."
                     },
                     "recurring": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Should the schedule recur?"
                     },
                     "schedule_type": {
                        "type": "string",
                        "description": "Schedule type for creating schedule.",
                        "enum": [
                           "DaysOfWeekFrequency",
                           "DaysOfMonthFrequency",
                           "TimeIntervalFrequency"
                        ]
                     },
                     "time_interval_days": {
                        "type": "string",
                        "description": "Default: 1\n\nTime interval in days."
                     },
                     "time_interval_hours": {
                        "type": "string",
                        "description": "Time interval in hours."
                     },
                     "time_interval_minutes": {
                        "type": "string",
                        "description": "Time interval in minutes."
                     },
                     "days_of_week_weekdays": {
                        "type": "array",
                        "description": "List of days of the week (Sunday to Saturday)"
                     },
                     "days_of_week_hours": {
                        "type": "string",
                        "description": "Time specified in hours"
                     },
                     "days_of_week_minutes": {
                        "type": "string",
                        "description": "Time specified in minutes."
                     },
                     "days_of_month_monthdays": {
                        "type": "array",
                        "description": "List of days of the month (1-31)"
                     },
                     "days_of_month_hours": {
                        "type": "string",
                        "description": "Time specified in hours"
                     },
                     "days_of_month_minutes": {
                        "type": "string",
                        "description": "Time specified in minutes."
                     },
                     "name": {
                        "type": "string",
                        "description": "Name for the snapshot schedule.\nIt accepts either schedule_id or schedule_name\nif name is digit, it will consider as schedule_id\nIf name is string, it will consider as schedule_name"
                     },
                     "snapshot_name": {
                        "type": "string",
                        "description": "Name for the created snapshots."
                     },
                     "volumes": {
                        "type": "string",
                        "description": "Volume IDs that you want to set the snapshot schedule for.\nIt accepts both volume_name and volume_id"
                     },
                     "account_id": {
                        "type": "string",
                        "description": "Account ID for the owner of this volume.\nIt accepts either account_name or account_id\nif account_id is digit, it will consider as account_id\nIf account_id is string, it will consider as account_name"
                     },
                     "retention": {
                        "type": "string",
                        "description": "Retention period for the snapshot.\nFormat is 'HH:mm:ss'."
                     },
                     "starting_date": {
                        "type": "string",
                        "description": "Starting date for the schedule.\nRequired when C(state=present).\nFormat: C(2016-12-01T00:00:00Z)"
                     },
                     "password": {
                        "type": "string",
                        "description": "Element SW access account password"
                     },
                     "pass": {
                        "type": "string",
                        "description": "Element SW access account password"
                     },
                     "username": {
                        "type": "string",
                        "description": "Element SW access account user-name"
                     },
                     "user": {
                        "type": "string",
                        "description": "Element SW access account user-name"
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "password",
                                    "pass"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "username",
                                    "user"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "na_elementsw_snapshot_restore": {
                  "type": "object",
                  "description": "Element OS Cluster restore snapshot to volume.",
                  "properties": {
                     "src_volume_id": {
                        "type": "string",
                        "description": "ID or Name of source active volume."
                     },
                     "src_snapshot_id": {
                        "type": "string",
                        "description": "ID or Name of an existing snapshot."
                     },
                     "dest_volume_name": {
                        "type": "string",
                        "description": "New Name of destination for restoring the snapshot"
                     },
                     "account_id": {
                        "type": "string",
                        "description": "Account ID or Name of Parent/Source Volume."
                     }
                  },
                  "required": [
                     "src_volume_id",
                     "src_snapshot_id",
                     "dest_volume_name",
                     "account_id"
                  ]
               },
               "na_elementsw_snapshot": {
                  "type": "object",
                  "description": "Create, Modify or Delete Snapshot on Element OS Cluster.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of new snapshot create.\nIf unspecified, date and time when the snapshot was taken is used."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified snapshot should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "src_volume_id": {
                        "type": "string",
                        "description": "ID or Name of active volume."
                     },
                     "account_id": {
                        "type": "string",
                        "description": "Account ID or Name of Parent/Source Volume."
                     },
                     "retention": {
                        "type": "string",
                        "description": "Retention period for the snapshot.\nFormat is 'HH:mm:ss'."
                     },
                     "src_snapshot_id": {
                        "type": "string",
                        "description": "ID or Name of an existing snapshot.\nRequired when C(state=present), to modify snapshot properties.\nRequired when C(state=present), to create snapshot from another snapshot in the volume.\nRequired when C(state=absent), to delete snapshot."
                     },
                     "enable_remote_replication": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Flag, whether to replicate the snapshot created to a remote replication cluster.\nTo enable specify 'true' value."
                     },
                     "snap_mirror_label": {
                        "type": "string",
                        "description": "Label used by SnapMirror software to specify snapshot retention policy on SnapMirror endpoint."
                     },
                     "expiration_time": {
                        "type": "string",
                        "description": "The date and time (format ISO 8601 date string) at which this snapshot will expire."
                     },
                     "password": {
                        "type": "string",
                        "description": "Element OS access account password"
                     },
                     "pass": {
                        "type": "string",
                        "description": "Element OS access account password"
                     },
                     "username": {
                        "type": "string",
                        "description": "Element OS access account user-name"
                     },
                     "user": {
                        "type": "string",
                        "description": "Element OS access account user-name"
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "password",
                                    "pass"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "username",
                                    "user"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "na_elementsw_node": {
                  "type": "object",
                  "description": "Add, remove cluster node on Element Software Cluster.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nElement Software Storage Node operation state.\npresent - To add pending node to participate in cluster data storage.\nabsent  - To remove node from active cluster.  A node cannot be removed if active drives are present.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "node_id": {
                        "type": "array",
                        "description": "List of IDs or Names or IP Address of nodes from cluster used for operation."
                     }
                  },
                  "required": [
                     "node_id"
                  ]
               },
               "na_elementsw_network_interfaces": {
                  "type": "object",
                  "description": "Configure Element SW Node Network Interfaces for Bond 1G and 10G IP address.",
                  "properties": {
                     "method": {
                        "type": "string",
                        "description": "Type of Method used to configure the interface.\nmethod depends on other settings such as the use of a static IP address, which will change the method to static.\nloopback - Used to define the IPv4 loopback interface.\nmanual - Used to define interfaces for which no configuration is done by default.\ndhcp - May be used to obtain an IP address via DHCP.\nstatic - Used to define Ethernet interfaces with statically allocated IPv4 addresses.",
                        "enum": [
                           "loopback",
                           "manual",
                           "dhcp",
                           "static"
                        ]
                     },
                     "ip_address_1g": {
                        "type": "string",
                        "description": "IP address for the 1G network."
                     },
                     "ip_address_10g": {
                        "type": "string",
                        "description": "IP address for the 10G network."
                     },
                     "subnet_1g": {
                        "type": "string",
                        "description": "1GbE Subnet Mask."
                     },
                     "subnet_10g": {
                        "type": "string",
                        "description": "10GbE Subnet Mask."
                     },
                     "gateway_address_1g": {
                        "type": "string",
                        "description": "Router network address to send packets out of the local network."
                     },
                     "gateway_address_10g": {
                        "type": "string",
                        "description": "Router network address to send packets out of the local network."
                     },
                     "mtu_1g": {
                        "type": "string",
                        "description": "Default: 1500\n\nMaximum Transmission Unit for 1GbE, Largest packet size that a network protocol can transmit.\nMust be greater than or equal to 1500 bytes."
                     },
                     "mtu_10g": {
                        "type": "string",
                        "description": "Default: 1500\n\nMaximum Transmission Unit for 10GbE, Largest packet size that a network protocol can transmit.\nMust be greater than or equal to 1500 bytes."
                     },
                     "dns_nameservers": {
                        "type": "array",
                        "description": "List of addresses for domain name servers."
                     },
                     "dns_search_domains": {
                        "type": "array",
                        "description": "List of DNS search domains."
                     },
                     "bond_mode_1g": {
                        "type": "string",
                        "description": "Default: ActivePassive\n\nBond mode for 1GbE configuration.",
                        "enum": [
                           "ActivePassive",
                           "ALB",
                           "LACP"
                        ]
                     },
                     "bond_mode_10g": {
                        "type": "string",
                        "description": "Default: ActivePassive\n\nBond mode for 10GbE configuration.",
                        "enum": [
                           "ActivePassive",
                           "ALB",
                           "LACP"
                        ]
                     },
                     "lacp_1g": {
                        "type": "string",
                        "description": "Default: Slow\n\nLink Aggregation Control Protocol useful only if LACP is selected as the Bond Mode.\nSlow - Packets are transmitted at 30 second intervals.\nFast - Packets are transmitted in 1 second intervals.",
                        "enum": [
                           "Fast",
                           "Slow"
                        ]
                     },
                     "lacp_10g": {
                        "type": "string",
                        "description": "Default: Slow\n\nLink Aggregation Control Protocol useful only if LACP is selected as the Bond Mode.\nSlow - Packets are transmitted at 30 second intervals.\nFast - Packets are transmitted in 1 second intervals.",
                        "enum": [
                           "Fast",
                           "Slow"
                        ]
                     },
                     "virtual_network_tag": {
                        "type": "string",
                        "description": "This is the primary network tag. All nodes in a cluster have the same VLAN tag."
                     }
                  },
                  "required": [
                     "method",
                     "ip_address_1g",
                     "ip_address_10g",
                     "subnet_1g",
                     "subnet_10g",
                     "gateway_address_1g",
                     "gateway_address_10g"
                  ]
               },
               "na_elementsw_ldap": {
                  "type": "object",
                  "description": "Enable, disable ldap, and add ldap users",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Whether the specified volume should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "authType": {
                        "type": "string",
                        "description": "Identifies which user authentication method to use.",
                        "enum": [
                           "DirectBind",
                           "SearchAndBind"
                        ]
                     },
                     "groupSearchBaseDn": {
                        "type": "string",
                        "description": "The base DN of the tree to start the group search (will do a subtree search from here)"
                     },
                     "groupSearchType": {
                        "type": "string",
                        "description": "Controls the default group search filter used",
                        "enum": [
                           "NoGroup",
                           "ActiveDirectory",
                           "MemberDN"
                        ]
                     },
                     "serverURIs": {
                        "type": "string",
                        "description": "A comma-separated list of LDAP server URIs"
                     },
                     "userSearchBaseDN": {
                        "type": "string",
                        "description": "The base DN of the tree to start the search (will do a subtree search from here)"
                     },
                     "searchBindDN": {
                        "type": "string",
                        "description": "A dully qualified DN to log in with to perform an LDAp search for the user (needs read access to the LDAP directory)."
                     },
                     "searchBindPassword": {
                        "type": "string",
                        "description": "The password for the searchBindDN account used for searching"
                     },
                     "userSearchFilter": {
                        "type": "string",
                        "description": "the LDAP Filter to use"
                     },
                     "userDNTemplate": {
                        "type": "string",
                        "description": "A string that is used form a fully qualified user DN."
                     },
                     "groupSearchCustomFilter": {
                        "type": "string",
                        "description": "For use with the CustomFilter Search type"
                     }
                  },
                  "required": [
                     "state"
                  ]
               },
               "na_elementsw_initiators": {
                  "type": "object",
                  "description": "Manage Element Software initiators that allow external clients access to volumes.",
                  "properties": {
                     "initiators": {
                        "type": "string",
                        "description": "A list of objects containing characteristics of each initiator."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified initiator should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     }
                  }
               },
               "na_elementsw_drive": {
                  "type": "object",
                  "description": "Add, Erase or Remove drive for nodes on Element Software Cluster.",
                  "properties": {
                     "drive_id": {
                        "type": "string",
                        "description": "Drive ID or Serial Name of Node drive.\nIf not specified, add and remove action will be performed on all drives of node_id"
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nElement SW Storage Drive operation state.\npresent - To add drive of node to participate in cluster data storage.\nabsent  - To remove the drive from being part of active cluster.\nclean   - Clean-up any residual data persistent on a *removed* drive in a secured method.",
                        "enum": [
                           "present",
                           "absent",
                           "clean"
                        ]
                     },
                     "node_id": {
                        "type": "string",
                        "description": "ID or Name of cluster node."
                     },
                     "force_during_upgrade": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Flag to force drive operation during upgrade."
                     },
                     "force_during_bin_sync": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Flag to force during a bin sync operation."
                     }
                  },
                  "required": [
                     "node_id"
                  ]
               },
               "na_elementsw_cluster_snmp": {
                  "type": "object",
                  "description": "Configure Element Software cluster SNMP.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nThis module enables you to enable SNMP on cluster nodes. When you enable SNMP,           the action applies to all nodes in the cluster, and the values that are passed replace,           in whole, all values set in any previous call to this module.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "snmp_v3_enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Which version of SNMP has to be enabled."
                     },
                     "networks": {
                        "type": "array",
                        "description": "List of networks and what type of access they have to the SNMP servers running on the cluster nodes.\nThis parameter is required if SNMP v3 is disabled."
                     },
                     "usm_users": {
                        "type": "array",
                        "description": "List of users and the type of access they have to the SNMP servers running on the cluster nodes.\nThis parameter is required if SNMP v3 is enabled."
                     }
                  }
               },
               "na_elementsw_cluster_pair": {
                  "type": "object",
                  "description": "Create, delete cluster pair",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the specified cluster pair should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "dest_mvip": {
                        "type": "string",
                        "description": "Destination IP address of the cluster to be paired."
                     },
                     "dest_username": {
                        "type": "string",
                        "description": "Destination username for the cluster to be paired.\nOptional if this is same as source cluster username."
                     },
                     "dest_password": {
                        "type": "string",
                        "description": "Destination password for the cluster to be paired.\nOptional if this is same as source cluster password."
                     }
                  },
                  "required": [
                     "dest_mvip"
                  ]
               },
               "na_elementsw_cluster_config": {
                  "type": "object",
                  "description": "Configure Element Software cluster.",
                  "properties": {
                     "modify_cluster_full_threshold": {
                        "type": "string",
                        "description": "The capacity level at which the cluster generates an event\nRequires a stage3_block_threshold_percent or\nmax_metadata_over_provision_factor or\nstage2_aware_threshold"
                     },
                     "encryption_at_rest": {
                        "type": "string",
                        "description": "enable or disable the Advanced Encryption Standard (AES) 256-bit encryption at rest on the cluster",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "set_ntp_info": {
                        "type": "string",
                        "description": "configure NTP on cluster node\nRequires a list of one or more ntp_servers"
                     },
                     "enable_virtual_volumes": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nEnable the NetApp SolidFire VVols cluster feature"
                     }
                  }
               },
               "na_elementsw_cluster": {
                  "type": "object",
                  "description": "Initialize Element Software node ownership to form a cluster.",
                  "properties": {
                     "management_virtual_ip": {
                        "type": "string",
                        "description": "Floating (virtual) IP address for the cluster on the management network."
                     },
                     "storage_virtual_ip": {
                        "type": "string",
                        "description": "Floating (virtual) IP address for the cluster on the storage (iSCSI) network."
                     },
                     "replica_count": {
                        "type": "string",
                        "description": "Default: 2\n\nNumber of replicas of each piece of data to store in the cluster."
                     },
                     "cluster_admin_username": {
                        "type": "string",
                        "description": "Username for the cluster admin.\nIf not provided, default to login username."
                     },
                     "cluster_admin_password": {
                        "type": "string",
                        "description": "Initial password for the cluster admin account.\nIf not provided, default to login password."
                     },
                     "accept_eula": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Required to indicate your acceptance of the End User License Agreement when creating this cluster.\nTo accept the EULA, set this parameter to true."
                     },
                     "nodes": {
                        "type": "string",
                        "description": "Storage IP (SIP) addresses of the initial set of nodes making up the cluster.\nnodes IP must be in the list."
                     },
                     "attributes": {
                        "type": "array",
                        "description": "List of name-value pairs in JSON object format."
                     }
                  },
                  "required": [
                     "management_virtual_ip",
                     "storage_virtual_ip",
                     "nodes"
                  ]
               },
               "na_elementsw_check_connections": {
                  "type": "object",
                  "description": "Used to test the management connection to the cluster.\nThe test pings the MVIP and SVIP, and executes a simple API method to verify connectivity.",
                  "properties": {
                     "skip": {
                        "type": "string",
                        "description": "Skip checking connection to SVIP or MVIP.",
                        "enum": [
                           "svip",
                           "mvip"
                        ]
                     },
                     "mvip": {
                        "type": "string",
                        "description": "Optionally, use to test connection of a different MVIP.\nThis is not needed to test the connection to the target cluster."
                     },
                     "svip": {
                        "type": "string",
                        "description": "Optionally, use to test connection of a different SVIP.\nThis is not needed to test the connection to the target cluster."
                     }
                  }
               },
               "na_elementsw_backup": {
                  "type": "object",
                  "description": "Create backup",
                  "properties": {
                     "src_volume_id": {
                        "type": "string",
                        "description": "ID of the backup source volume."
                     },
                     "volume_id": {
                        "type": "string",
                        "description": "ID of the backup source volume."
                     },
                     "dest_hostname": {
                        "type": "string",
                        "description": "hostname for the backup source cluster\nwill be set equal to hostname if not specified"
                     },
                     "dest_username": {
                        "type": "string",
                        "description": "username for the backup destination cluster\nwill be set equal to username if not specified"
                     },
                     "dest_password": {
                        "type": "string",
                        "description": "password for the backup destination cluster\nwill be set equal to password if not specified"
                     },
                     "dest_volume_id": {
                        "type": "string",
                        "description": "ID of the backup destination volume"
                     },
                     "format": {
                        "type": "string",
                        "description": "Default: native\n\nBackup format to use",
                        "enum": [
                           "native",
                           "uncompressed"
                        ]
                     },
                     "script": {
                        "type": "string",
                        "description": "the backup script to be executed"
                     },
                     "script_parameters": {
                        "type": "string",
                        "description": "the backup script parameters"
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "src_volume_id",
                                    "volume_id"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "src_volume_id"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "volume_id"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "na_elementsw_admin_users": {
                  "type": "object",
                  "description": "Create, destroy, or update admin users on SolidFire",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Whether the specified account should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "element_username": {
                        "type": "string",
                        "description": "Unique username for this account. (May be 1 to 64 characters in length)."
                     },
                     "element_password": {
                        "type": "string",
                        "description": "The password for the new admin account. Setting the password attribute will always reset your password, even if the password is the same"
                     },
                     "acceptEula": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Boolean, true for accepting Eula, False Eula"
                     },
                     "access": {
                        "type": "string",
                        "description": "A list of type the admin has access to"
                     }
                  },
                  "required": [
                     "state",
                     "element_username"
                  ]
               },
               "na_elementsw_account": {
                  "type": "object",
                  "description": "Create, destroy, or update accounts on Element SW",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Whether the specified account should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "element_username": {
                        "type": "string",
                        "description": "Unique username for this account. (May be 1 to 64 characters in length)."
                     },
                     "account_id": {
                        "type": "string",
                        "description": "Unique username for this account. (May be 1 to 64 characters in length)."
                     },
                     "from_name": {
                        "type": "string",
                        "description": "ID or Name of the account to rename.\nRequired to create an account called 'element_username' by renaming 'from_name'."
                     },
                     "initiator_secret": {
                        "type": "string",
                        "description": "CHAP secret to use for the initiator. Should be 12-16 characters long and impenetrable.\nThe CHAP initiator secrets must be unique and cannot be the same as the target CHAP secret.\nIf not specified, a random secret is created."
                     },
                     "target_secret": {
                        "type": "string",
                        "description": "CHAP secret to use for the target (mutual CHAP authentication).\nShould be 12-16 characters long and impenetrable.\nThe CHAP target secrets must be unique and cannot be the same as the initiator CHAP secret.\nIf not specified, a random secret is created."
                     },
                     "attributes": {
                        "type": "array",
                        "description": "List of Name/Value pairs in JSON object format."
                     },
                     "status": {
                        "type": "string",
                        "description": "Status of the account."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "element_username",
                                    "account_id"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "element_username"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "account_id"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "na_elementsw_access_group": {
                  "type": "object",
                  "description": "Create, destroy, or update access groups on Element Software Cluster.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Whether the specified access group should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "from_name": {
                        "type": "string",
                        "description": "ID or Name of the access group to rename.\nRequired to create a new access group called 'name' by renaming 'from_name'."
                     },
                     "name": {
                        "type": "string",
                        "description": "Name for the access group for create, modify and delete operations."
                     },
                     "src_access_group_id": {
                        "type": "string",
                        "description": "Name for the access group for create, modify and delete operations."
                     },
                     "initiators": {
                        "type": "array",
                        "description": "List of initiators to include in the access group. If unspecified, the access group will start out without configured initiators."
                     },
                     "volumes": {
                        "type": "array",
                        "description": "List of volumes to initially include in the volume access group. If unspecified, the access group will start without any volumes.\nIt accepts either volume_name or volume_id"
                     },
                     "account_id": {
                        "type": "string",
                        "description": "Account ID for the owner of this volume.\nIt accepts either account_name or account_id\nif account_id is digit, it will consider as account_id\nIf account_id is string, it will consider as account_name"
                     },
                     "virtual_network_id": {
                        "type": "string",
                        "description": "The ID of the Element SW Software Cluster Virtual Network ID to associate the access group with."
                     },
                     "virtual_network_tags": {
                        "type": "string",
                        "description": "The ID of the VLAN Virtual Network Tag to associate the access group with."
                     },
                     "attributes": {
                        "type": "array",
                        "description": "List of Name/Value pairs in JSON object format."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "src_access_group_id"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "src_access_group_id"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "sf_volume_manager": {
                  "type": "object",
                  "description": "Create, destroy, or update volumes on SolidFire",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Whether the specified volume should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the volume to manage."
                     },
                     "account_id": {
                        "type": "string",
                        "description": "Account ID for the owner of this volume."
                     },
                     "512emulation": {
                        "type": "string",
                        "description": "Should the volume provide 512-byte sector emulation?\nRequired when C(state=present)"
                     },
                     "qos": {
                        "type": "string",
                        "description": "Initial quality of service settings for this volume. Configure as dict in playbooks."
                     },
                     "attributes": {
                        "type": "string",
                        "description": "A YAML dictionary of attributes that you would like to apply on this volume."
                     },
                     "volume_id": {
                        "type": "string",
                        "description": "The ID of the volume to manage or update.\nIn order to create multiple volumes with the same name, but different volume_ids, please declare the I(volume_id) parameter with an arbitrary value. However, the specified volume_id will not be assigned to the newly created volume (since it's an auto-generated property)."
                     },
                     "size": {
                        "type": "string",
                        "description": "The size of the volume in (size_unit).\nRequired when C(state = present)."
                     },
                     "size_unit": {
                        "type": "string",
                        "description": "Default: gb\n\nThe unit used to interpret the size parameter.",
                        "enum": [
                           "bytes",
                           "b",
                           "kb",
                           "mb",
                           "gb",
                           "tb",
                           "pb",
                           "eb",
                           "zb",
                           "yb"
                        ]
                     },
                     "access": {
                        "type": "string",
                        "description": "Access allowed for the volume.\nreadOnly: Only read operations are allowed.\nreadWrite: Reads and writes are allowed.\nlocked: No reads or writes are allowed.\nreplicationTarget: Identify a volume as the target volume for a paired set of volumes. If the volume is not paired, the access status is locked.\nIf unspecified, the access settings of the clone will be the same as the source.",
                        "enum": [
                           "readOnly",
                           "readWrite",
                           "locked",
                           "replicationTarget"
                        ]
                     }
                  },
                  "required": [
                     "state",
                     "name",
                     "account_id"
                  ]
               },
               "sf_volume_access_group_manager": {
                  "type": "object",
                  "description": "Create, destroy, or update volume access groups on SolidFire",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Whether the specified volume access group should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "Name of the volume access group. It is not required to be unique, but recommended."
                     },
                     "initiators": {
                        "type": "array",
                        "description": "List of initiators to include in the volume access group. If unspecified, the access group will start out without configured initiators."
                     },
                     "volumes": {
                        "type": "array",
                        "description": "List of volumes to initially include in the volume access group. If unspecified, the access group will start without any volumes."
                     },
                     "virtual_network_id": {
                        "type": "string",
                        "description": "The ID of the SolidFire Virtual Network ID to associate the volume access group with."
                     },
                     "virtual_network_tags": {
                        "type": "string",
                        "description": "The ID of the VLAN Virtual Network Tag to associate the volume access group with."
                     },
                     "attributes": {
                        "type": "array",
                        "description": "List of Name/Value pairs in JSON object format."
                     },
                     "volume_access_group_id": {
                        "type": "string",
                        "description": "The ID of the volume access group to modify or delete."
                     }
                  },
                  "required": [
                     "state",
                     "name"
                  ]
               },
               "sf_snapshot_schedule_manager": {
                  "type": "object",
                  "description": "Create, destroy, or update accounts on SolidFire",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Whether the specified schedule should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "paused": {
                        "type": "string",
                        "description": "Pause / Resume a schedule."
                     },
                     "recurring": {
                        "type": "string",
                        "description": "Should the schedule recur?"
                     },
                     "time_interval_days": {
                        "type": "string",
                        "description": "Default: 1\n\nTime interval in days."
                     },
                     "time_interval_hours": {
                        "type": "string",
                        "description": "Time interval in hours."
                     },
                     "time_interval_minutes": {
                        "type": "string",
                        "description": "Time interval in minutes."
                     },
                     "name": {
                        "type": "string",
                        "description": "Name for the snapshot schedule."
                     },
                     "snapshot_name": {
                        "type": "string",
                        "description": "Name for the created snapshots."
                     },
                     "volumes": {
                        "type": "string",
                        "description": "Volume IDs that you want to set the snapshot schedule for.\nAt least 1 volume ID is required for creating a new schedule.\nrequired when C(state=present)"
                     },
                     "retention": {
                        "type": "string",
                        "description": "Retention period for the snapshot.\nFormat is 'HH:mm:ss'."
                     },
                     "schedule_id": {
                        "type": "string",
                        "description": "The schedule ID for the schedule that you want to update or delete."
                     },
                     "starting_date": {
                        "type": "string",
                        "description": "Starting date for the schedule.\nRequired when C(state=present).\nPlease use two '-' in the above format, or you may see an error- TypeError, is not JSON serializable description.\nFormat: C(2016--12--01T00:00:00Z)"
                     }
                  },
                  "required": [
                     "state",
                     "name"
                  ]
               },
               "sf_check_connections": {
                  "type": "object",
                  "description": "Used to test the management connection to the cluster.\nThe test pings the MVIP and SVIP, and executes a simple API method to verify connectivity.",
                  "properties": {
                     "skip": {
                        "type": "string",
                        "description": "Skip checking connection to SVIP or MVIP.",
                        "enum": [
                           "svip",
                           "mvip"
                        ]
                     },
                     "mvip": {
                        "type": "string",
                        "description": "Optionally, use to test connection of a different MVIP.\nThis is not needed to test the connection to the target cluster."
                     },
                     "svip": {
                        "type": "string",
                        "description": "Optionally, use to test connection of a different SVIP.\nThis is not needed to test the connection to the target cluster."
                     }
                  }
               },
               "sf_account_manager": {
                  "type": "object",
                  "description": "Create, destroy, or update accounts on SolidFire",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Whether the specified account should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "Unique username for this account. (May be 1 to 64 characters in length)."
                     },
                     "new_name": {
                        "type": "string",
                        "description": "New name for the user account."
                     },
                     "initiator_secret": {
                        "type": "string",
                        "description": "CHAP secret to use for the initiator. Should be 12-16 characters long and impenetrable.\nThe CHAP initiator secrets must be unique and cannot be the same as the target CHAP secret.\nIf not specified, a random secret is created."
                     },
                     "target_secret": {
                        "type": "string",
                        "description": "CHAP secret to use for the target (mutual CHAP authentication).\nShould be 12-16 characters long and impenetrable.\nThe CHAP target secrets must be unique and cannot be the same as the initiator CHAP secret.\nIf not specified, a random secret is created."
                     },
                     "attributes": {
                        "type": "array",
                        "description": "List of Name/Value pairs in JSON object format."
                     },
                     "account_id": {
                        "type": "string",
                        "description": "The ID of the account to manage or update."
                     },
                     "status": {
                        "type": "string",
                        "description": "Status of the account."
                     }
                  },
                  "required": [
                     "state",
                     "name"
                  ]
               },
               "na_ontap_gather_facts": {
                  "type": "object",
                  "description": "This module allows you to gather various information about ONTAP configuration",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: info\n\nReturns \"info\"",
                        "enum": [
                           "info"
                        ]
                     },
                     "gather_subset": {
                        "type": "string",
                        "description": "Default: all\n\nWhen supplied, this argument will restrict the facts collected to a given subset.  Possible values for this argument include \"aggregate_info\", \"cluster_node_info\", \"igroup_info\", \"lun_info\", \"net_dns_info\", \"net_ifgrp_info\", \"net_interface_info\", \"net_port_info\", \"nvme_info\", \"nvme_interface_info\", \"nvme_namespace_info\", \"nvme_subsystem_info\", \"ontap_version\", \"qos_adaptive_policy_info\", \"qos_policy_info\", \"security_key_manager_key_info\", \"security_login_account_info\", \"storage_failover_info\", \"volume_info\", \"vserver_info\", \"vserver_login_banner_info\", \"vserver_motd_info\", \"vserver_nfs_info\" Can specify a list of values to include a larger subset.  Values can also be used with an initial C(M(!)) to specify that a specific subset should not be collected.\nnvme is supported with ONTAP 9.4 onwards.\nuse \"help\" to get a list of supported facts for your system."
                     }
                  }
               },
               "na_cdot_volume": {
                  "type": "object",
                  "description": "Create or destroy volumes on NetApp cDOT",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Whether the specified volume should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the volume to manage."
                     },
                     "infinite": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nSet True if the volume is an Infinite Volume."
                     },
                     "online": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nWhether the specified volume is online, or not."
                     },
                     "aggregate_name": {
                        "type": "string",
                        "description": "The name of the aggregate the flexvol should exist on. Required when C(state=present)."
                     },
                     "size": {
                        "type": "string",
                        "description": "The size of the volume in (size_unit). Required when C(state=present)."
                     },
                     "size_unit": {
                        "type": "string",
                        "description": "Default: gb\n\nThe unit used to interpret the size parameter.",
                        "enum": [
                           "bytes",
                           "b",
                           "kb",
                           "mb",
                           "gb",
                           "tb",
                           "pb",
                           "eb",
                           "zb",
                           "yb"
                        ]
                     },
                     "vserver": {
                        "type": "string",
                        "description": "Name of the vserver to use."
                     },
                     "junction_path": {
                        "type": "string",
                        "description": "Junction path where to mount the volume"
                     },
                     "export_policy": {
                        "type": "string",
                        "description": "Default: default\n\nExport policy to set for the specified junction path."
                     },
                     "snapshot_policy": {
                        "type": "string",
                        "description": "Default: default\n\nSnapshot policy to set for the specified volume."
                     }
                  },
                  "required": [
                     "state",
                     "name",
                     "vserver"
                  ]
               },
               "na_cdot_user_role": {
                  "type": "object",
                  "description": "Create or destroy user roles",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Whether the specified user should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the role to manage."
                     },
                     "command_directory_name": {
                        "type": "string",
                        "description": "The command or command directory to which the role has an access."
                     },
                     "access_level": {
                        "type": "string",
                        "description": "Default: all\n\nThe name of the role to manage.",
                        "enum": [
                           "none",
                           "readonly",
                           "all"
                        ]
                     },
                     "vserver": {
                        "type": "string",
                        "description": "The name of the vserver to use."
                     }
                  },
                  "required": [
                     "state",
                     "name",
                     "command_directory_name",
                     "vserver"
                  ]
               },
               "na_cdot_user": {
                  "type": "object",
                  "description": "Create or destroy users.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Whether the specified user should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the user to manage."
                     },
                     "application": {
                        "type": "string",
                        "description": "Applications to grant access to.",
                        "enum": [
                           "console",
                           "http",
                           "ontapi",
                           "rsh",
                           "snmp",
                           "sp",
                           "ssh",
                           "telnet"
                        ]
                     },
                     "authentication_method": {
                        "type": "string",
                        "description": "Authentication method for the application.\nNot all authentication methods are valid for an application.\nValid authentication methods for each application are as denoted in I(authentication_choices_description).\npassword for console application\npassword, domain, nsswitch, cert for http application.\npassword, domain, nsswitch, cert for ontapi application.\ncommunity for snmp application (when creating SNMPv1 and SNMPv2 users).\nusm and community for snmp application (when creating SNMPv3 users).\npassword for sp application.\npassword for rsh application.\npassword for telnet application.\npassword, publickey, domain, nsswitch for ssh application.",
                        "enum": [
                           "community",
                           "password",
                           "publickey",
                           "domain",
                           "nsswitch",
                           "usm"
                        ]
                     },
                     "set_password": {
                        "type": "string",
                        "description": "Password for the user account.\nIt is ignored for creating snmp users, but is required for creating non-snmp users.\nFor an existing user, this value will be used as the new password."
                     },
                     "role_name": {
                        "type": "string",
                        "description": "The name of the role. Required when C(state=present)"
                     },
                     "vserver": {
                        "type": "string",
                        "description": "The name of the vserver to use."
                     }
                  },
                  "required": [
                     "state",
                     "name",
                     "application",
                     "authentication_method",
                     "vserver"
                  ]
               },
               "na_cdot_svm": {
                  "type": "object",
                  "description": "Create or destroy svm on NetApp cDOT",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Whether the specified SVM should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the SVM to manage."
                     },
                     "root_volume": {
                        "type": "string",
                        "description": "Root volume of the SVM. Required when C(state=present)."
                     },
                     "root_volume_aggregate": {
                        "type": "string",
                        "description": "The aggregate on which the root volume will be created.\nRequired when C(state=present)."
                     },
                     "root_volume_security_style": {
                        "type": "string",
                        "description": "Security Style of the root volume.\nWhen specified as part of the vserver-create, this field represents the security style for the Vserver root volume.\nWhen specified as part of vserver-get-iter call, this will return the list of matching Vservers.\nPossible values are 'unix', 'ntfs', 'mixed'.\nThe 'unified' security style, which applies only to Infinite Volumes, cannot be applied to a Vserver's root volume.\nValid options are \"unix\" for NFS, \"ntfs\" for CIFS, \"mixed\" for Mixed, \"unified\" for Unified.\nRequired when C(state=present)",
                        "enum": [
                           "unix",
                           "ntfs",
                           "mixed",
                           "unified"
                        ]
                     }
                  },
                  "required": [
                     "state",
                     "name"
                  ]
               },
               "na_cdot_qtree": {
                  "type": "object",
                  "description": "Create or destroy Qtrees.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Whether the specified Qtree should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the Qtree to manage."
                     },
                     "flexvol_name": {
                        "type": "string",
                        "description": "The name of the FlexVol the Qtree should exist on. Required when C(state=present)."
                     },
                     "vserver": {
                        "type": "string",
                        "description": "The name of the vserver to use."
                     }
                  },
                  "required": [
                     "state",
                     "name",
                     "vserver"
                  ]
               },
               "na_cdot_lun": {
                  "type": "object",
                  "description": "Create, destroy, resize luns on NetApp cDOT.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Whether the specified lun should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the lun to manage."
                     },
                     "flexvol_name": {
                        "type": "string",
                        "description": "The name of the FlexVol the lun should exist on.\nRequired when C(state=present)."
                     },
                     "size": {
                        "type": "string",
                        "description": "The size of the lun in C(size_unit).\nRequired when C(state=present)."
                     },
                     "size_unit": {
                        "type": "string",
                        "description": "Default: gb\n\nThe unit used to interpret the size parameter.",
                        "enum": [
                           "bytes",
                           "b",
                           "kb",
                           "mb",
                           "gb",
                           "tb",
                           "pb",
                           "eb",
                           "zb",
                           "yb"
                        ]
                     },
                     "force_resize": {
                        "type": "string",
                        "description": "Forcibly reduce the size. This is required for reducing the size of the LUN to avoid accidentally reducing the LUN size."
                     },
                     "force_remove": {
                        "type": "string",
                        "description": "If \"true\", override checks that prevent a LUN from being destroyed if it is online and mapped.\nIf \"false\", destroying an online and mapped LUN will fail."
                     },
                     "force_remove_fenced": {
                        "type": "string",
                        "description": "If \"true\", override checks that prevent a LUN from being destroyed while it is fenced.\nIf \"false\", attempting to destroy a fenced LUN will fail.\nThe default if not specified is \"false\". This field is available in Data ONTAP 8.2 and later."
                     },
                     "vserver": {
                        "type": "string",
                        "description": "The name of the vserver to use."
                     }
                  },
                  "required": [
                     "state",
                     "name",
                     "vserver"
                  ]
               },
               "na_cdot_license": {
                  "type": "object",
                  "description": "Add or remove licenses on NetApp ONTAP.",
                  "properties": {
                     "remove_unused": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Remove licenses that have no controller affiliation in the cluster."
                     },
                     "remove_expired": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Remove licenses that have expired in the cluster."
                     },
                     "serial_number": {
                        "type": "string",
                        "description": "Serial number of the node associated with the license.\nThis parameter is used primarily when removing license for a specific service.\nIf this parameter is not provided, the cluster serial number is used by default."
                     },
                     "licenses": {
                        "type": "array",
                        "description": "List of licenses to add or remove.\nPlease note that trying to remove a non-existent license will throw an error."
                     }
                  }
               },
               "na_cdot_aggregate": {
                  "type": "object",
                  "description": "Create or destroy aggregates on NetApp cDOT.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Whether the specified aggregate should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the aggregate to manage."
                     },
                     "disk_count": {
                        "type": "string",
                        "description": "Number of disks to place into the aggregate, including parity disks.\nThe disks in this newly-created aggregate come from the spare disk pool.\nThe smallest disks in this pool join the aggregate first, unless the C(disk-size) argument is provided.\nEither C(disk-count) or C(disks) must be supplied. Range [0..2^31-1].\nRequired when C(state=present)."
                     }
                  },
                  "required": [
                     "state",
                     "name"
                  ]
               },
               "infini_vol": {
                  "type": "object",
                  "description": "This module creates, deletes or modifies volume on Infinibox.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Volume Name"
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nCreates/Modifies volume when present or removes when absent",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "size": {
                        "type": "string",
                        "description": "Volume size in MB, GB or TB units. See examples."
                     },
                     "pool": {
                        "type": "string",
                        "description": "Pool that volume will reside on"
                     }
                  },
                  "required": [
                     "name",
                     "pool"
                  ]
               },
               "infini_pool": {
                  "type": "object",
                  "description": "This module to creates, deletes or modifies pools on Infinibox.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Pool Name"
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nCreates/Modifies Pool when present or removes when absent",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "size": {
                        "type": "string",
                        "description": "Pool Physical Capacity in MB, GB or TB units. If pool size is not set on pool creation, size will be equal to 1TB. See examples."
                     },
                     "vsize": {
                        "type": "string",
                        "description": "Pool Virtual Capacity in MB, GB or TB units. If pool vsize is not set on pool creation, Virtual Capacity will be equal to Physical Capacity. See examples."
                     },
                     "ssd_cache": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nEnable/Disable SSD Cache on Pool"
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "infini_host": {
                  "type": "object",
                  "description": "This module creates, deletes or modifies hosts on Infinibox.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Host Name"
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nCreates/Modifies Host when present or removes when absent",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "wwns": {
                        "type": "array",
                        "description": "List of wwns of the host"
                     },
                     "volume": {
                        "type": "string",
                        "description": "Volume name to map to the host"
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "infini_fs": {
                  "type": "object",
                  "description": "This module creates, deletes or modifies filesystems on Infinibox.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "File system name."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nCreates/Modifies file system when present or removes when absent.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "size": {
                        "type": "string",
                        "description": "File system size in MB, GB or TB units. See examples."
                     },
                     "pool": {
                        "type": "string",
                        "description": "Pool that will host file system."
                     }
                  },
                  "required": [
                     "name",
                     "pool"
                  ]
               },
               "infini_export_client": {
                  "type": "object",
                  "description": "This module creates, deletes or modifys NFS client(s) for existing exports on Infinibox.",
                  "properties": {
                     "client": {
                        "type": "string",
                        "description": "Client IP or Range. Ranges can be defined as follows 192.168.0.1-192.168.0.254."
                     },
                     "name": {
                        "type": "string",
                        "description": "Client IP or Range. Ranges can be defined as follows 192.168.0.1-192.168.0.254."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nCreates/Modifies client when present and removes when absent.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "access_mode": {
                        "type": "string",
                        "description": "Default: RW\n\nRead Write or Read Only Access.",
                        "enum": [
                           "RW",
                           "RO"
                        ]
                     },
                     "no_root_squash": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Don't squash root user to anonymous. Will be set to \"no\" on creation if not specified explicitly."
                     },
                     "export": {
                        "type": "string",
                        "description": "Name of the export."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "client",
                                    "name"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "client"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "infini_export": {
                  "type": "object",
                  "description": "This module creates, deletes or modifies NFS exports on Infinibox.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Export name. Should always start with C(/). (ex. name=/data)"
                     },
                     "export": {
                        "type": "string",
                        "description": "Export name. Should always start with C(/). (ex. name=/data)"
                     },
                     "path": {
                        "type": "string",
                        "description": "Export name. Should always start with C(/). (ex. name=/data)"
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nCreates/Modifies export when present and removes when absent.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "inner_path": {
                        "type": "string",
                        "description": "Default: /\n\nInternal path of the export."
                     },
                     "client_list": {
                        "type": "array",
                        "description": "Default: All Hosts(*), RW, no_root_squash: True\n\nList of dictionaries with client entries. See examples. Check infini_export_client module to modify individual NFS client entries for export."
                     },
                     "filesystem": {
                        "type": "string",
                        "description": "Name of exported file system."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "export",
                                    "path"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "export"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "path"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "ibm_sa_vol_map": {
                  "type": "object",
                  "description": "This module maps volumes to or unmaps them from the hosts on IBM Spectrum Accelerate Family storage systems.",
                  "properties": {
                     "vol": {
                        "type": "string",
                        "description": "Volume name."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhen the state is present the volume is mapped. When the state is absent, the volume is meant to be unmapped.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "cluster": {
                        "type": "string",
                        "description": "Maps the volume to a cluster."
                     },
                     "host": {
                        "type": "string",
                        "description": "Maps the volume to a host."
                     },
                     "lun": {
                        "type": "string",
                        "description": "The LUN identifier."
                     },
                     "override": {
                        "type": "string",
                        "description": "Overrides the existing volume mapping."
                     }
                  },
                  "required": [
                     "vol",
                     "state"
                  ]
               },
               "ibm_sa_vol": {
                  "type": "object",
                  "description": "This module creates or deletes volumes to be used on IBM Spectrum Accelerate Family storage systems.",
                  "properties": {
                     "vol": {
                        "type": "string",
                        "description": "Volume name."
                     },
                     "pool": {
                        "type": "string",
                        "description": "Volume pool."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nVolume state.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "size": {
                        "type": "string",
                        "description": "Volume size."
                     }
                  },
                  "required": [
                     "vol",
                     "state"
                  ]
               },
               "ibm_sa_pool": {
                  "type": "object",
                  "description": "This module creates or deletes pools to be used on IBM Spectrum Accelerate Family storage systems",
                  "properties": {
                     "pool": {
                        "type": "string",
                        "description": "Pool name."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nPool state.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "size": {
                        "type": "string",
                        "description": "Pool size in GB"
                     },
                     "snapshot_size": {
                        "type": "string",
                        "description": "Pool snapshot size in GB"
                     },
                     "domain": {
                        "type": "string",
                        "description": "Adds the pool to the specified domain."
                     },
                     "perf_class": {
                        "type": "string",
                        "description": "Assigns a perf_class to the pool."
                     }
                  },
                  "required": [
                     "pool",
                     "state"
                  ]
               },
               "ibm_sa_host_ports": {
                  "type": "object",
                  "description": "This module adds ports to or removes them from the hosts on IBM Spectrum Accelerate Family storage systems.",
                  "properties": {
                     "host": {
                        "type": "string",
                        "description": "Host name."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nHost ports state.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "iscsi_name": {
                        "type": "string",
                        "description": "iSCSI initiator name."
                     },
                     "fcaddress": {
                        "type": "string",
                        "description": "Fiber channel address."
                     },
                     "num_of_visible_targets": {
                        "type": "string",
                        "description": "Number of visible targets."
                     }
                  },
                  "required": [
                     "host",
                     "state"
                  ]
               },
               "ibm_sa_host": {
                  "type": "object",
                  "description": "This module adds hosts to or removes them from IBM Spectrum Accelerate Family storage systems.",
                  "properties": {
                     "host": {
                        "type": "string",
                        "description": "Host name."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nHost state.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "cluster": {
                        "type": "string",
                        "description": "The name of the cluster to include the host."
                     },
                     "domain": {
                        "type": "string",
                        "description": "The domains the cluster will be attached to. To include more than one domain, separate domain names with commas. To include all existing domains, use an asterisk (\"*\")."
                     },
                     "iscsi_chap_name": {
                        "type": "string",
                        "description": "The host's CHAP name identifier"
                     },
                     "iscsi_chap_secret": {
                        "type": "string",
                        "description": "The password of the initiator used to authenticate to the system when CHAP is enable"
                     }
                  },
                  "required": [
                     "host",
                     "state"
                  ]
               },
               "ibm_sa_domain": {
                  "type": "object",
                  "description": "This module can be used to add domains to or removes them from IBM Spectrum Accelerate Family storage systems.",
                  "properties": {
                     "domain": {
                        "type": "string",
                        "description": "Name of the domain to be managed."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nThe desired state of the domain.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "ldap_id": {
                        "type": "string",
                        "description": "ldap id to add to the domain."
                     },
                     "size": {
                        "type": "string",
                        "description": "Size of the domain."
                     },
                     "hard_capacity": {
                        "type": "string",
                        "description": "Hard capacity of the domain."
                     },
                     "soft_capacity": {
                        "type": "string",
                        "description": "Soft capacity of the domain."
                     },
                     "max_cgs": {
                        "type": "string",
                        "description": "Number of max cgs."
                     },
                     "max_dms": {
                        "type": "string",
                        "description": "Number of max dms."
                     },
                     "max_mirrors": {
                        "type": "string",
                        "description": "Number of max_mirrors."
                     },
                     "max_pools": {
                        "type": "string",
                        "description": "Number of max_pools."
                     },
                     "max_volumes": {
                        "type": "string",
                        "description": "Number of max_volumes."
                     },
                     "perf_class": {
                        "type": "string",
                        "description": "Add the domain to a performance class."
                     }
                  },
                  "required": [
                     "domain",
                     "state"
                  ]
               },
               "ss_3par_cpg": {
                  "type": "object",
                  "description": "Create and delete CPG on HPE 3PAR.",
                  "properties": {
                     "cpg_name": {
                        "type": "string",
                        "description": "Name of the CPG."
                     },
                     "disk_type": {
                        "type": "string",
                        "description": "Specifies that physical disks must have the specified device type.",
                        "enum": [
                           "FC",
                           "NL",
                           "SSD"
                        ]
                     },
                     "domain": {
                        "type": "string",
                        "description": "Specifies the name of the domain in which the object will reside."
                     },
                     "growth_increment": {
                        "type": "string",
                        "description": "Specifies the growth increment(in MiB, GiB or TiB) the amount of logical disk storage created on each auto-grow operation."
                     },
                     "growth_limit": {
                        "type": "string",
                        "description": "Specifies that the autogrow operation is limited to the specified storage amount that sets the growth limit(in MiB, GiB or TiB)."
                     },
                     "growth_warning": {
                        "type": "string",
                        "description": "Specifies that the threshold(in MiB, GiB or TiB) of used logical disk space when exceeded results in a warning alert."
                     },
                     "high_availability": {
                        "type": "string",
                        "description": "Specifies that the layout must support the failure of one port pair, one cage, or one magazine.",
                        "enum": [
                           "PORT",
                           "CAGE",
                           "MAG"
                        ]
                     },
                     "raid_type": {
                        "type": "string",
                        "description": "Specifies the RAID type for the logical disk.",
                        "enum": [
                           "R0",
                           "R1",
                           "R5",
                           "R6"
                        ]
                     },
                     "set_size": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Specifies the set size in the number of chunklets."
                     },
                     "state": {
                        "type": "string",
                        "description": "Whether the specified CPG should exist or not.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "secure": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Specifies whether the certificate needs to be validated while communicating."
                     }
                  },
                  "required": [
                     "cpg_name",
                     "state"
                  ]
               },
               "gluster_volume": {
                  "type": "object",
                  "description": "Create, remove, start, stop and tune GlusterFS volumes",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The volume name."
                     },
                     "volume": {
                        "type": "string",
                        "description": "The volume name."
                     },
                     "state": {
                        "type": "string",
                        "description": "Use present/absent ensure if a volume exists or not. Use started/stopped to control its availability.",
                        "enum": [
                           "absent",
                           "present",
                           "started",
                           "stopped"
                        ]
                     },
                     "cluster": {
                        "type": "array",
                        "description": "List of hosts to use for probing and brick setup."
                     },
                     "host": {
                        "type": "string",
                        "description": "Override local hostname (for peer probing purposes)."
                     },
                     "replicas": {
                        "type": "string",
                        "description": "Replica count for volume."
                     },
                     "arbiters": {
                        "type": "string",
                        "description": "Arbiter count for volume."
                     },
                     "stripes": {
                        "type": "string",
                        "description": "Stripe count for volume."
                     },
                     "disperses": {
                        "type": "string",
                        "description": "Disperse count for volume."
                     },
                     "redundancies": {
                        "type": "string",
                        "description": "Redundancy count for volume."
                     },
                     "transport": {
                        "type": "string",
                        "description": "Default: tcp\n\nTransport type for volume.",
                        "enum": [
                           "tcp",
                           "rdma",
                           "tcp,rdma"
                        ]
                     },
                     "bricks": {
                        "type": "string",
                        "description": "Brick paths on servers. Multiple brick paths can be separated by commas."
                     },
                     "brick": {
                        "type": "string",
                        "description": "Brick paths on servers. Multiple brick paths can be separated by commas."
                     },
                     "start_on_create": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nControls whether the volume is started after creation or not."
                     },
                     "rebalance": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nControls whether the cluster is rebalanced after changes."
                     },
                     "directory": {
                        "type": "string",
                        "description": "Directory for limit-usage."
                     },
                     "options": {
                        "type": "object",
                        "description": "A dictionary/hash with options/settings for the volume."
                     },
                     "quota": {
                        "type": "string",
                        "description": "Quota value for limit-usage (be sure to use 10.0MB instead of 10MB, see quota list)."
                     },
                     "force": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "If brick is being created in the root partition, module will fail. Set force to true to override this behaviour."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "volume"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "volume"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "bricks",
                                    "brick"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "gluster_peer": {
                  "type": "object",
                  "description": "Create or diminish a GlusterFS trusted storage pool. A set of nodes can be added into an existing trusted storage pool or a new storage pool can be formed. Or, nodes can be removed from an existing trusted storage pool.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDetermines whether the nodes should be attached to the pool or removed from the pool. If the state is present, nodes will be attached to the pool. If state is absent, nodes will be detached from the pool.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "nodes": {
                        "type": "array",
                        "description": "List of nodes that have to be probed into the pool."
                     },
                     "force": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: false\n\nApplicable only while removing the nodes from the pool. gluster will refuse to detach a node from the pool if any one of the node is down, in such cases force can be used."
                     }
                  },
                  "required": [
                     "state",
                     "nodes"
                  ]
               },
               "gluster_heal_info": {
                  "type": "object",
                  "description": "Gather facts about either self-heal or rebalance status.\nThis module was called C(gluster_heal_facts) before Ansible 2.9, returning C(ansible_facts). Note that the M(gluster_heal_info) module no longer returns C(ansible_facts)!",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The volume name."
                     },
                     "volume": {
                        "type": "string",
                        "description": "The volume name."
                     },
                     "status_filter": {
                        "type": "string",
                        "description": "Default: self-heal\n\nDetermines which facts are to be returned.\nIf the C(status_filter) is C(self-heal), status of self-heal, along with the number of files still in process are returned.\nIf the C(status_filter) is C(rebalance), rebalance status is returned.",
                        "enum": [
                           "self-heal",
                           "rebalance"
                        ]
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "volume"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "volume"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "emc_vnx_sg_member": {
                  "type": "object",
                  "description": "This module manages the members of an existing storage group.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the Storage group to manage."
                     },
                     "lunid": {
                        "type": "string",
                        "description": "Lun id to be added."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIndicates the desired lunid state.\nC(present) ensures specified lunid is present in the Storage Group.\nC(absent) ensures specified lunid is absent from Storage Group.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     }
                  },
                  "required": [
                     "name",
                     "lunid"
                  ]
               },
               "subversion": {
                  "type": "object",
                  "description": "Deploy given repository URL / revision to dest. If dest exists, update to the specified revision, otherwise perform a checkout.",
                  "properties": {
                     "repo": {
                        "type": "string",
                        "description": "The subversion URL to the repository."
                     },
                     "name": {
                        "type": "string",
                        "description": "The subversion URL to the repository."
                     },
                     "repository": {
                        "type": "string",
                        "description": "The subversion URL to the repository."
                     },
                     "dest": {
                        "type": "string",
                        "description": "Absolute path where the repository should be deployed."
                     },
                     "revision": {
                        "type": "string",
                        "description": "Default: HEAD\n\nSpecific revision to checkout."
                     },
                     "version": {
                        "type": "string",
                        "description": "Default: HEAD\n\nSpecific revision to checkout."
                     },
                     "force": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nIf C(yes), modified files will be discarded. If C(no), module will fail if it encounters modified files. Prior to 1.9 the default was C(yes)."
                     },
                     "in_place": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nIf the directory exists, then the working copy will be checked-out over-the-top using svn checkout --force; if force is specified then existing files with different content are reverted"
                     },
                     "username": {
                        "type": "string",
                        "description": "C(--username) parameter passed to svn."
                     },
                     "password": {
                        "type": "string",
                        "description": "C(--password) parameter passed to svn."
                     },
                     "executable": {
                        "type": "string",
                        "description": "Path to svn executable to use. If not supplied, the normal mechanism for resolving binary paths will be used."
                     },
                     "checkout": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nIf C(no), do not check out the repository if it does not exist locally."
                     },
                     "update": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nIf C(no), do not retrieve new revisions from the origin repository."
                     },
                     "export": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nIf C(yes), do export instead of checkout/update."
                     },
                     "switch": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nIf C(no), do not call svn switch before update."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "repo",
                                    "name",
                                    "repository"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "repo"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "repository"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "revision",
                                    "version"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "hg": {
                  "type": "object",
                  "description": "Manages Mercurial (hg) repositories. Supports SSH, HTTP/S and local address.",
                  "properties": {
                     "repo": {
                        "type": "string",
                        "description": "The repository address."
                     },
                     "name": {
                        "type": "string",
                        "description": "The repository address."
                     },
                     "dest": {
                        "type": "string",
                        "description": "Absolute path of where the repository should be cloned to. This parameter is required, unless clone and update are set to no"
                     },
                     "revision": {
                        "type": "string",
                        "description": "Equivalent C(-r) option in hg command which could be the changeset, revision number, branch name or even tag."
                     },
                     "version": {
                        "type": "string",
                        "description": "Equivalent C(-r) option in hg command which could be the changeset, revision number, branch name or even tag."
                     },
                     "force": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nDiscards uncommitted changes. Runs C(hg update -C).  Prior to 1.9, the default was `yes`."
                     },
                     "purge": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nDeletes untracked files. Runs C(hg purge)."
                     },
                     "update": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nIf C(no), do not retrieve new revisions from the origin repository"
                     },
                     "clone": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nIf C(no), do not clone the repository if it does not exist locally."
                     },
                     "executable": {
                        "type": "string",
                        "description": "Path to hg executable to use. If not supplied, the normal mechanism for resolving binary paths will be used."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "repo",
                                    "name"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "repo"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "revision",
                                    "version"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "gitlab_user": {
                  "type": "object",
                  "description": "When the user does not exist in GitLab, it will be created.\nWhen the user does exists and state=absent, the user will be deleted.\nWhen changes are made to user, the user will be updated.",
                  "properties": {
                     "server_url": {
                        "type": "string",
                        "description": "The URL of the GitLab server, with protocol (i.e. http or https)."
                     },
                     "login_user": {
                        "type": "string",
                        "description": "GitLab user name."
                     },
                     "login_password": {
                        "type": "string",
                        "description": "GitLab password for login_user"
                     },
                     "api_token": {
                        "type": "string",
                        "description": "GitLab token for logging in."
                     },
                     "login_token": {
                        "type": "string",
                        "description": "GitLab token for logging in."
                     },
                     "name": {
                        "type": "string",
                        "description": "Name of the user you want to create"
                     },
                     "username": {
                        "type": "string",
                        "description": "The username of the user."
                     },
                     "password": {
                        "type": "string",
                        "description": "The password of the user.\nGitLab server enforces minimum password length to 8, set this value with 8 or more characters."
                     },
                     "email": {
                        "type": "string",
                        "description": "The email that belongs to the user."
                     },
                     "sshkey_name": {
                        "type": "string",
                        "description": "The name of the sshkey"
                     },
                     "sshkey_file": {
                        "type": "string",
                        "description": "The ssh key itself."
                     },
                     "group": {
                        "type": "string",
                        "description": "Id or Full path of parent group in the form of group/name\nAdd user as an member to this group."
                     },
                     "access_level": {
                        "type": "string",
                        "description": "Default: guest\n\nThe access level to the group. One of the following can be used.\nguest\nreporter\ndeveloper\nmaster (alias for maintainer)\nmaintainer\nowner",
                        "enum": [
                           "guest",
                           "reporter",
                           "developer",
                           "master",
                           "maintainer",
                           "owner"
                        ]
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\ncreate or delete group.\nPossible values are present and absent.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "confirm": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nRequire confirmation."
                     },
                     "isadmin": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Grant admin privileges to the user"
                     },
                     "external": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Define external parameter for this user"
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "api_token",
                                    "login_token"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "gitlab_runner": {
                  "type": "object",
                  "description": "Register, update and delete runners with the GitLab API.\nAll operations are performed using the GitLab API v4.\nFor details, consult the full API documentation at U(https://docs.gitlab.com/ee/api/runners.html).\nA valid private API token is required for all operations. You can create as many tokens as you like using the GitLab web interface at U(https://$GITLAB_URL/profile/personal_access_tokens).\nA valid registration token is required for registering a new runner. To create shared runners, you need to ask your administrator to give you this token. It can be found at U(https://$GITLAB_URL/admin/runners/).",
                  "properties": {
                     "url": {
                        "type": "string",
                        "description": "The URL of the GitLab server, with protocol (i.e. http or https)."
                     },
                     "api_token": {
                        "type": "string",
                        "description": "Your private token to interact with the GitLab API."
                     },
                     "private_token": {
                        "type": "string",
                        "description": "Your private token to interact with the GitLab API."
                     },
                     "description": {
                        "type": "string",
                        "description": "The unique name of the runner."
                     },
                     "name": {
                        "type": "string",
                        "description": "The unique name of the runner."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nMake sure that the runner with the same name exists with the same configuration or delete the runner with the same name.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "registration_token": {
                        "type": "string",
                        "description": "The registration token is used to register new runners."
                     },
                     "active": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nDefine if the runners is immediately active after creation."
                     },
                     "locked": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Determines if the runner is locked or not."
                     },
                     "access_level": {
                        "type": "string",
                        "description": "Default: ref_protected\n\nDetermines if a runner can pick up jobs from protected branches.",
                        "enum": [
                           "ref_protected",
                           "not_protected"
                        ]
                     },
                     "maximum_timeout": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 3600\n\nThe maximum timeout that a runner has to pick up a specific job."
                     },
                     "run_untagged": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nRun untagged jobs or not."
                     },
                     "tag_list": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "The tags that apply to the runner."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "api_token",
                                    "private_token"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "api_token"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "private_token"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "description",
                                    "name"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "description"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "gitlab_project_variable": {
                  "type": "object",
                  "description": "When a project variable does not exist, it will be created.\nWhen a project variable does exist, its value will be updated when the values are different.\nVariables which are untouched in the playbook, but are not untouched in the GitLab project, they stay untouched (I(purge) is C(false)) or will be deleted (I(purge) is C(true)).",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nCreate or delete project variable.\nPossible values are present and absent.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "api_token": {
                        "type": "string",
                        "description": "GitLab access token with API permissions."
                     },
                     "project": {
                        "type": "string",
                        "description": "The path and name of the project."
                     },
                     "purge": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "When set to true, all variables which are not untouched in the task will be deleted."
                     },
                     "vars": {
                        "type": "object",
                        "description": "A list of key value pairs."
                     }
                  },
                  "required": [
                     "api_token",
                     "project"
                  ]
               },
               "gitlab_project": {
                  "type": "object",
                  "description": "When the project does not exist in GitLab, it will be created.\nWhen the project does exists and state=absent, the project will be deleted.\nWhen changes are made to the project, the project will be updated.",
                  "properties": {
                     "server_url": {
                        "type": "string",
                        "description": "The URL of the GitLab server, with protocol (i.e. http or https)."
                     },
                     "login_user": {
                        "type": "string",
                        "description": "GitLab user name."
                     },
                     "login_password": {
                        "type": "string",
                        "description": "GitLab password for login_user"
                     },
                     "api_token": {
                        "type": "string",
                        "description": "GitLab token for logging in."
                     },
                     "login_token": {
                        "type": "string",
                        "description": "GitLab token for logging in."
                     },
                     "group": {
                        "type": "string",
                        "description": "Id or The full path of the group of which this projects belongs to."
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the project"
                     },
                     "path": {
                        "type": "string",
                        "description": "The path of the project you want to create, this will be server_url/<group>/path\nIf not supplied, name will be used."
                     },
                     "description": {
                        "type": "string",
                        "description": "An description for the project."
                     },
                     "issues_enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nWhether you want to create issues or not.\nPossible values are true and false."
                     },
                     "merge_requests_enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nIf merge requests can be made or not.\nPossible values are true and false."
                     },
                     "wiki_enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nIf an wiki for this project should be available or not.\nPossible values are true and false."
                     },
                     "snippets_enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nIf creating snippets should be available or not.\nPossible values are true and false."
                     },
                     "visibility": {
                        "type": "string",
                        "description": "Default: private\n\nPrivate. Project access must be granted explicitly for each user.\nInternal. The project can be cloned by any logged in user.\nPublic. The project can be cloned without any authentication.",
                        "enum": [
                           "private",
                           "internal",
                           "public"
                        ]
                     },
                     "visibility_level": {
                        "type": "string",
                        "description": "Default: private\n\nPrivate. Project access must be granted explicitly for each user.\nInternal. The project can be cloned by any logged in user.\nPublic. The project can be cloned without any authentication.",
                        "enum": [
                           "private",
                           "internal",
                           "public"
                        ]
                     },
                     "import_url": {
                        "type": "string",
                        "description": "Git repository which will be imported into gitlab.\nGitLab server needs read access to this git repository."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\ncreate or delete project.\nPossible values are present and absent.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "api_token",
                                    "login_token"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "visibility",
                                    "visibility_level"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "gitlab_hook": {
                  "type": "object",
                  "description": "Adds, updates and removes project hook",
                  "properties": {
                     "api_token": {
                        "type": "string",
                        "description": "GitLab token for logging in."
                     },
                     "private_token": {
                        "type": "string",
                        "description": "GitLab token for logging in."
                     },
                     "access_token": {
                        "type": "string",
                        "description": "GitLab token for logging in."
                     },
                     "project": {
                        "type": "string",
                        "description": "Id or Full path of the project in the form of group/name."
                     },
                     "hook_url": {
                        "type": "string",
                        "description": "The url that you want GitLab to post to, this is used as the primary key for updates and deletion."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhen C(present) the hook will be updated to match the input or created if it doesn't exist.\nWhen C(absent) hook will be deleted if it exists.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "push_events": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nTrigger hook on push events."
                     },
                     "issues_events": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Trigger hook on issues events."
                     },
                     "merge_requests_events": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Trigger hook on merge requests events."
                     },
                     "tag_push_events": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Trigger hook on tag push events."
                     },
                     "note_events": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Trigger hook on note events or when someone adds a comment."
                     },
                     "job_events": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Trigger hook on job events."
                     },
                     "pipeline_events": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Trigger hook on pipeline events."
                     },
                     "wiki_page_events": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Trigger hook on wiki events."
                     },
                     "hook_validate_certs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether GitLab will do SSL verification when triggering the hook."
                     },
                     "enable_ssl_verification": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether GitLab will do SSL verification when triggering the hook."
                     },
                     "token": {
                        "type": "string",
                        "description": "Secret token to validate hook messages at the receiver.\nIf this is present it will always result in a change as it cannot be retrieved from GitLab.\nWill show up in the X-GitLab-Token HTTP request header."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "api_token",
                                    "private_token",
                                    "access_token"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "hook_validate_certs",
                                    "enable_ssl_verification"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "gitlab_group": {
                  "type": "object",
                  "description": "When the group does not exist in GitLab, it will be created.\nWhen the group does exist and state=absent, the group will be deleted.",
                  "properties": {
                     "server_url": {
                        "type": "string",
                        "description": "The URL of the GitLab server, with protocol (i.e. http or https)."
                     },
                     "login_user": {
                        "type": "string",
                        "description": "GitLab user name."
                     },
                     "login_password": {
                        "type": "string",
                        "description": "GitLab password for login_user"
                     },
                     "api_token": {
                        "type": "string",
                        "description": "GitLab token for logging in."
                     },
                     "login_token": {
                        "type": "string",
                        "description": "GitLab token for logging in."
                     },
                     "name": {
                        "type": "string",
                        "description": "Name of the group you want to create."
                     },
                     "path": {
                        "type": "string",
                        "description": "The path of the group you want to create, this will be server_url/group_path\nIf not supplied, the group_name will be used."
                     },
                     "description": {
                        "type": "string",
                        "description": "A description for the group."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\ncreate or delete group.\nPossible values are present and absent.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "parent": {
                        "type": "string",
                        "description": "Allow to create subgroups\nId or Full path of parent group in the form of group/name"
                     },
                     "visibility": {
                        "type": "string",
                        "description": "Default: private\n\nDefault visibility of the group",
                        "enum": [
                           "private",
                           "internal",
                           "public"
                        ]
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "api_token",
                                    "login_token"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "gitlab_deploy_key": {
                  "type": "object",
                  "description": "Adds, updates and removes project deploy keys",
                  "properties": {
                     "api_token": {
                        "type": "string",
                        "description": "GitLab token for logging in."
                     },
                     "private_token": {
                        "type": "string",
                        "description": "GitLab token for logging in."
                     },
                     "access_token": {
                        "type": "string",
                        "description": "GitLab token for logging in."
                     },
                     "project": {
                        "type": "string",
                        "description": "Id or Full path of project in the form of group/name"
                     },
                     "title": {
                        "type": "string",
                        "description": "Deploy key's title"
                     },
                     "key": {
                        "type": "string",
                        "description": "Deploy key"
                     },
                     "can_push": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether this key can push to the project"
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhen C(present) the deploy key added to the project if it doesn't exist.\nWhen C(absent) it will be removed from the project if it exists",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "api_token",
                                    "private_token",
                                    "access_token"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "github_webhook_info": {
                  "type": "object",
                  "description": "Query information about GitHub webhooks\nThis module was called C(github_webhook_facts) before Ansible 2.9. The usage did not change.",
                  "properties": {
                     "repository": {
                        "type": "string",
                        "description": "Full name of the repository to configure a hook for"
                     },
                     "repo": {
                        "type": "string",
                        "description": "Full name of the repository to configure a hook for"
                     },
                     "user": {
                        "type": "string",
                        "description": "User to authenticate to GitHub as"
                     },
                     "password": {
                        "type": "string",
                        "description": "Password to authenticate to GitHub with"
                     },
                     "token": {
                        "type": "string",
                        "description": "Token to authenticate to GitHub with"
                     },
                     "github_url": {
                        "type": "string",
                        "description": "Default: https://api.github.com\n\nBase URL of the github api"
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "repository",
                                    "repo"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "repository"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "repo"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "github_webhook": {
                  "type": "object",
                  "description": "Create and delete GitHub webhooks",
                  "properties": {
                     "repository": {
                        "type": "string",
                        "description": "Full name of the repository to configure a hook for"
                     },
                     "repo": {
                        "type": "string",
                        "description": "Full name of the repository to configure a hook for"
                     },
                     "url": {
                        "type": "string",
                        "description": "URL to which payloads will be delivered"
                     },
                     "content_type": {
                        "type": "string",
                        "description": "Default: form\n\nThe media type used to serialize the payloads",
                        "enum": [
                           "form",
                           "json"
                        ]
                     },
                     "secret": {
                        "type": "string",
                        "description": "The shared secret between GitHub and the payload URL."
                     },
                     "insecure_ssl": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Flag to indicate that GitHub should skip SSL verification when calling the hook.\n"
                     },
                     "events": {
                        "type": "string",
                        "description": "A list of GitHub events the hook is triggered for. Events are listed at U(https://developer.github.com/v3/activity/events/types/). Required unless C(state) is C(absent)\n"
                     },
                     "active": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nWhether or not the hook is active"
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the hook should be present or absent",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "user": {
                        "type": "string",
                        "description": "User to authenticate to GitHub as"
                     },
                     "password": {
                        "type": "string",
                        "description": "Password to authenticate to GitHub with"
                     },
                     "token": {
                        "type": "string",
                        "description": "Token to authenticate to GitHub with"
                     },
                     "github_url": {
                        "type": "string",
                        "description": "Default: https://api.github.com\n\nBase URL of the GitHub API"
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "repository",
                                    "repo"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "repository"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "repo"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "github_release": {
                  "type": "object",
                  "description": "Fetch metadata about GitHub Releases",
                  "properties": {
                     "token": {
                        "type": "string",
                        "description": "GitHub Personal Access Token for authenticating. Mutually exclusive with C(password)."
                     },
                     "user": {
                        "type": "string",
                        "description": "The GitHub account that owns the repository"
                     },
                     "password": {
                        "type": "string",
                        "description": "The GitHub account password for the user. Mutually exclusive with C(token)."
                     },
                     "repo": {
                        "type": "string",
                        "description": "Repository name"
                     },
                     "action": {
                        "type": "string",
                        "description": "Action to perform",
                        "enum": [
                           "latest_release",
                           "create_release"
                        ]
                     },
                     "tag": {
                        "type": "string",
                        "description": "Tag name when creating a release. Required when using action is set to C(create_release)."
                     },
                     "target": {
                        "type": "string",
                        "description": "Target of release when creating a release"
                     },
                     "name": {
                        "type": "string",
                        "description": "Name of release when creating a release"
                     },
                     "body": {
                        "type": "string",
                        "description": "Description of the release when creating a release"
                     },
                     "draft": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nSets if the release is a draft or not. (boolean)"
                     },
                     "prerelease": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nSets if the release is a prerelease or not. (boolean)"
                     }
                  },
                  "required": [
                     "user",
                     "repo",
                     "action"
                  ]
               },
               "github_key": {
                  "type": "object",
                  "description": "Creates, removes, or updates GitHub access keys.",
                  "properties": {
                     "token": {
                        "type": "string",
                        "description": "GitHub Access Token with permission to list and create public keys."
                     },
                     "name": {
                        "type": "string",
                        "description": "SSH key name"
                     },
                     "pubkey": {
                        "type": "string",
                        "description": "SSH public key value. Required when C(state=present)."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether to remove a key, ensure that it exists, or update its value.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "force": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nThe default is C(yes), which will replace the existing remote key if it's different than C(pubkey). If C(no), the key will only be set if no key with the given C(name) exists."
                     }
                  },
                  "required": [
                     "token",
                     "name"
                  ]
               },
               "github_issue": {
                  "type": "object",
                  "description": "View GitHub issue for a given repository and organization.",
                  "properties": {
                     "repo": {
                        "type": "string",
                        "description": "Name of repository from which issue needs to be retrieved."
                     },
                     "organization": {
                        "type": "string",
                        "description": "Name of the GitHub organization in which the repository is hosted."
                     },
                     "issue": {
                        "type": "string",
                        "description": "Issue number for which information is required."
                     },
                     "action": {
                        "type": "string",
                        "description": "Default: get_status\n\nGet various details about issue depending upon action specified.",
                        "enum": [
                           "get_status"
                        ]
                     }
                  },
                  "required": [
                     "repo",
                     "organization",
                     "issue"
                  ]
               },
               "github_deploy_key": {
                  "type": "object",
                  "description": "Adds or removes deploy keys for GitHub repositories. Supports authentication using username and password, username and password and 2-factor authentication code (OTP), OAuth2 token, or personal access token.",
                  "properties": {
                     "owner": {
                        "type": "string",
                        "description": "The name of the individual account or organization that owns the GitHub repository."
                     },
                     "account": {
                        "type": "string",
                        "description": "The name of the individual account or organization that owns the GitHub repository."
                     },
                     "organization": {
                        "type": "string",
                        "description": "The name of the individual account or organization that owns the GitHub repository."
                     },
                     "repo": {
                        "type": "string",
                        "description": "The name of the GitHub repository."
                     },
                     "repository": {
                        "type": "string",
                        "description": "The name of the GitHub repository."
                     },
                     "name": {
                        "type": "string",
                        "description": "The name for the deploy key."
                     },
                     "title": {
                        "type": "string",
                        "description": "The name for the deploy key."
                     },
                     "label": {
                        "type": "string",
                        "description": "The name for the deploy key."
                     },
                     "key": {
                        "type": "string",
                        "description": "The SSH public key to add to the repository as a deploy key."
                     },
                     "read_only": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nIf C(true), the deploy key will only be able to read repository contents. Otherwise, the deploy key will be able to read and write."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nThe state of the deploy key.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "force": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nIf C(true), forcefully adds the deploy key by deleting any existing deploy key with the same public key or title."
                     },
                     "username": {
                        "type": "string",
                        "description": "The username to authenticate with. Should not be set when using personal access token"
                     },
                     "password": {
                        "type": "string",
                        "description": "The password to authenticate with. Alternatively, a personal access token can be used instead of I(username) and I(password) combination."
                     },
                     "token": {
                        "type": "string",
                        "description": "The OAuth2 token or personal access token to authenticate with. Mutually exclusive with I(password)."
                     },
                     "otp": {
                        "type": "string",
                        "description": "The 6 digit One Time Password for 2-Factor Authentication. Required together with I(username) and I(password)."
                     },
                     "2fa_token": {
                        "type": "string",
                        "description": "The 6 digit One Time Password for 2-Factor Authentication. Required together with I(username) and I(password)."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "owner",
                                    "account",
                                    "organization"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "owner"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "account"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "organization"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "repo",
                                    "repository"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "repo"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "repository"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "title",
                                    "label"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "title"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "label"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "otp",
                                    "2fa_token"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "git_config": {
                  "type": "object",
                  "description": "The C(git_config) module changes git configuration by invoking 'git config'. This is needed if you don't want to use M(template) for the entire git config file (e.g. because you need to change just C(user.email) in /etc/.git/config).  Solutions involving M(command) are cumbersome or don't work correctly in check mode.",
                  "properties": {
                     "list_all": {
                        "type": "array",
                        "description": "Default: no\n\nList all settings (optionally limited to a given I(scope))"
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the setting. If no value is supplied, the value will be read from the config if it has been set."
                     },
                     "repo": {
                        "type": "string",
                        "description": "Path to a git repository for reading and writing values from a specific repo."
                     },
                     "scope": {
                        "type": "string",
                        "description": "Specify which scope to read/set values from. This is required when setting config values. If this is set to local, you must also specify the repo parameter. It defaults to system only when not using I(list_all)=yes.",
                        "enum": [
                           "local",
                           "global",
                           "system"
                        ]
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIndicates the setting should be set/unset. This parameter has higher precedence than I(value) parameter: when I(state)=absent and I(value) is defined, I(value) is discarded.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "value": {
                        "type": "string",
                        "description": "When specifying the name of a single setting, supply a value to set that setting to the given value."
                     }
                  }
               },
               "git": {
                  "type": "object",
                  "description": "Manage I(git) checkouts of repositories to deploy files or software.",
                  "properties": {
                     "repo": {
                        "type": "string",
                        "description": "git, SSH, or HTTP(S) protocol address of the git repository."
                     },
                     "name": {
                        "type": "string",
                        "description": "git, SSH, or HTTP(S) protocol address of the git repository."
                     },
                     "dest": {
                        "type": "string",
                        "description": "The path of where the repository should be checked out. This parameter is required, unless C(clone) is set to C(no)."
                     },
                     "version": {
                        "type": "string",
                        "description": "Default: HEAD\n\nWhat version of the repository to check out.  This can be the literal string C(HEAD), a branch name, a tag name. It can also be a I(SHA-1) hash, in which case C(refspec) needs to be specified if the given revision is not already available."
                     },
                     "accept_hostkey": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nif C(yes), ensure that \"-o StrictHostKeyChecking=no\" is present as an ssh option."
                     },
                     "ssh_opts": {
                        "type": "string",
                        "description": "Creates a wrapper script and exports the path as GIT_SSH which git then automatically uses to override ssh arguments. An example value could be \"-o StrictHostKeyChecking=no\" (although this particular option is better set via C(accept_hostkey))."
                     },
                     "key_file": {
                        "type": "string",
                        "description": "Specify an optional private key file path, on the target host, to use for the checkout."
                     },
                     "reference": {
                        "type": "string",
                        "description": "Reference repository (see \"git clone --reference ...\")"
                     },
                     "remote": {
                        "type": "string",
                        "description": "Default: origin\n\nName of the remote."
                     },
                     "refspec": {
                        "type": "string",
                        "description": "Add an additional refspec to be fetched. If version is set to a I(SHA-1) not reachable from any branch or tag, this option may be necessary to specify the ref containing the I(SHA-1). Uses the same syntax as the 'git fetch' command. An example value could be \"refs/meta/config\"."
                     },
                     "force": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nIf C(yes), any modified files in the working repository will be discarded.  Prior to 0.7, this was always 'yes' and could not be disabled.  Prior to 1.9, the default was `yes`"
                     },
                     "depth": {
                        "type": "string",
                        "description": "Create a shallow clone with a history truncated to the specified number or revisions. The minimum possible value is C(1), otherwise ignored. Needs I(git>=1.9.1) to work correctly."
                     },
                     "clone": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nIf C(no), do not clone the repository even if it does not exist locally"
                     },
                     "update": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nIf C(no), do not retrieve new revisions from the origin repository\nOperations like archive will work on the existing (old) repository and might not respond to changes to the options version or remote."
                     },
                     "executable": {
                        "type": "string",
                        "description": "Path to git executable to use. If not supplied, the normal mechanism for resolving binary paths will be used."
                     },
                     "bare": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nif C(yes), repository will be created as a bare repo, otherwise it will be a standard repo with a workspace."
                     },
                     "umask": {
                        "type": "string",
                        "description": "The umask to set before doing any checkouts, or any other repository maintenance."
                     },
                     "recursive": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nif C(no), repository will be cloned without the --recursive option, skipping sub-modules."
                     },
                     "track_submodules": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nif C(yes), submodules will track the latest commit on their master branch (or other branch specified in .gitmodules).  If C(no), submodules will be kept at the revision specified by the main project. This is equivalent to specifying the --remote flag to git submodule update."
                     },
                     "verify_commit": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nif C(yes), when cloning or checking out a C(version) verify the signature of a GPG signed commit. This requires C(git) version>=2.1.0 to be installed. The commit MUST be signed and the public key MUST be present in the GPG keyring."
                     },
                     "archive": {
                        "type": "string",
                        "description": "Specify archive file path with extension. If specified, creates an archive file of the specified format containing the tree structure for the source tree. Allowed archive formats [\"zip\", \"tar.gz\", \"tar\", \"tgz\"]\nThis will clone and perform git archive from local directory as not all git servers support git archive."
                     },
                     "separate_git_dir": {
                        "type": "string",
                        "description": "The path to place the cloned repository. If specified, Git repository can be separated from working tree."
                     },
                     "gpg_whitelist": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "A list of trusted GPG fingerprints to compare to the fingerprint of the GPG-signed commit.\nOnly used when I(verify_commit=yes)."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "repo",
                                    "name"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "repo"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "bzr": {
                  "type": "object",
                  "description": "Manage I(bzr) branches to deploy files or software.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "SSH or HTTP protocol address of the parent branch."
                     },
                     "parent": {
                        "type": "string",
                        "description": "SSH or HTTP protocol address of the parent branch."
                     },
                     "dest": {
                        "type": "string",
                        "description": "Absolute path of where the branch should be cloned to."
                     },
                     "version": {
                        "type": "string",
                        "description": "Default: head\n\nWhat version of the branch to clone.  This can be the bzr revno or revid."
                     },
                     "force": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nIf C(yes), any modified files in the working tree will be discarded.  Before 1.9 the default value was C(yes)."
                     },
                     "executable": {
                        "type": "string",
                        "description": "Path to bzr executable to use. If not supplied, the normal mechanism for resolving binary paths will be used."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "parent"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "parent"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "github_hooks": {
                  "type": "object",
                  "description": "Adds service hooks and removes service hooks that have an error status.",
                  "properties": {
                     "user": {
                        "type": "string",
                        "description": "GitHub username."
                     },
                     "oauthkey": {
                        "type": "string",
                        "description": "The oauth key provided by GitHub. It can be found/generated on GitHub under \"Edit Your Profile\" >> \"Developer settings\" >> \"Personal Access Tokens\""
                     },
                     "repo": {
                        "type": "string",
                        "description": "This is the API url for the repository you want to manage hooks for. It should be in the form of: https://api.github.com/repos/user:/repo:. Note this is different than the normal repo url.\n"
                     },
                     "hookurl": {
                        "type": "string",
                        "description": "When creating a new hook, this is the url that you want GitHub to post to. It is only required when creating a new hook."
                     },
                     "action": {
                        "type": "string",
                        "description": "This tells the githooks module what you want it to do.",
                        "enum": [
                           "create",
                           "cleanall",
                           "list",
                           "clean504"
                        ]
                     },
                     "validate_certs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nIf C(no), SSL certificates for the target repo will not be validated. This should only be used on personally controlled sites using self-signed certificates."
                     },
                     "content_type": {
                        "type": "string",
                        "description": "Default: json\n\nContent type to use for requests made to the webhook",
                        "enum": [
                           "json",
                           "form"
                        ]
                     }
                  },
                  "required": [
                     "user",
                     "oauthkey",
                     "repo",
                     "action"
                  ]
               },
               "bitbucket_pipeline_variable": {
                  "type": "object",
                  "description": "Manages Bitbucket pipeline variables.",
                  "properties": {
                     "client_id": {
                        "type": "string",
                        "description": "The OAuth consumer key.\nIf not set the environment variable C(BITBUCKET_CLIENT_ID) will be used."
                     },
                     "client_secret": {
                        "type": "string",
                        "description": "The OAuth consumer secret.\nIf not set the environment variable C(BITBUCKET_CLIENT_SECRET) will be used."
                     },
                     "repository": {
                        "type": "string",
                        "description": "The repository name."
                     },
                     "username": {
                        "type": "string",
                        "description": "The repository owner."
                     },
                     "name": {
                        "type": "string",
                        "description": "The pipeline variable name."
                     },
                     "value": {
                        "type": "string",
                        "description": "The pipeline variable value."
                     },
                     "secured": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether to encrypt the variable value."
                     },
                     "state": {
                        "type": "string",
                        "description": "Indicates desired state of the variable.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     }
                  },
                  "required": [
                     "repository",
                     "username",
                     "name",
                     "state"
                  ]
               },
               "bitbucket_pipeline_known_host": {
                  "type": "object",
                  "description": "Manages Bitbucket pipeline known hosts under the \"SSH Keys\" menu.\nThe host fingerprint will be retrieved automatically, but in case of an error, one can use I(key) field to specify it manually.",
                  "properties": {
                     "client_id": {
                        "type": "string",
                        "description": "The OAuth consumer key.\nIf not set the environment variable C(BITBUCKET_CLIENT_ID) will be used."
                     },
                     "client_secret": {
                        "type": "string",
                        "description": "The OAuth consumer secret.\nIf not set the environment variable C(BITBUCKET_CLIENT_SECRET) will be used."
                     },
                     "repository": {
                        "type": "string",
                        "description": "The repository name."
                     },
                     "username": {
                        "type": "string",
                        "description": "The repository owner."
                     },
                     "name": {
                        "type": "string",
                        "description": "The FQDN of the known host."
                     },
                     "key": {
                        "type": "string",
                        "description": "The public key."
                     },
                     "state": {
                        "type": "string",
                        "description": "Indicates desired state of the record.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     }
                  },
                  "required": [
                     "repository",
                     "username",
                     "name",
                     "state"
                  ]
               },
               "bitbucket_pipeline_key_pair": {
                  "type": "object",
                  "description": "Manages Bitbucket pipeline SSH key pair.",
                  "properties": {
                     "client_id": {
                        "type": "string",
                        "description": "OAuth consumer key.\nIf not set the environment variable C(BITBUCKET_CLIENT_ID) will be used."
                     },
                     "client_secret": {
                        "type": "string",
                        "description": "OAuth consumer secret.\nIf not set the environment variable C(BITBUCKET_CLIENT_SECRET) will be used."
                     },
                     "repository": {
                        "type": "string",
                        "description": "The repository name."
                     },
                     "username": {
                        "type": "string",
                        "description": "The repository owner."
                     },
                     "public_key": {
                        "type": "string",
                        "description": "The public key."
                     },
                     "private_key": {
                        "type": "string",
                        "description": "The private key."
                     },
                     "state": {
                        "type": "string",
                        "description": "Indicates desired state of the key pair.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     }
                  },
                  "required": [
                     "repository",
                     "username",
                     "state"
                  ]
               },
               "bitbucket_access_key": {
                  "type": "object",
                  "description": "Manages Bitbucket repository access keys (also called deploy keys).",
                  "properties": {
                     "client_id": {
                        "type": "string",
                        "description": "The OAuth consumer key.\nIf not set the environment variable C(BITBUCKET_CLIENT_ID) will be used."
                     },
                     "client_secret": {
                        "type": "string",
                        "description": "The OAuth consumer secret.\nIf not set the environment variable C(BITBUCKET_CLIENT_SECRET) will be used."
                     },
                     "repository": {
                        "type": "string",
                        "description": "The repository name."
                     },
                     "username": {
                        "type": "string",
                        "description": "The repository owner."
                     },
                     "key": {
                        "type": "string",
                        "description": "The SSH public key."
                     },
                     "label": {
                        "type": "string",
                        "description": "The key label."
                     },
                     "state": {
                        "type": "string",
                        "description": "Indicates desired state of the access key.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     }
                  },
                  "required": [
                     "repository",
                     "username",
                     "label",
                     "state"
                  ]
               },
               "wakeonlan": {
                  "type": "object",
                  "description": "The C(wakeonlan) module sends magic Wake-on-LAN (WoL) broadcast packets.",
                  "properties": {
                     "mac": {
                        "type": "string",
                        "description": "MAC address to send Wake-on-LAN broadcast packet for."
                     },
                     "broadcast": {
                        "type": "string",
                        "description": "Default: 255.255.255.255\n\nNetwork broadcast address to use for broadcasting magic Wake-on-LAN packet."
                     },
                     "port": {
                        "type": "string",
                        "description": "Default: 7\n\nUDP port to use for magic Wake-on-LAN packet."
                     }
                  },
                  "required": [
                     "mac"
                  ]
               },
               "ucs_wwn_pool": {
                  "type": "object",
                  "description": "Configures WWNNs or WWPN pools on Cisco UCS Manager.\nExamples can be used with the UCS Platform Emulator U(https://communities.cisco.com/ucspe).",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIf C(present), will verify WWNNs/WWPNs are present and will create if needed.\nIf C(absent), will verify WWNNs/WWPNs are absent and will delete if needed.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the World Wide Node Name (WWNN) or World Wide Port Name (WWPN) pool.\nThis name can be between 1 and 32 alphanumeric characters.\nYou cannot use spaces or any special characters other than - (hyphen), \"_\" (underscore), : (colon), and . (period).\nYou cannot change this name after the WWNN or WWPN pool is created."
                     },
                     "purpose": {
                        "type": "string",
                        "description": "Specify whether this is a node (WWNN) or port (WWPN) pool.\nOptional if state is absent.",
                        "enum": [
                           "node",
                           "port"
                        ]
                     },
                     "description": {
                        "type": "string",
                        "description": "A description of the WWNN or WWPN pool.\nEnter up to 256 characters.\nYou can use any characters or spaces except the following:\n` (accent mark),  (backslash), ^ (carat), \" (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote)."
                     },
                     "descr": {
                        "type": "string",
                        "description": "A description of the WWNN or WWPN pool.\nEnter up to 256 characters.\nYou can use any characters or spaces except the following:\n` (accent mark),  (backslash), ^ (carat), \" (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote)."
                     },
                     "order": {
                        "type": "string",
                        "description": "Default: default\n\nThe Assignment Order field.\nThis can be one of the following:\ndefault - Cisco UCS Manager selects a random identity from the pool.\nsequential - Cisco UCS Manager selects the lowest available identity from the pool.",
                        "enum": [
                           "default",
                           "sequential"
                        ]
                     },
                     "first_addr": {
                        "type": "string",
                        "description": "The first initiator in the World Wide Name (WWN) block.\nThis is the From field in the UCS Manager Add WWN Blocks menu."
                     },
                     "last_addr": {
                        "type": "string",
                        "description": "The last initiator in the World Wide Name (WWN) block.\nThis is the To field in the UCS Manager Add WWN Blocks menu.\nFor WWxN pools, the pool size must be a multiple of ports-per-node + 1.\nFor example, if there are 7 ports per node, the pool size must be a multiple of 8.\nIf there are 63 ports per node, the pool size must be a multiple of 64."
                     },
                     "org_dn": {
                        "type": "string",
                        "description": "Default: org-root\n\nOrg dn (distinguished name)"
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "description",
                                    "descr"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "ucs_vsans": {
                  "type": "object",
                  "description": "Configures VSANs on Cisco UCS Manager.\nExamples can be used with the UCS Platform Emulator U(https://communities.cisco.com/ucspe).",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIf C(present), will verify VSANs are present and will create if needed.\nIf C(absent), will verify VSANs are absent and will delete if needed.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name assigned to the VSAN.\nThis name can be between 1 and 32 alphanumeric characters.\nYou cannot use spaces or any special characters other than - (hyphen), \"_\" (underscore), : (colon), and . (period).\nYou cannot change this name after the VSAN is created."
                     },
                     "vsan_id": {
                        "type": "string",
                        "description": "The unique identifier assigned to the VSAN.\nThe ID can be a string between '1' and '4078', or between '4080' and '4093'. '4079' is a reserved VSAN ID.\nIn addition, if you plan to use FC end-host mode, the range between '3840' to '4079' is also a reserved VSAN ID range.\nOptional if state is absent."
                     },
                     "vlan_id": {
                        "type": "string",
                        "description": "The unique string identifier assigned to the VLAN used for Fibre Channel connections.\nNote that Cisco UCS Manager uses VLAN '4048'.  See the UCS Manager configuration guide if you want to assign '4048' to a VLAN.\nOptional if state is absent."
                     },
                     "fc_zoning": {
                        "type": "string",
                        "description": "Default: disabled\n\nFibre Channel zoning configuration for the Cisco UCS domain.\nFibre Channel zoning can be set to one of the following values:\ndisabled \u2014 The upstream switch handles Fibre Channel zoning, or Fibre Channel zoning is not implemented for the Cisco UCS domain.\nenabled \u2014 Cisco UCS Manager configures and controls Fibre Channel zoning for the Cisco UCS domain.\nIf you enable Fibre Channel zoning, do not configure the upstream switch with any VSANs that are being used for Fibre Channel zoning.",
                        "enum": [
                           "disabled",
                           "enabled"
                        ]
                     },
                     "fabric": {
                        "type": "string",
                        "description": "Default: common\n\nThe fabric configuration of the VSAN.  This can be one of the following:\ncommon - The VSAN maps to the same VSAN ID in all available fabrics.\nA - The VSAN maps to the a VSAN ID that exists only in fabric A.\nB - The VSAN maps to the a VSAN ID that exists only in fabric B.",
                        "enum": [
                           "common",
                           "A",
                           "B"
                        ]
                     }
                  },
                  "required": [
                     "name",
                     "vsan_id",
                     "vlan_id"
                  ]
               },
               "ucs_vnic_template": {
                  "type": "object",
                  "description": "Configures vNIC templates on Cisco UCS Manager.\nExamples can be used with the UCS Platform Emulator U(https://communities.cisco.com/ucspe).",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIf C(present), will verify vNIC templates are present and will create if needed.\nIf C(absent), will verify vNIC templates are absent and will delete if needed.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the vNIC template.\nThis name can be between 1 and 16 alphanumeric characters.\nYou cannot use spaces or any special characters other than - (hyphen), \"_\" (underscore), : (colon), and . (period).\nYou cannot change this name after the template is created."
                     },
                     "description": {
                        "type": "string",
                        "description": "A user-defined description of the vNIC template.\nEnter up to 256 characters.\nYou can use any characters or spaces except the following:\n` (accent mark),  (backslash), ^ (carat), \" (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote)."
                     },
                     "descr": {
                        "type": "string",
                        "description": "A user-defined description of the vNIC template.\nEnter up to 256 characters.\nYou can use any characters or spaces except the following:\n` (accent mark),  (backslash), ^ (carat), \" (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote)."
                     },
                     "fabric": {
                        "type": "string",
                        "description": "Default: A\n\nThe Fabric ID field specifying the fabric interconnect associated with vNICs created from this template.\nIf you want fabric failover enabled on vNICs created from this template, use of of the following:\"\nA-B to use Fabric A by default with failover enabled.\nB-A to use Fabric B by default with failover enabled.\nDo not enable vNIC fabric failover under the following circumstances:\n- If the Cisco UCS domain is running in Ethernet switch mode. vNIC fabric failover is not supported in that mode.\n- If you plan to associate one or more vNICs created from this template to a server with an adapter that does not support fabric failover.",
                        "enum": [
                           "A",
                           "B",
                           "A-B",
                           "B-A"
                        ]
                     },
                     "redundancy_type": {
                        "type": "string",
                        "description": "Default: none\n\nThe Redundancy Type used for vNIC redundancy pairs during fabric failover.\nThis can be one of the following:\nprimary \u2014 Creates configurations that can be shared with the Secondary template.\nsecondary \u2014 All shared configurations are inherited from the Primary template.\nnone - Legacy vNIC template behavior. Select this option if you do not want to use redundancy.",
                        "enum": [
                           "none",
                           "primary",
                           "secondary"
                        ]
                     },
                     "peer_redundancy_template": {
                        "type": "string",
                        "description": "The Peer Redundancy Template.\nThe name of the vNIC template sharing a configuration with this template.\nIf the redundancy_type is primary, the name of the secondary template should be provided.\nIf the redundancy_type is secondary, the name of the primary template should be provided.\nSecondary templates can only configure non-shared properties (name, description, and mac_pool)."
                     },
                     "peer_redundancy_templ": {
                        "type": "string",
                        "description": "The Peer Redundancy Template.\nThe name of the vNIC template sharing a configuration with this template.\nIf the redundancy_type is primary, the name of the secondary template should be provided.\nIf the redundancy_type is secondary, the name of the primary template should be provided.\nSecondary templates can only configure non-shared properties (name, description, and mac_pool)."
                     },
                     "target": {
                        "type": "string",
                        "description": "Default: adapter\n\nThe possible target for vNICs created from this template.\nThe target determines whether or not Cisco UCS Manager automatically creates a VM-FEX port profile with the appropriate settings for the vNIC template.\nThis can be one of the following:\nadapter \u2014 The vNICs apply to all adapters. No VM-FEX port profile is created if you choose this option.\nvm - The vNICs apply to all virtual machines. A VM-FEX port profile is created if you choose this option."
                     },
                     "template_type": {
                        "type": "string",
                        "description": "Default: initial-template\n\nThe Template Type field.\nThis can be one of the following:\ninitial-template \u2014 vNICs created from this template are not updated if the template changes.\nupdating-template - vNICs created from this template are updated if the template changes.",
                        "enum": [
                           "initial-template",
                           "updating-template"
                        ]
                     },
                     "vlans_list": {
                        "type": "array",
                        "description": "List of VLANs used by the vNIC template.\nEach list element has the following suboptions:\n= name\n  The name of the VLAN (required).\n- native\n  Designates the VLAN as a native VLAN.  Only one VLAN in the list can be a native VLAN.\n  [choices: 'no', 'yes']\n  [Default: 'no']\n- state\n  If present, will verify VLAN is present on template.\n  If absent, will verify VLAN is absent on template.\n  choices: [present, absent]\n  default: present"
                     },
                     "cdn_source": {
                        "type": "string",
                        "description": "Default: vnic-name\n\nCDN Source field.\nThis can be one of the following options:\nvnic-name - Uses the vNIC template name of the vNIC instance as the CDN name. This is the default option.\nuser-defined - Uses a user-defined CDN name for the vNIC template. If this option is chosen, cdn_name must also be provided.",
                        "enum": [
                           "vnic-name",
                           "user-defined"
                        ]
                     },
                     "cdn_name": {
                        "type": "string",
                        "description": "CDN Name used when cdn_source is set to user-defined."
                     },
                     "mtu": {
                        "type": "string",
                        "description": "Default: 1500\n\nThe MTU field.\nThe maximum transmission unit, or packet size, that vNICs created from this vNIC template should use.\nEnter a string between '1500' and '9000'.\nIf the vNIC template has an associated QoS policy, the MTU specified here must be equal to or less than the MTU specified in the QoS system class."
                     },
                     "mac_pool": {
                        "type": "string",
                        "description": "The MAC address pool that vNICs created from this vNIC template should use."
                     },
                     "qos_policy": {
                        "type": "string",
                        "description": "The quality of service (QoS) policy that vNICs created from this vNIC template should use."
                     },
                     "network_control_policy": {
                        "type": "string",
                        "description": "The network control policy that vNICs created from this vNIC template should use."
                     },
                     "pin_group": {
                        "type": "string",
                        "description": "The LAN pin group that vNICs created from this vNIC template should use."
                     },
                     "stats_policy": {
                        "type": "string",
                        "description": "Default: default\n\nThe statistics collection policy that vNICs created from this vNIC template should use."
                     },
                     "org_dn": {
                        "type": "string",
                        "description": "Default: org-root\n\nOrg dn (distinguished name)"
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "description",
                                    "descr"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "peer_redundancy_template",
                                    "peer_redundancy_templ"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "ucs_vlans": {
                  "type": "object",
                  "description": "Configures VLANs on Cisco UCS Manager.\nExamples can be used with the UCS Platform Emulator U(https://communities.cisco.com/ucspe).",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIf C(present), will verify VLANs are present and will create if needed.\nIf C(absent), will verify VLANs are absent and will delete if needed.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name assigned to the VLAN.\nThe VLAN name is case sensitive.\nThis name can be between 1 and 32 alphanumeric characters.\nYou cannot use spaces or any special characters other than - (hyphen), \"_\" (underscore), : (colon), and . (period).\nYou cannot change this name after the VLAN is created."
                     },
                     "multicast_policy": {
                        "type": "string",
                        "description": "The multicast policy associated with this VLAN.\nThis option is only valid if the Sharing Type field is set to None or Primary."
                     },
                     "fabric": {
                        "type": "string",
                        "description": "Default: common\n\nThe fabric configuration of the VLAN.  This can be one of the following:\ncommon - The VLAN applies to both fabrics and uses the same configuration parameters in both cases.\nA \u2014 The VLAN only applies to fabric A.\nB \u2014 The VLAN only applies to fabric B.\nFor upstream disjoint L2 networks, Cisco recommends that you choose common to create VLANs that apply to both fabrics.",
                        "enum": [
                           "common",
                           "A",
                           "B"
                        ]
                     },
                     "id": {
                        "type": "string",
                        "description": "The unique string identifier assigned to the VLAN.\nA VLAN ID can be between '1' and '3967', or between '4048' and '4093'.\nYou cannot create VLANs with IDs from 4030 to 4047. This range of VLAN IDs is reserved.\nThe VLAN IDs you specify must also be supported on the switch that you are using.\nVLANs in the LAN cloud and FCoE VLANs in the SAN cloud must have different IDs.\nOptional if state is absent."
                     },
                     "sharing": {
                        "type": "string",
                        "description": "Default: none\n\nThe Sharing Type field.\nWhether this VLAN is subdivided into private or secondary VLANs. This can be one of the following:\nnone - This VLAN does not have any secondary or private VLANs. This is a regular VLAN.\nprimary - This VLAN can have one or more secondary VLANs, as shown in the Secondary VLANs area. This VLAN is a primary VLAN in the private VLAN domain.\nisolated - This is a private VLAN associated with a primary VLAN. This VLAN is an Isolated VLAN.\ncommunity - This VLAN can communicate with other ports on the same community VLAN as well as the promiscuous port. This VLAN is a Community VLAN.",
                        "enum": [
                           "none",
                           "primary",
                           "isolated",
                           "community"
                        ]
                     },
                     "native": {
                        "type": "string",
                        "description": "Default: no\n\nDesignates the VLAN as a native VLAN.",
                        "enum": [
                           "yes",
                           "no"
                        ]
                     }
                  },
                  "required": [
                     "name",
                     "id"
                  ]
               },
               "ucs_vlan_find": {
                  "type": "object",
                  "description": "Find VLANs on Cisco UCS Manager based on different criteria.",
                  "properties": {
                     "pattern": {
                        "type": "string",
                        "description": "Regex pattern to find within the name property of the fabricVlan class.\nThis is required if C(vlanid) parameter is not supplied."
                     },
                     "fabric": {
                        "type": "string",
                        "description": "Default: common\n\nThe fabric configuration of the VLAN.  This can be one of the following:\ncommon - The VLAN applies to both fabrics and uses the same configuration parameters in both cases.\nA \u2014 The VLAN only applies to fabric A.\nB \u2014 The VLAN only applies to fabric B.",
                        "enum": [
                           "common",
                           "A",
                           "B"
                        ]
                     },
                     "vlanid": {
                        "type": "string",
                        "description": "The unique string identifier assigned to the VLAN.\nA VLAN ID can be between '1' and '3967', or between '4048' and '4093'.\nThis is required if C(pattern) parameter is not supplied."
                     }
                  }
               },
               "ucs_vhba_template": {
                  "type": "object",
                  "description": "Configures vHBA templates on Cisco UCS Manager.\nExamples can be used with the UCS Platform Emulator U(https://communities.cisco.com/ucspe).",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIf C(present), will verify vHBA templates are present and will create if needed.\nIf C(absent), will verify vHBA templates are absent and will delete if needed.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the virtual HBA template.\nThis name can be between 1 and 16 alphanumeric characters.\nYou cannot use spaces or any special characters other than - (hyphen), \"_\" (underscore), : (colon), and . (period).\nYou cannot change this name after the template is created."
                     },
                     "description": {
                        "type": "string",
                        "description": "A user-defined description of the template.\nEnter up to 256 characters.\nYou can use any characters or spaces except the following:\n` (accent mark),  (backslash), ^ (carat), \" (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote)."
                     },
                     "descr": {
                        "type": "string",
                        "description": "A user-defined description of the template.\nEnter up to 256 characters.\nYou can use any characters or spaces except the following:\n` (accent mark),  (backslash), ^ (carat), \" (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote)."
                     },
                     "fabric": {
                        "type": "string",
                        "description": "Default: A\n\nThe Fabric ID field.\nThe name of the fabric interconnect that vHBAs created with this template are associated with.",
                        "enum": [
                           "A",
                           "B"
                        ]
                     },
                     "redundancy_type": {
                        "type": "string",
                        "description": "Default: none\n\nThe Redundancy Type used for template pairing from the Primary or Secondary redundancy template.\nprimary \u2014 Creates configurations that can be shared with the Secondary template.\nAny other shared changes on the Primary template are automatically synchronized to the Secondary template.\nsecondary \u2014 All shared configurations are inherited from the Primary template.\nnone - Legacy vHBA template behavior. Select this option if you do not want to use redundancy.",
                        "enum": [
                           "none",
                           "primary",
                           "secondary"
                        ]
                     },
                     "vsan": {
                        "type": "string",
                        "description": "Default: default\n\nThe VSAN to associate with vHBAs created from this template."
                     },
                     "template_type": {
                        "type": "string",
                        "description": "Default: initial-template\n\nThe Template Type field.\nThis can be one of the following:\ninitial-template \u2014 vHBAs created from this template are not updated if the template changes.\nupdating-template - vHBAs created from this template are updated if the template changes.",
                        "enum": [
                           "initial-template",
                           "updating-template"
                        ]
                     },
                     "max_data": {
                        "type": "string",
                        "description": "Default: 2048\n\nThe Max Data Field Size field.\nThe maximum size of the Fibre Channel frame payload bytes that the vHBA supports.\nEnter an string between '256' and '2112'."
                     },
                     "wwpn_pool": {
                        "type": "string",
                        "description": "Default: default\n\nThe WWPN pool that a vHBA created from this template uses to derive its WWPN address."
                     },
                     "qos_policy": {
                        "type": "string",
                        "description": "The QoS policy that is associated with vHBAs created from this template."
                     },
                     "pin_group": {
                        "type": "string",
                        "description": "The SAN pin group that is associated with vHBAs created from this template."
                     },
                     "stats_policy": {
                        "type": "string",
                        "description": "Default: default\n\nThe statistics collection policy that is associated with vHBAs created from this template."
                     },
                     "org_dn": {
                        "type": "string",
                        "description": "Default: org-root\n\nOrg dn (distinguished name)"
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "description",
                                    "descr"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "ucs_uuid_pool": {
                  "type": "object",
                  "description": "Configures server UUID pools and UUID blocks on Cisco UCS Manager.\nExamples can be used with the L(UCS Platform Emulator,https://communities.cisco.com/ucspe).",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIf C(present), will verify UUID pool is present and will create if needed.\nIf C(absent), will verify UUID pool is absent and will delete if needed.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the UUID pool.\nThis name can be between 1 and 32 alphanumeric characters.\nYou cannot use spaces or any special characters other than - (hyphen), \"_\" (underscore), : (colon), and . (period).\nYou cannot change this name after the UUID pool is created."
                     },
                     "description": {
                        "type": "string",
                        "description": "The user-defined description of the UUID pool.\nEnter up to 256 characters.\nYou can use any characters or spaces except the following:\n` (accent mark),  (backslash), ^ (carat), \" (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote)."
                     },
                     "descr": {
                        "type": "string",
                        "description": "The user-defined description of the UUID pool.\nEnter up to 256 characters.\nYou can use any characters or spaces except the following:\n` (accent mark),  (backslash), ^ (carat), \" (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote)."
                     },
                     "prefix": {
                        "type": "string",
                        "description": "UUID prefix used for the range of server UUIDs.\nIf no value is provided, the system derived prefix will be used (equivalent to selecting 'derived' option in UI).\nIf the user provides a value, the user provided prefix will be used (equivalent to selecting 'other' option in UI).\nA user provided value should be in the format XXXXXXXX-XXXX-XXXX."
                     },
                     "order": {
                        "type": "string",
                        "description": "Default: default\n\nThe Assignment Order field.\nThis can be one of the following:\ndefault - Cisco UCS Manager selects a random identity from the pool.\nsequential - Cisco UCS Manager selects the lowest available identity from the pool.",
                        "enum": [
                           "default",
                           "sequential"
                        ]
                     },
                     "first_uuid": {
                        "type": "string",
                        "description": "The first UUID in the block of UUIDs.\nThis is the From field in the UCS Manager UUID Blocks menu."
                     },
                     "last_uuid": {
                        "type": "string",
                        "description": "The last UUID in the block of UUIDs.\nThis is the To field in the UCS Manager Add UUID Blocks menu."
                     },
                     "org_dn": {
                        "type": "string",
                        "description": "Default: org-root\n\nThe distinguished name (dn) of the organization where the resource is assigned."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "description",
                                    "descr"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "ucs_timezone": {
                  "type": "object",
                  "description": "Configures timezone on Cisco UCS Manager.\nExamples can be used with the L(UCS Platform Emulator,https://communities.cisco.com/ucspe).",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIf C(absent), will unset timezone.\nIf C(present), will set or update timezone.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "admin_state": {
                        "type": "string",
                        "description": "Default: enabled\n\nThe admin_state setting\nThe enabled admin_state indicates the timezone configuration is utilized by UCS Manager.\nThe disabled admin_state indicates the timezone configuration is ignored by UCS Manager.",
                        "enum": [
                           "disabled",
                           "enabled"
                        ]
                     },
                     "description": {
                        "type": "string",
                        "description": "A user-defined description of the timezone.\nEnter up to 256 characters.\nYou can use any characters or spaces except the following:\n` (accent mark),  (backslash), ^ (carat), \" (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote)."
                     },
                     "descr": {
                        "type": "string",
                        "description": "A user-defined description of the timezone.\nEnter up to 256 characters.\nYou can use any characters or spaces except the following:\n` (accent mark),  (backslash), ^ (carat), \" (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote)."
                     },
                     "timezone": {
                        "type": "string",
                        "description": "The timezone name.\nTime zone names are from the L(tz database,https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)\nThe timezone name is case sensitive.\nThe timezone name can be between 0 and 510 alphanumeric characters.\nYou cannot use spaces or any special characters other than\n\"-\" (hyphen), \"_\" (underscore), \"/\" (backslash)."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "description",
                                    "descr"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "ucs_storage_profile": {
                  "type": "object",
                  "description": "Configures storage profiles on Cisco UCS Manager.\nExamples can be used with the L(UCS Platform Emulator,https://communities.cisco.com/ucspe).",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIf C(present), will verify that the storage profile is present and will create if needed.\nIf C(absent), will verify that the storage profile is absent and will delete if needed.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the storage profile.\nThis name can be between 1 and 16 alphanumeric characters.\nYou cannot use spaces or any special characters other than - (hyphen), \"_\" (underscore), : (colon), and . (period).\nYou cannot change this name after profile is created."
                     },
                     "description": {
                        "type": "string",
                        "description": "The user-defined description of the storage profile.\nEnter up to 256 characters.\nYou can use any characters or spaces except the following:\n` (accent mark),  (backslash), ^ (carat), \" (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote)."
                     },
                     "descr": {
                        "type": "string",
                        "description": "The user-defined description of the storage profile.\nEnter up to 256 characters.\nYou can use any characters or spaces except the following:\n` (accent mark),  (backslash), ^ (carat), \" (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote)."
                     },
                     "local_luns": {
                        "type": "array",
                        "description": "List of Local LUNs used by the storage profile."
                     },
                     "org_dn": {
                        "type": "string",
                        "description": "Default: org-root\n\nThe distinguished name (dn) of the organization where the resource is assigned."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "description",
                                    "descr"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "ucs_service_profile_template": {
                  "type": "object",
                  "description": "Configures Service Profile Templates on Cisco UCS Manager.\nExamples can be used with the UCS Platform Emulator U(https://communities.cisco.com/ucspe).",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIf C(present), will verify Service Profile Templates are present and will create if needed.\nIf C(absent), will verify Service Profile Templates are absent and will delete if needed.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the service profile template.\nThis name can be between 2 and 32 alphanumeric characters.\nYou cannot use spaces or any special characters other than - (hyphen), \"_\" (underscore), : (colon), and . (period).\nThis name must be unique across all service profiles and service profile templates within the same organization."
                     },
                     "template_type": {
                        "type": "string",
                        "description": "Default: initial-template\n\nThe template type field which can be one of the following:\ninitial-template \u2014 Any service profiles created from this template are not updated if the template changes.\nupdating-template \u2014 Any service profiles created from this template are updated if the template changes.",
                        "enum": [
                           "initial-template",
                           "updating-template"
                        ]
                     },
                     "uuid_pool": {
                        "type": "string",
                        "description": "Default: default\n\nSpecifies how the UUID will be set on a server associated with a service profile created from this template.\nThe uuid_pool option can be the name of the UUID pool to use or '' (the empty string).\nAn empty string will use the UUID assigned to the server by the manufacturer, and the\nUUID remains unassigned until a service profile created from this template is associated with a server. At that point,\nthe UUID is set to the UUID value assigned to the server by the manufacturer. If the service profile is later moved to\na different server, the UUID is changed to match the new server.\""
                     },
                     "description": {
                        "type": "string",
                        "description": "A user-defined description of the service profile template.\nEnter up to 256 characters.\nYou can use any characters or spaces except the following:\n` (accent mark),  (backslash), ^ (carat), \" (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote)."
                     },
                     "descr": {
                        "type": "string",
                        "description": "A user-defined description of the service profile template.\nEnter up to 256 characters.\nYou can use any characters or spaces except the following:\n` (accent mark),  (backslash), ^ (carat), \" (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote)."
                     },
                     "storage_profile": {
                        "type": "string",
                        "description": "The name of the storage profile you want to associate with service profiles created from this template"
                     },
                     "local_disk_policy": {
                        "type": "string",
                        "description": "The name of the local disk policy you want to associate with service profiles created from this template."
                     },
                     "lan_connectivity_policy": {
                        "type": "string",
                        "description": "The name of the LAN connectivity policy you want to associate with service profiles created from this template."
                     },
                     "iqn_pool": {
                        "type": "string",
                        "description": "The name of the IQN pool (initiator) you want to apply to all iSCSI vNICs for service profiles created from this template."
                     },
                     "san_connectivity_policy": {
                        "type": "string",
                        "description": "The name of the SAN connectivity policy you want to associate with service profiles created from this template."
                     },
                     "vmedia_policy": {
                        "type": "string",
                        "description": "The name of the vMedia policy you want to associate with service profiles created from this template."
                     },
                     "boot_policy": {
                        "type": "string",
                        "description": "Default: default\n\nThe name of the boot order policy you want to associate with service profiles created from this template."
                     },
                     "maintenance_policy": {
                        "type": "string",
                        "description": "The name of the maintenance policy you want to associate with service profiles created from this template."
                     },
                     "server_pool": {
                        "type": "string",
                        "description": "The name of the server pool you want to associate with this service profile template."
                     },
                     "server_pool_qualification": {
                        "type": "string",
                        "description": "The name of the server pool policy qualification you want to use for this service profile template."
                     },
                     "power_state": {
                        "type": "string",
                        "description": "Default: up\n\nThe power state to be applied when a service profile created from this template is associated with a server.",
                        "enum": [
                           "up",
                           "down"
                        ]
                     },
                     "host_firmware_package": {
                        "type": "string",
                        "description": "The name of the host firmware package you want to associate with service profiles created from this template."
                     },
                     "bios_policy": {
                        "type": "string",
                        "description": "The name of the BIOS policy you want to associate with service profiles created from this template."
                     },
                     "ipmi_access_profile": {
                        "type": "string",
                        "description": "The name of the IPMI access profile you want to associate with service profiles created from this template."
                     },
                     "sol_policy": {
                        "type": "string",
                        "description": "The name of the Serial over LAN (SoL) policy you want to associate with service profiles created from this template."
                     },
                     "mgmt_ip_pool": {
                        "type": "string",
                        "description": "Default: ext-mgmt\n\nThe name of the management IP pool you want to use with service profiles created from this template."
                     },
                     "power_control_policy": {
                        "type": "string",
                        "description": "Default: default\n\nThe name of the power control policy you want to associate with service profiles created from this template."
                     },
                     "power_sync_policy": {
                        "type": "string",
                        "description": "The name of the power sync policy you want to associate with service profiles created from this template."
                     },
                     "scrub_policy": {
                        "type": "string",
                        "description": "The name of the scrub policy you want to associate with service profiles created from this template."
                     },
                     "kvm_mgmt_policy": {
                        "type": "string",
                        "description": "The name of the KVM management policy you want to associate with service profiles created from this template."
                     },
                     "graphics_card_policy": {
                        "type": "string",
                        "description": "The name of the graphics card policy you want to associate with service profiles created from this template."
                     },
                     "threshold_policy": {
                        "type": "string",
                        "description": "Default: default\n\nThe name of the threshold policy you want to associate with service profiles created from this template."
                     },
                     "user_label": {
                        "type": "string",
                        "description": "The User Label you want to assign to service profiles created from this template."
                     },
                     "mgmt_interface_mode": {
                        "type": "string",
                        "description": "The Management Interface you want to assign to service profiles created from this template.",
                        "enum": [
                           "",
                           "in-band"
                        ]
                     },
                     "mgmt_vnet_name": {
                        "type": "string",
                        "description": "A VLAN selected from the associated VLAN group."
                     },
                     "mgmt_inband_pool_name": {
                        "type": "string",
                        "description": "How the inband management IPv4 address is derived for the server associated with this service profile."
                     },
                     "org_dn": {
                        "type": "string",
                        "description": "Default: org-root\n\nOrg dn (distinguished name)"
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "description",
                                    "descr"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "ucs_san_connectivity": {
                  "type": "object",
                  "description": "Configures SAN Connectivity Policies on Cisco UCS Manager.\nExamples can be used with the UCS Platform Emulator U(https://communities.cisco.com/ucspe).",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIf C(present), will verify SAN Connectivity Policies are present and will create if needed.\nIf C(absent), will verify SAN Connectivity Policies are absent and will delete if needed.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the SAN Connectivity Policy.\nThis name can be between 1 and 16 alphanumeric characters.\nYou cannot use spaces or any special characters other than - (hyphen), \"_\" (underscore), : (colon), and . (period).\nYou cannot change this name after the policy is created."
                     },
                     "description": {
                        "type": "string",
                        "description": "A description of the policy.\nCisco recommends including information about where and when to use the policy.\nEnter up to 256 characters.\nYou can use any characters or spaces except the following:\n` (accent mark),  (backslash), ^ (carat), \" (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote)."
                     },
                     "descr": {
                        "type": "string",
                        "description": "A description of the policy.\nCisco recommends including information about where and when to use the policy.\nEnter up to 256 characters.\nYou can use any characters or spaces except the following:\n` (accent mark),  (backslash), ^ (carat), \" (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote)."
                     },
                     "wwnn_pool": {
                        "type": "string",
                        "description": "Default: default\n\nName of the WWNN pool to use for WWNN assignment."
                     },
                     "vhba_list": {
                        "type": "array",
                        "description": "List of vHBAs used by the SAN Connectivity Policy.\nvHBAs used by the SAN Connectivity Policy must be created from a vHBA template.\nEach list element has the following suboptions:\n= name\n  The name of the virtual HBA (required).\n= vhba_template\n  The name of the virtual HBA template (required).\n- adapter_policy\n  The name of the Fibre Channel adapter policy.\n  A user defined policy can be used, or one of the system defined policies (default, Linux, Solaris, VMware, Windows, WindowsBoot)\n  [Default: default]\n- order\n  String specifying the vHBA assignment order (e.g., '1', '2').\n  [Default: unspecified]"
                     },
                     "org_dn": {
                        "type": "string",
                        "description": "Default: org-root\n\nOrg dn (distinguished name)"
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "description",
                                    "descr"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "ucs_org": {
                  "type": "object",
                  "description": "Manages UCS Organizations for UCS Manager.\nExamples can be used with the UCS Platform Emulator U(https://cs.co/ucspe).",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIf C(absent), will remove organization.\nIf C(present), will create or update organization.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "org_name": {
                        "type": "string",
                        "description": "The name of the organization.\nEnter up to 16 characters.\nYou can use any characters or spaces except the following:\n` (accent mark),  (backslash), ^ (carat), \" (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote)."
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the organization.\nEnter up to 16 characters.\nYou can use any characters or spaces except the following:\n` (accent mark),  (backslash), ^ (carat), \" (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote)."
                     },
                     "parent_org_path": {
                        "type": "string",
                        "description": "Default: root\n\nA forward slash / separated hierarchical path from the root organization to the parent of the organization to be added or updated.\nUCS Manager supports a hierarchical structure of organizations up to five levels deep not including the root organization.\nFor example the parent_org_path for an organization named level5 could be root/level1/level2/level3/level4/level5"
                     },
                     "description": {
                        "type": "string",
                        "description": "A user-defined description of the organization.\nEnter up to 256 characters.\nYou can use any characters or spaces except the following:\n` (accent mark),  (backslash), ^ (carat), \" (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote)."
                     },
                     "descr": {
                        "type": "string",
                        "description": "A user-defined description of the organization.\nEnter up to 256 characters.\nYou can use any characters or spaces except the following:\n` (accent mark),  (backslash), ^ (carat), \" (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote)."
                     },
                     "delegate_to": {
                        "type": "string",
                        "description": "Default: localhost\n\nWhere the module will be run"
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "org_name",
                                    "name"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "description",
                                    "descr"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "ucs_ntp_server": {
                  "type": "object",
                  "description": "Configures NTP server on Cisco UCS Manager.\nExamples can be used with the L(UCS Platform Emulator,https://communities.cisco.com/ucspe).",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIf C(absent), will remove an NTP server.\nIf C(present), will add or update an NTP server.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "ntp_server": {
                        "type": "string",
                        "description": "NTP server IP address or hostname.\nEnter up to 63 characters that form a valid hostname.\nEnter a valid IPV4 Address."
                     },
                     "name": {
                        "type": "string",
                        "description": "NTP server IP address or hostname.\nEnter up to 63 characters that form a valid hostname.\nEnter a valid IPV4 Address."
                     },
                     "description": {
                        "type": "string",
                        "description": "A user-defined description of the NTP server.\nEnter up to 256 characters.\nYou can use any characters or spaces except the following:\n` (accent mark),  (backslash), ^ (carat), \" (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote)."
                     },
                     "descr": {
                        "type": "string",
                        "description": "A user-defined description of the NTP server.\nEnter up to 256 characters.\nYou can use any characters or spaces except the following:\n` (accent mark),  (backslash), ^ (carat), \" (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote)."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "ntp_server",
                                    "name"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "description",
                                    "descr"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "ucs_managed_objects": {
                  "type": "object",
                  "description": "Configures Managed Objects on Cisco UCS Manager.\nThe Python SDK module, Python class within the module (UCSM Class), and all properties must be directly specified.\nMore information on the UCSM Python SDK and how to directly configure Managed Objects is available at L(UCSM Python SDK,http://ucsmsdk.readthedocs.io/).\nExamples can be used with the UCS Platform Emulator U(https://communities.cisco.com/ucspe).",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIf C(present), will verify that the Managed Objects are present and will create if needed.\nIf C(absent), will verify that the Managed Objects are absent and will delete if needed.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "objects": {
                        "type": "array",
                        "description": "List of managed objects to configure.  Each managed object has suboptions the specify the Python SDK module, class, and properties to configure."
                     }
                  },
                  "required": [
                     "objects"
                  ]
               },
               "ucs_mac_pool": {
                  "type": "object",
                  "description": "Configures MAC address pools and MAC address blocks on Cisco UCS Manager.\nExamples can be used with the UCS Platform Emulator U(https://communities.cisco.com/ucspe).",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIf C(present), will verify MAC pool is present and will create if needed.\nIf C(absent), will verify MAC pool is absent and will delete if needed.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the MAC pool.\nThis name can be between 1 and 32 alphanumeric characters.\nYou cannot use spaces or any special characters other than - (hyphen), \"_\" (underscore), : (colon), and . (period).\nYou cannot change this name after the MAC pool is created."
                     },
                     "description": {
                        "type": "string",
                        "description": "A description of the MAC pool.\nEnter up to 256 characters.\nYou can use any characters or spaces except the following:\n` (accent mark),  (backslash), ^ (carat), \" (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote)."
                     },
                     "descr": {
                        "type": "string",
                        "description": "A description of the MAC pool.\nEnter up to 256 characters.\nYou can use any characters or spaces except the following:\n` (accent mark),  (backslash), ^ (carat), \" (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote)."
                     },
                     "descrption": {
                        "type": "string",
                        "description": "A description of the MAC pool.\nEnter up to 256 characters.\nYou can use any characters or spaces except the following:\n` (accent mark),  (backslash), ^ (carat), \" (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote)."
                     },
                     "order": {
                        "type": "string",
                        "description": "Default: default\n\nThe Assignment Order field.\nThis can be one of the following:\ndefault - Cisco UCS Manager selects a random identity from the pool.\nsequential - Cisco UCS Manager selects the lowest available identity from the pool.",
                        "enum": [
                           "default",
                           "sequential"
                        ]
                     },
                     "first_addr": {
                        "type": "string",
                        "description": "The first MAC address in the block of addresses.\nThis is the From field in the UCS Manager MAC Blocks menu."
                     },
                     "last_addr": {
                        "type": "string",
                        "description": "The last MAC address in the block of addresses.\nThis is the To field in the UCS Manager Add MAC Blocks menu."
                     },
                     "org_dn": {
                        "type": "string",
                        "description": "Default: org-root\n\nThe distinguished name (dn) of the organization where the resource is assigned."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "description",
                                    "descr",
                                    "descrption"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "ucs_lan_connectivity": {
                  "type": "object",
                  "description": "Configures LAN Connectivity Policies on Cisco UCS Manager.\nExamples can be used with the UCS Platform Emulator U(https://communities.cisco.com/ucspe).",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIf C(present), will verify LAN Connectivity Policies are present and will create if needed.\nIf C(absent), will verify LAN Connectivity Policies are absent and will delete if needed.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the LAN Connectivity Policy.\nThis name can be between 1 and 16 alphanumeric characters.\nYou cannot use spaces or any special characters other than - (hyphen), \"_\" (underscore), : (colon), and . (period).\nYou cannot change this name after the policy is created."
                     },
                     "description": {
                        "type": "string",
                        "description": "A description of the LAN Connectivity Policy.\nCisco recommends including information about where and when to use the policy.\nEnter up to 256 characters.\nYou can use any characters or spaces except the following:\n` (accent mark),  (backslash), ^ (carat), \" (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote)."
                     },
                     "descr": {
                        "type": "string",
                        "description": "A description of the LAN Connectivity Policy.\nCisco recommends including information about where and when to use the policy.\nEnter up to 256 characters.\nYou can use any characters or spaces except the following:\n` (accent mark),  (backslash), ^ (carat), \" (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote)."
                     },
                     "vnic_list": {
                        "type": "array",
                        "description": "List of vNICs used by the LAN Connectivity Policy.\nvNICs used by the LAN Connectivity Policy must be created from a vNIC template."
                     },
                     "iscsi_vnic_list": {
                        "type": "array",
                        "description": "List of iSCSI vNICs used by the LAN Connectivity Policy."
                     },
                     "org_dn": {
                        "type": "string",
                        "description": "Default: org-root\n\nOrg dn (distinguished name)"
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "description",
                                    "descr"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "ucs_ip_pool": {
                  "type": "object",
                  "description": "Configures IP address pools and blocks of IP addresses on Cisco UCS Manager.\nExamples can be used with the UCS Platform Emulator U(https://communities.cisco.com/ucspe).",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIf C(present), will verify IP pool is present and will create if needed.\nIf C(absent), will verify IP pool is absent and will delete if needed.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the IP address pool.\nThis name can be between 1 and 32 alphanumeric characters.\nYou cannot use spaces or any special characters other than - (hyphen), \"_\" (underscore), : (colon), and . (period).\nYou cannot change this name after the IP address pool is created."
                     },
                     "description": {
                        "type": "string",
                        "description": "The user-defined description of the IP address pool.\nEnter up to 256 characters.\nYou can use any characters or spaces except the following:\n` (accent mark),  (backslash), ^ (carat), \" (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote)."
                     },
                     "descr": {
                        "type": "string",
                        "description": "The user-defined description of the IP address pool.\nEnter up to 256 characters.\nYou can use any characters or spaces except the following:\n` (accent mark),  (backslash), ^ (carat), \" (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote)."
                     },
                     "descrption": {
                        "type": "string",
                        "description": "The user-defined description of the IP address pool.\nEnter up to 256 characters.\nYou can use any characters or spaces except the following:\n` (accent mark),  (backslash), ^ (carat), \" (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote)."
                     },
                     "order": {
                        "type": "string",
                        "description": "Default: default\n\nThe Assignment Order field.\nThis can be one of the following:\ndefault - Cisco UCS Manager selects a random identity from the pool.\nsequential - Cisco UCS Manager selects the lowest available identity from the pool.",
                        "enum": [
                           "default",
                           "sequential"
                        ]
                     },
                     "first_addr": {
                        "type": "string",
                        "description": "The first IPv4 address in the IPv4 addresses block.\nThis is the From field in the UCS Manager Add IPv4 Blocks menu."
                     },
                     "last_addr": {
                        "type": "string",
                        "description": "The last IPv4 address in the IPv4 addresses block.\nThis is the To field in the UCS Manager Add IPv4 Blocks menu."
                     },
                     "subnet_mask": {
                        "type": "string",
                        "description": "Default: 255.255.255.0\n\nThe subnet mask associated with the IPv4 addresses in the block."
                     },
                     "default_gw": {
                        "type": "string",
                        "description": "Default: 0.0.0.0\n\nThe default gateway associated with the IPv4 addresses in the block."
                     },
                     "primary_dns": {
                        "type": "string",
                        "description": "Default: 0.0.0.0\n\nThe primary DNS server that this block of IPv4 addresses should access."
                     },
                     "secondary_dns": {
                        "type": "string",
                        "description": "Default: 0.0.0.0\n\nThe secondary DNS server that this block of IPv4 addresses should access."
                     },
                     "ipv6_first_addr": {
                        "type": "string",
                        "description": "The first IPv6 address in the IPv6 addresses block.\nThis is the From field in the UCS Manager Add IPv6 Blocks menu."
                     },
                     "ipv6_last_addr": {
                        "type": "string",
                        "description": "The last IPv6 address in the IPv6 addresses block.\nThis is the To field in the UCS Manager Add IPv6 Blocks menu."
                     },
                     "ipv6_prefix": {
                        "type": "string",
                        "description": "Default: 64\n\nThe network address prefix associated with the IPv6 addresses in the block."
                     },
                     "ipv6_default_gw": {
                        "type": "string",
                        "description": "Default: ::\n\nThe default gateway associated with the IPv6 addresses in the block."
                     },
                     "ipv6_primary_dns": {
                        "type": "string",
                        "description": "Default: ::\n\nThe primary DNS server that this block of IPv6 addresses should access."
                     },
                     "ipv6_secondary_dns": {
                        "type": "string",
                        "description": "Default: ::\n\nThe secondary DNS server that this block of IPv6 addresses should access."
                     },
                     "org_dn": {
                        "type": "string",
                        "description": "Default: org-root\n\nOrg dn (distinguished name)"
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "description",
                                    "descr",
                                    "descrption"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "ucs_dns_server": {
                  "type": "object",
                  "description": "Configure DNS servers on Cisco UCS Manager.\nExamples can be used with the L(UCS Platform Emulator,https://communities.cisco.com/ucspe).",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIf C(absent), will remove a DNS server.\nIf C(present), will add or update a DNS server.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "dns_server": {
                        "type": "string",
                        "description": "DNS server IP address.\nEnter a valid IPV4 Address.\nUCS Manager supports up to 4 DNS Servers"
                     },
                     "name": {
                        "type": "string",
                        "description": "DNS server IP address.\nEnter a valid IPV4 Address.\nUCS Manager supports up to 4 DNS Servers"
                     },
                     "description": {
                        "type": "string",
                        "description": "A user-defined description of the DNS server.\nEnter up to 256 characters.\nYou can use any characters or spaces except the following:\n` (accent mark),  (backslash), ^ (carat), \" (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote)."
                     },
                     "descr": {
                        "type": "string",
                        "description": "A user-defined description of the DNS server.\nEnter up to 256 characters.\nYou can use any characters or spaces except the following:\n` (accent mark),  (backslash), ^ (carat), \" (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote)."
                     },
                     "delegate_to": {
                        "type": "string",
                        "description": "Default: localhost\n\nWhere the module will be run"
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "dns_server",
                                    "name"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "description",
                                    "descr"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "ucs_disk_group_policy": {
                  "type": "object",
                  "description": "Configures disk group policies on Cisco UCS Manager.\nExamples can be used with the L(UCS Platform Emulator,https://communities.cisco.com/ucspe).",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDesired state of the disk group policy.\nIf C(present), will verify that the disk group policy is present and will create if needed.\nIf C(absent), will verify that the disk group policy is absent and will delete if needed.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the disk group policy. This name can be between 1 and 16 alphanumeric characters.\nYou cannot use spaces or any special characters other than - (hyphen), \"_\" (underscore), : (colon), and . (period).\nYou cannot change this name after the policy is created."
                     },
                     "description": {
                        "type": "string",
                        "description": "The user-defined description of the storage profile. Enter up to 256 characters. \"You can use any characters or spaces except the following:\" \"` (accent mark), \\ (backslash), ^ (carat), \\\" (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote).\""
                     },
                     "descr": {
                        "type": "string",
                        "description": "The user-defined description of the storage profile. Enter up to 256 characters. \"You can use any characters or spaces except the following:\" \"` (accent mark), \\ (backslash), ^ (carat), \\\" (double quote), = (equal sign), > (greater than), < (less than), or ' (single quote).\""
                     },
                     "raid_level": {
                        "type": "string",
                        "description": "Default: stripe\n\nThe RAID level for the disk group policy. This can be one of the following:\nstripe - UCS Manager shows RAID 0 Striped\nmirror - RAID 1 Mirrored\nmirror-stripe - RAID 10 Mirrored and Striped\nstripe-parity - RAID 5 Striped Parity\nstripe-dual-parity - RAID 6 Striped Dual Parity\nstripe-parity-stripe - RAID 50 Striped Parity and Striped\nstripe-dual-parity-stripe - RAID 60 Striped Dual Parity and Striped",
                        "enum": [
                           "stripe",
                           "mirror",
                           "mirror-stripe",
                           "stripe-parity",
                           "stripe-dual-parity",
                           "stripe-parity-stripe",
                           "stripe-dual-parity-stripe"
                        ]
                     },
                     "configuration_mode": {
                        "type": "string",
                        "description": "Default: automatic\n\nDisk group configuration mode. Choose one of the following:\nautomatic - Automatically configures the disks in the disk group.\nmanual - Enables you to manually configure the disks in the disk group.",
                        "enum": [
                           "automatic",
                           "manual"
                        ]
                     },
                     "num_drives": {
                        "type": "string",
                        "description": "Default: 1\n\nSpecify the number of drives for the disk group.\nThis can be from 0 to 24.\nOption only applies when configuration mode is automatic."
                     },
                     "drive_type": {
                        "type": "string",
                        "description": "Default: unspecified\n\nSpecify the drive type to use in the drive group.\nThis can be one of the following:\nunspecified \u2014 Selects the first available drive type, and applies that to all drives in the group.\nHDD \u2014 Hard disk drive\nSSD \u2014 Solid state drive\nOption only applies when configuration mode is automatic.",
                        "enum": [
                           "unspecified",
                           "HDD",
                           "SSD"
                        ]
                     },
                     "num_ded_hot_spares": {
                        "type": "string",
                        "description": "Default: unspecified\n\nSpecify the number of hot spares for the disk group.\nThis can be from 0 to 24.\nOption only applies when configuration mode is automatic."
                     },
                     "num_glob_hot_spares": {
                        "type": "string",
                        "description": "Default: unspecified\n\nSpecify the number of global hot spares for the disk group.\nThis can be from 0 to 24.\nOption only applies when configuration mode is automatic."
                     },
                     "min_drive_size": {
                        "type": "string",
                        "description": "Default: unspecified\n\nSpecify the minimum drive size or unspecified to allow all drive sizes.\nThis can be from 0 to 10240 GB.\nOption only applies when configuration mode is automatic."
                     },
                     "use_remaining_disks": {
                        "type": "string",
                        "description": "Default: no\n\nSpecifies whether you can use all the remaining disks in the disk group or not.\nOption only applies when configuration mode is automatic.",
                        "enum": [
                           "yes",
                           "no"
                        ]
                     },
                     "manual_disks": {
                        "type": "array",
                        "description": "List of manually configured disks.\nOptions are only used when you choose manual configuration_mode."
                     },
                     "virtual_drive": {
                        "type": "string",
                        "description": "Configuration of virtual drive options."
                     },
                     "org_dn": {
                        "type": "string",
                        "description": "Default: org-root\n\nThe distinguished name (dn) of the organization where the resource is assigned."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "description",
                                    "descr"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "stacki_host": {
                  "type": "object",
                  "description": "Use this module to add or remove hosts to a stacki front-end via API.\nU(https://github.com/StackIQ/stacki)",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the host to be added to Stacki."
                     },
                     "stacki_user": {
                        "type": "string",
                        "description": "Username for authenticating with Stacki API, but if not specified, the environment variable C(stacki_user) is used instead."
                     },
                     "stacki_password": {
                        "type": "string",
                        "description": "Password for authenticating with Stacki API, but if not specified, the environment variable C(stacki_password) is used instead."
                     },
                     "stacki_endpoint": {
                        "type": "string",
                        "description": "URL for the Stacki API Endpoint."
                     },
                     "prim_intf_mac": {
                        "type": "string",
                        "description": "MAC Address for the primary PXE boot network interface."
                     },
                     "prim_intf_ip": {
                        "type": "string",
                        "description": "IP Address for the primary network interface."
                     },
                     "prim_intf": {
                        "type": "string",
                        "description": "Name of the primary network interface."
                     },
                     "force_install": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Set value to True to force node into install state if it already exists in stacki."
                     }
                  },
                  "required": [
                     "name",
                     "stacki_user",
                     "stacki_password",
                     "stacki_endpoint"
                  ]
               },
               "redfish_info": {
                  "type": "object",
                  "description": "Builds Redfish URIs locally and sends them to remote OOB controllers to get information back.\nInformation retrieved is placed in a location specified by the user.\nThis module was called C(redfish_facts) before Ansible 2.9, returning C(ansible_facts). Note that the M(redfish_info) module no longer returns C(ansible_facts)!",
                  "properties": {
                     "category": {
                        "type": "array",
                        "description": "Default: ['Systems']\n\nList of categories to execute on OOB controller"
                     },
                     "command": {
                        "type": "array",
                        "description": "List of commands to execute on OOB controller"
                     },
                     "baseuri": {
                        "type": "string",
                        "description": "Base URI of OOB controller"
                     },
                     "username": {
                        "type": "string",
                        "description": "User for authentication with OOB controller"
                     },
                     "password": {
                        "type": "string",
                        "description": "Password for authentication with OOB controller"
                     },
                     "timeout": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 10\n\nTimeout in seconds for URL requests to OOB controller"
                     }
                  },
                  "required": [
                     "baseuri",
                     "username",
                     "password"
                  ]
               },
               "redfish_config": {
                  "type": "object",
                  "description": "Builds Redfish URIs locally and sends them to remote OOB controllers to set or update a configuration attribute.\nManages BIOS configuration settings.\nManages OOB controller configuration settings.",
                  "properties": {
                     "category": {
                        "type": "string",
                        "description": "Category to execute on OOB controller"
                     },
                     "command": {
                        "type": "array",
                        "description": "List of commands to execute on OOB controller"
                     },
                     "baseuri": {
                        "type": "string",
                        "description": "Base URI of OOB controller"
                     },
                     "username": {
                        "type": "string",
                        "description": "User for authentication with OOB controller"
                     },
                     "password": {
                        "type": "string",
                        "description": "Password for authentication with OOB controller"
                     },
                     "bios_attribute_name": {
                        "type": "string",
                        "description": "Default: null\n\nname of BIOS attribute to update"
                     },
                     "bios_attribute_value": {
                        "type": "string",
                        "description": "Default: null\n\nvalue of BIOS attribute to update"
                     },
                     "timeout": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 10\n\nTimeout in seconds for URL requests to OOB controller"
                     }
                  },
                  "required": [
                     "category",
                     "command",
                     "baseuri",
                     "username",
                     "password"
                  ]
               },
               "redfish_command": {
                  "type": "object",
                  "description": "Builds Redfish URIs locally and sends them to remote OOB controllers to perform an action.\nManages OOB controller ex. reboot, log management.\nManages OOB controller users ex. add, remove, update.\nManages system power ex. on, off, graceful and forced reboot.",
                  "properties": {
                     "category": {
                        "type": "string",
                        "description": "Category to execute on OOB controller"
                     },
                     "command": {
                        "type": "array",
                        "description": "List of commands to execute on OOB controller"
                     },
                     "baseuri": {
                        "type": "string",
                        "description": "Base URI of OOB controller"
                     },
                     "username": {
                        "type": "string",
                        "description": "User for authentication with OOB controller"
                     },
                     "password": {
                        "type": "string",
                        "description": "Password for authentication with OOB controller"
                     },
                     "id": {
                        "type": "string",
                        "description": "ID of user to add/delete/modify"
                     },
                     "new_username": {
                        "type": "string",
                        "description": "name of user to add/delete/modify"
                     },
                     "new_password": {
                        "type": "string",
                        "description": "password of user to add/delete/modify"
                     },
                     "roleid": {
                        "type": "string",
                        "description": "role of user to add/delete/modify"
                     },
                     "bootdevice": {
                        "type": "string",
                        "description": "bootdevice when setting boot configuration"
                     },
                     "timeout": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 10\n\nTimeout in seconds for URL requests to OOB controller"
                     },
                     "uefi_target": {
                        "type": "string",
                        "description": "UEFI target when bootdevice is \"UefiTarget\""
                     },
                     "boot_next": {
                        "type": "string",
                        "description": "BootNext target when bootdevice is \"UefiBootNext\""
                     }
                  },
                  "required": [
                     "category",
                     "command",
                     "baseuri",
                     "username",
                     "password"
                  ]
               },
               "idrac_redfish_info": {
                  "type": "object",
                  "description": "Builds Redfish URIs locally and sends them to remote iDRAC controllers to get information back.\nFor use with Dell iDRAC operations that require Redfish OEM extensions\nThis module was called C(idrac_redfish_facts) before Ansible 2.9, returning C(ansible_facts). Note that the M(idrac_redfish_info) module no longer returns C(ansible_facts)!",
                  "properties": {
                     "category": {
                        "type": "string",
                        "description": "Category to execute on iDRAC controller"
                     },
                     "command": {
                        "type": "array",
                        "description": "List of commands to execute on iDRAC controller"
                     },
                     "baseuri": {
                        "type": "string",
                        "description": "Base URI of iDRAC controller"
                     },
                     "username": {
                        "type": "string",
                        "description": "User for authentication with iDRAC controller"
                     },
                     "password": {
                        "type": "string",
                        "description": "Password for authentication with iDRAC controller"
                     },
                     "timeout": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 10\n\nTimeout in seconds for URL requests to OOB controller"
                     }
                  },
                  "required": [
                     "category",
                     "command",
                     "baseuri",
                     "username",
                     "password"
                  ]
               },
               "idrac_redfish_config": {
                  "type": "object",
                  "description": "For use with Dell iDRAC operations that require Redfish OEM extensions\nBuilds Redfish URIs locally and sends them to remote iDRAC controllers to set or update a configuration attribute.",
                  "properties": {
                     "category": {
                        "type": "string",
                        "description": "Category to execute on iDRAC"
                     },
                     "command": {
                        "type": "array",
                        "description": "List of commands to execute on iDRAC"
                     },
                     "baseuri": {
                        "type": "string",
                        "description": "Base URI of iDRAC"
                     },
                     "username": {
                        "type": "string",
                        "description": "User for authentication with iDRAC"
                     },
                     "password": {
                        "type": "string",
                        "description": "Password for authentication with iDRAC"
                     },
                     "manager_attribute_name": {
                        "type": "string",
                        "description": "Default: null\n\nname of iDRAC attribute to update"
                     },
                     "manager_attribute_value": {
                        "type": "string",
                        "description": "Default: null\n\nvalue of iDRAC attribute to update"
                     },
                     "timeout": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 10\n\nTimeout in seconds for URL requests to iDRAC controller"
                     }
                  },
                  "required": [
                     "category",
                     "command",
                     "baseuri",
                     "username",
                     "password"
                  ]
               },
               "idrac_redfish_command": {
                  "type": "object",
                  "description": "Builds Redfish URIs locally and sends them to remote OOB controllers to perform an action.\nFor use with Dell iDRAC operations that require Redfish OEM extensions",
                  "properties": {
                     "category": {
                        "type": "string",
                        "description": "Category to execute on OOB controller"
                     },
                     "command": {
                        "type": "array",
                        "description": "List of commands to execute on OOB controller"
                     },
                     "baseuri": {
                        "type": "string",
                        "description": "Base URI of OOB controller"
                     },
                     "username": {
                        "type": "string",
                        "description": "User for authentication with OOB controller"
                     },
                     "password": {
                        "type": "string",
                        "description": "Password for authentication with OOB controller"
                     },
                     "timeout": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 10\n\nTimeout in seconds for URL requests to OOB controller"
                     }
                  },
                  "required": [
                     "category",
                     "command",
                     "baseuri",
                     "username",
                     "password"
                  ]
               },
               "oneview_san_manager_info": {
                  "type": "object",
                  "description": "Retrieve information about one or more of the SAN Managers from OneView\nThis module was called C(oneview_san_manager_facts) before Ansible 2.9, returning C(ansible_facts). Note that the M(oneview_san_manager_info) module no longer returns C(ansible_facts)!",
                  "properties": {
                     "provider_display_name": {
                        "type": "string",
                        "description": "Provider Display Name."
                     },
                     "params": {
                        "type": "array",
                        "description": "List of params to delimit, filter and sort the list of resources.\nparams allowed: - C(start): The first item to return, using 0-based indexing. - C(count): The number of resources to return. - C(query): A general query string to narrow the list of resources returned. - C(sort): The sort order of the returned data set."
                     }
                  }
               },
               "oneview_san_manager": {
                  "type": "object",
                  "description": "Provides an interface to manage SAN Manager resources. Can create, update, or delete.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIndicates the desired state for the Uplink Set resource. - C(present) ensures data properties are compliant with OneView. - C(absent) removes the resource from OneView, if it exists. - C(connection_information_set) updates the connection information for the SAN Manager. This operation is non-idempotent.",
                        "enum": [
                           "present",
                           "absent",
                           "connection_information_set"
                        ]
                     },
                     "data": {
                        "type": "array",
                        "description": "List with SAN Manager properties."
                     }
                  },
                  "required": [
                     "data"
                  ]
               },
               "oneview_network_set_info": {
                  "type": "object",
                  "description": "Retrieve information about the Network Sets from OneView.\nThis module was called C(oneview_network_set_facts) before Ansible 2.9, returning C(ansible_facts). Note that the M(oneview_network_set_info) module no longer returns C(ansible_facts)!",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Network Set name."
                     },
                     "options": {
                        "type": "array",
                        "description": "List with options to gather information about Network Set. Option allowed: C(withoutEthernet). The option C(withoutEthernet) retrieves the list of network_sets excluding Ethernet networks."
                     }
                  }
               },
               "oneview_network_set": {
                  "type": "object",
                  "description": "Provides an interface to manage Network Set resources. Can create, update, or delete.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIndicates the desired state for the Network Set resource. - C(present) will ensure data properties are compliant with OneView. - C(absent) will remove the resource from OneView, if it exists.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "data": {
                        "type": "array",
                        "description": "List with the Network Set properties."
                     }
                  },
                  "required": [
                     "data"
                  ]
               },
               "oneview_logical_interconnect_group_info": {
                  "type": "object",
                  "description": "Retrieve information about one or more of the Logical Interconnect Groups from OneView\nThis module was called C(oneview_logical_interconnect_group_facts) before Ansible 2.9, returning C(ansible_facts). Note that the M(oneview_logical_interconnect_group_info) module no longer returns C(ansible_facts)!",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Logical Interconnect Group name."
                     }
                  }
               },
               "oneview_logical_interconnect_group": {
                  "type": "object",
                  "description": "Provides an interface to manage Logical Interconnect Group resources. Can create, update, or delete.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIndicates the desired state for the Logical Interconnect Group resource. C(absent) will remove the resource from OneView, if it exists. C(present) will ensure data properties are compliant with OneView.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "data": {
                        "type": "array",
                        "description": "List with the Logical Interconnect Group properties."
                     }
                  },
                  "required": [
                     "data"
                  ]
               },
               "oneview_fcoe_network_info": {
                  "type": "object",
                  "description": "Retrieve the information about one or more of the FCoE Networks from OneView.\nThis module was called C(oneview_fcoe_network_facts) before Ansible 2.9, returning C(ansible_facts). Note that the M(oneview_fcoe_network_info) module no longer returns C(ansible_facts)!",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "FCoE Network name."
                     }
                  }
               },
               "oneview_fcoe_network": {
                  "type": "object",
                  "description": "Provides an interface to manage FCoE Network resources. Can create, update, or delete.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIndicates the desired state for the FCoE Network resource. C(present) will ensure data properties are compliant with OneView. C(absent) will remove the resource from OneView, if it exists.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "data": {
                        "type": "array",
                        "description": "List with FCoE Network properties."
                     }
                  },
                  "required": [
                     "data"
                  ]
               },
               "oneview_fc_network_info": {
                  "type": "object",
                  "description": "Retrieve the information about one or more of the Fibre Channel Networks from OneView.\nThis module was called C(oneview_fc_network_facts) before Ansible 2.9, returning C(ansible_facts). Note that the M(oneview_fc_network_info) module no longer returns C(ansible_facts)!",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Fibre Channel Network name."
                     }
                  }
               },
               "oneview_fc_network": {
                  "type": "object",
                  "description": "Provides an interface to manage Fibre Channel Network resources. Can create, update, and delete.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Indicates the desired state for the Fibre Channel Network resource. C(present) will ensure data properties are compliant with OneView. C(absent) will remove the resource from OneView, if it exists.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "data": {
                        "type": "array",
                        "description": "List with the Fibre Channel Network properties."
                     }
                  },
                  "required": [
                     "data"
                  ]
               },
               "oneview_ethernet_network_info": {
                  "type": "object",
                  "description": "Retrieve the information about one or more of the Ethernet Networks from OneView.\nThis module was called C(oneview_ethernet_network_facts) before Ansible 2.9, returning C(ansible_facts). Note that the M(oneview_ethernet_network_info) module no longer returns C(ansible_facts)!",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Ethernet Network name."
                     },
                     "options": {
                        "type": "array",
                        "description": "List with options to gather additional information about an Ethernet Network and related resources. Options allowed: C(associatedProfiles) and C(associatedUplinkGroups)."
                     }
                  }
               },
               "oneview_ethernet_network": {
                  "type": "object",
                  "description": "Provides an interface to manage Ethernet Network resources. Can create, update, or delete.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIndicates the desired state for the Ethernet Network resource. - C(present) will ensure data properties are compliant with OneView. - C(absent) will remove the resource from OneView, if it exists. - C(default_bandwidth_reset) will reset the network connection template to the default.",
                        "enum": [
                           "present",
                           "absent",
                           "default_bandwidth_reset"
                        ]
                     },
                     "data": {
                        "type": "array",
                        "description": "List with Ethernet Network properties."
                     }
                  },
                  "required": [
                     "data"
                  ]
               },
               "oneview_enclosure_info": {
                  "type": "object",
                  "description": "Retrieve information about one or more of the Enclosures from OneView.\nThis module was called C(oneview_enclosure_facts) before Ansible 2.9, returning C(ansible_facts). Note that the M(oneview_enclosure_info) module no longer returns C(ansible_facts)!",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Enclosure name."
                     },
                     "options": {
                        "type": "array",
                        "description": "List with options to gather additional information about an Enclosure and related resources. Options allowed: C(script), C(environmentalConfiguration), and C(utilization). For the option C(utilization), you can provide specific parameters."
                     }
                  }
               },
               "oneview_datacenter_info": {
                  "type": "object",
                  "description": "Retrieve information about the OneView Data Centers.\nThis module was called C(oneview_datacenter_facts) before Ansible 2.9, returning C(ansible_facts). Note that the M(oneview_datacenter_info) module no longer returns C(ansible_facts)!",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Data Center name."
                     },
                     "options": {
                        "type": "string",
                        "description": "Retrieve additional information. Options available: 'visualContent'."
                     }
                  }
               },
               "manageiq_user": {
                  "type": "object",
                  "description": "The manageiq_user module supports adding, updating and deleting users in ManageIQ.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nabsent - user should not exist, present - user should be.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "userid": {
                        "type": "string",
                        "description": "The unique userid in manageiq, often mentioned as username."
                     },
                     "name": {
                        "type": "string",
                        "description": "The users' full name."
                     },
                     "password": {
                        "type": "string",
                        "description": "The users' password."
                     },
                     "group": {
                        "type": "string",
                        "description": "The name of the group to which the user belongs."
                     },
                     "email": {
                        "type": "string",
                        "description": "The users' E-mail address."
                     },
                     "update_password": {
                        "type": "string",
                        "description": "Default: always\n\nC(always) will update passwords unconditionally.  C(on_create) will only set the password for a newly created user.",
                        "enum": [
                           "always",
                           "on_create"
                        ]
                     }
                  },
                  "required": [
                     "userid"
                  ]
               },
               "manageiq_tenant": {
                  "type": "object",
                  "description": "The manageiq_tenant module supports adding, updating and deleting tenants in ManageIQ.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nabsent - tenant should not exist, present - tenant should be.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The tenant name."
                     },
                     "description": {
                        "type": "string",
                        "description": "The tenant description."
                     },
                     "parent_id": {
                        "type": "string",
                        "description": "The id of the parent tenant. If not supplied the root tenant is used.\nThe C(parent_id) takes president over C(parent) when supplied"
                     },
                     "parent": {
                        "type": "string",
                        "description": "The name of the parent tenant. If not supplied and no C(parent_id) is supplied the root tenant is used."
                     },
                     "quotas": {
                        "type": "string",
                        "description": "The tenant quotas.\nAll parameters case sensitive.\nValid attributes are:\n - C(cpu_allocated) (int): use null to remove the quota.\n - C(mem_allocated) (GB): use null to remove the quota.\n - C(storage_allocated) (GB): use null to remove the quota.\n - C(vms_allocated) (int): use null to remove the quota.\n - C(templates_allocated) (int): use null to remove the quota."
                     }
                  },
                  "required": [
                     "name",
                     "description"
                  ]
               },
               "manageiq_tags": {
                  "type": "object",
                  "description": "The manageiq_tags module supports adding, updating and deleting tags in ManageIQ.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nabsent - tags should not exist,\npresent - tags should exist,\nlist - list current tags.",
                        "enum": [
                           "absent",
                           "present",
                           "list"
                        ]
                     },
                     "tags": {
                        "type": "string",
                        "description": "tags - list of dictionaries, each includes 'name' and 'category' keys.\nrequired if state is present or absent."
                     },
                     "resource_type": {
                        "type": "string",
                        "description": "the relevant resource type in manageiq\n\nPossible choices:\nprovider\nhost\nvm\nblueprint\ncategory\ncluster\ndata store\ngroup\nresource pool\nservice\nservice template\ntemplate\ntenant\nuser"
                     },
                     "resource_name": {
                        "type": "string",
                        "description": "the relevant resource name in manageiq"
                     }
                  },
                  "required": [
                     "resource_type",
                     "resource_name"
                  ]
               },
               "manageiq_provider": {
                  "type": "object",
                  "description": "The manageiq_provider module supports adding, updating, and deleting provider in ManageIQ.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nabsent - provider should not exist, present - provider should be present, refresh - provider will be refreshed",
                        "enum": [
                           "absent",
                           "present",
                           "refresh"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The provider's name."
                     },
                     "type": {
                        "type": "string",
                        "description": "The provider's type.",
                        "enum": [
                           "Openshift",
                           "Amazon",
                           "oVirt",
                           "VMware",
                           "Azure",
                           "Director",
                           "OpenStack",
                           "GCE"
                        ]
                     },
                     "zone": {
                        "type": "string",
                        "description": "Default: default\n\nThe ManageIQ zone name that will manage the provider."
                     },
                     "provider_region": {
                        "type": "string",
                        "description": "The provider region name to connect to (e.g. AWS region for Amazon)."
                     },
                     "host_default_vnc_port_start": {
                        "type": "string",
                        "description": "The first port in the host VNC range. defaults to None."
                     },
                     "host_default_vnc_port_end": {
                        "type": "string",
                        "description": "The last port in the host VNC range. defaults to None."
                     },
                     "subscription": {
                        "type": "string",
                        "description": "Microsoft Azure subscription ID. defaults to None."
                     },
                     "project": {
                        "type": "string",
                        "description": "Google Compute Engine Project ID. defaults to None."
                     },
                     "azure_tenant_id": {
                        "type": "string",
                        "description": "Tenant ID. defaults to None."
                     },
                     "keystone_v3_domain_id": {
                        "type": "string",
                        "description": "Tenant ID. defaults to None."
                     },
                     "tenant_mapping_enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nWhether to enable mapping of existing tenants. defaults to False."
                     },
                     "api_version": {
                        "type": "string",
                        "description": "The OpenStack Keystone API version. defaults to None.",
                        "enum": [
                           "v2",
                           "v3"
                        ]
                     },
                     "provider": {
                        "type": "string",
                        "description": "Default endpoint connection information, required if state is true."
                     },
                     "metrics": {
                        "type": "string",
                        "description": "Metrics endpoint connection information."
                     },
                     "alerts": {
                        "type": "string",
                        "description": "Alerts endpoint connection information."
                     },
                     "ssh_keypair": {
                        "type": "string",
                        "description": "SSH key pair used for SSH connections to all hosts in this provider."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "azure_tenant_id",
                                    "keystone_v3_domain_id"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "manageiq_policies": {
                  "type": "object",
                  "description": "The manageiq_policies module supports adding and deleting policy_profiles in ManageIQ.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nabsent - policy_profiles should not exist,\npresent - policy_profiles should exist,\nlist - list current policy_profiles and policies.",
                        "enum": [
                           "absent",
                           "present",
                           "list"
                        ]
                     },
                     "policy_profiles": {
                        "type": "array",
                        "description": "list of dictionaries, each includes the policy_profile 'name' key.\nrequired if state is present or absent."
                     },
                     "resource_type": {
                        "type": "string",
                        "description": "the type of the resource to which the profile should be [un]assigned\n\nPossible choices:\nprovider\nhost\nvm\nblueprint\ncategory\ncluster\ndata store\ngroup\nresource pool\nservice\nservice template\ntemplate\ntenant\nuser"
                     },
                     "resource_name": {
                        "type": "string",
                        "description": "the name of the resource to which the profile should be [un]assigned"
                     }
                  },
                  "required": [
                     "resource_type",
                     "resource_name"
                  ]
               },
               "manageiq_group": {
                  "type": "object",
                  "description": "The manageiq_group module supports adding, updating and deleting groups in ManageIQ.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nabsent - group should not exist, present - group should be.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "description": {
                        "type": "string",
                        "description": "The group description."
                     },
                     "role_id": {
                        "type": "string",
                        "description": "The the group role id"
                     },
                     "role": {
                        "type": "string",
                        "description": "The the group role name\nThe C(role_id) has precedence over the C(role) when supplied."
                     },
                     "tenant_id": {
                        "type": "string",
                        "description": "The tenant for the group identified by the tenant id."
                     },
                     "tenant": {
                        "type": "string",
                        "description": "The tenant for the group identified by the tenant name.\nThe C(tenant_id) has precedence over the C(tenant) when supplied.\nTenant names are case sensitive."
                     },
                     "managed_filters": {
                        "type": "object",
                        "description": "The tag values per category"
                     },
                     "managed_filters_merge_mode": {
                        "type": "string",
                        "description": "Default: replace\n\nIn merge mode existing categories are kept or updated, new categories are added.\nIn replace mode all categories will be replaced with the supplied C(managed_filters).",
                        "enum": [
                           "merge",
                           "replace"
                        ]
                     },
                     "belongsto_filters": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "A list of strings with a reference to the allowed host, cluster or folder"
                     },
                     "belongsto_filters_merge_mode": {
                        "type": "string",
                        "description": "Default: replace\n\nIn merge mode existing settings are merged with the supplied C(belongsto_filters).\nIn replace mode current values are replaced with the supplied C(belongsto_filters).",
                        "enum": [
                           "merge",
                           "replace"
                        ]
                     }
                  },
                  "required": [
                     "description"
                  ]
               },
               "manageiq_alerts": {
                  "type": "object",
                  "description": "The manageiq_alerts module supports adding, updating and deleting alerts in ManageIQ.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nabsent - alert should not exist,\npresent - alert should exist,",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "description": {
                        "type": "string",
                        "description": "The unique alert description in ManageIQ.\nRequired when state is \"absent\" or \"present\"."
                     },
                     "resource_type": {
                        "type": "string",
                        "description": "The entity type for the alert in ManageIQ. Required when state is \"present\".",
                        "enum": [
                           "Vm",
                           "ContainerNode",
                           "MiqServer",
                           "Host",
                           "Storage",
                           "EmsCluster",
                           "ExtManagementSystem",
                           "MiddlewareServer"
                        ]
                     },
                     "expression_type": {
                        "type": "string",
                        "description": "Default: hash\n\nExpression type.",
                        "enum": [
                           "hash",
                           "miq"
                        ]
                     },
                     "expression": {
                        "type": "string",
                        "description": "The alert expression for ManageIQ.\nCan either be in the \"Miq Expression\" format or the \"Hash Expression format\".\nRequired if state is \"present\"."
                     },
                     "enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Enable or disable the alert. Required if state is \"present\"."
                     },
                     "options": {
                        "type": "string",
                        "description": "Additional alert options, such as notification type and frequency"
                     }
                  }
               },
               "manageiq_alert_profiles": {
                  "type": "object",
                  "description": "The manageiq_alert_profiles module supports adding, updating and deleting alert profiles in ManageIQ.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nabsent - alert profile should not exist,\npresent - alert profile should exist,",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The unique alert profile name in ManageIQ.\nRequired when state is \"absent\" or \"present\"."
                     },
                     "resource_type": {
                        "type": "string",
                        "description": "The resource type for the alert profile in ManageIQ. Required when state is \"present\".",
                        "enum": [
                           "Vm",
                           "ContainerNode",
                           "MiqServer",
                           "Host",
                           "Storage",
                           "EmsCluster",
                           "ExtManagementSystem",
                           "MiddlewareServer"
                        ]
                     },
                     "alerts": {
                        "type": "array",
                        "description": "List of alert descriptions to assign to this profile.\nRequired if state is \"present\""
                     },
                     "notes": {
                        "type": "string",
                        "description": "Optional notes for this profile"
                     }
                  }
               },
               "lxca_nodes": {
                  "type": "object",
                  "description": "This module returns/displays a inventory details of nodes",
                  "properties": {
                     "uuid": {
                        "type": "string",
                        "description": "uuid of device, this is string with length greater than 16."
                     },
                     "command_options": {
                        "type": "string",
                        "description": "Default: nodes\n\noptions to filter nodes information",
                        "enum": [
                           "nodes",
                           "nodes_by_uuid",
                           "nodes_by_chassis_uuid",
                           "nodes_status_managed",
                           "nodes_status_unmanaged"
                        ]
                     },
                     "chassis": {
                        "type": "string",
                        "description": "uuid of chassis, this is string with length greater than 16."
                     }
                  }
               },
               "lxca_cmms": {
                  "type": "object",
                  "description": "This module returns/displays a inventory details of cmms",
                  "properties": {
                     "uuid": {
                        "type": "string",
                        "description": "uuid of device, this is string with length greater than 16."
                     },
                     "command_options": {
                        "type": "string",
                        "description": "Default: cmms\n\noptions to filter nodes information",
                        "enum": [
                           "cmms",
                           "cmms_by_uuid",
                           "cmms_by_chassis_uuid"
                        ]
                     },
                     "chassis": {
                        "type": "string",
                        "description": "uuid of chassis, this is string with length greater than 16."
                     }
                  }
               },
               "ipmi_power": {
                  "type": "object",
                  "description": "Use this module for power management",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Hostname or ip address of the BMC."
                     },
                     "port": {
                        "type": "string",
                        "description": "Default: 623\n\nRemote RMCP port."
                     },
                     "user": {
                        "type": "string",
                        "description": "Username to use to connect to the BMC."
                     },
                     "password": {
                        "type": "string",
                        "description": "Password to connect to the BMC."
                     },
                     "state": {
                        "type": "string",
                        "description": "Whether to ensure that the machine in desired state.\n\nPossible choices:\non -- Request system turn on\noff -- Request system turn off without waiting for OS to shutdown\nshutdown -- Have system request OS proper shutdown\nreset -- Request system reset without waiting for OS\nboot -- If system is off, then 'on', else 'reset'"
                     },
                     "timeout": {
                        "type": "string",
                        "description": "Default: 300\n\nMaximum number of seconds before interrupt request."
                     }
                  },
                  "required": [
                     "name",
                     "user",
                     "password",
                     "state"
                  ]
               },
               "ipmi_boot": {
                  "type": "object",
                  "description": "Use this module to manage order of boot devices",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Hostname or ip address of the BMC."
                     },
                     "port": {
                        "type": "string",
                        "description": "Default: 623\n\nRemote RMCP port."
                     },
                     "user": {
                        "type": "string",
                        "description": "Username to use to connect to the BMC."
                     },
                     "password": {
                        "type": "string",
                        "description": "Password to connect to the BMC."
                     },
                     "bootdev": {
                        "type": "string",
                        "description": "Set boot device to use on next reboot\n\nPossible choices:\nnetwork -- Request network boot\nfloppy -- Boot from floppy\nhd -- Boot from hard drive\nsafe -- Boot from hard drive, requesting 'safe mode'\noptical -- boot from CD/DVD/BD drive\nsetup -- Boot into setup utility\ndefault -- remove any IPMI directed boot device request"
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether to ensure that boot devices is desired.\n\nPossible choices:\npresent -- Request system turn on\nabsent -- Request system turn on"
                     },
                     "persistent": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nIf set, ask that system firmware uses this device beyond next boot. Be aware many systems do not honor this."
                     },
                     "uefiboot": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nIf set, request UEFI boot explicitly. Strictly speaking, the spec suggests that if not set, the system should BIOS boot and offers no \"don't care\" option. In practice, this flag not being set does not preclude UEFI boot on any system I've encountered."
                     }
                  },
                  "required": [
                     "name",
                     "user",
                     "password",
                     "bootdev"
                  ]
               },
               "intersight_rest_api": {
                  "type": "object",
                  "description": "Direct REST API configuration for Cisco Intersight.\nAll REST API resources and properties must be specified.\nFor more information see L(Cisco Intersight,https://intersight.com/apidocs).",
                  "properties": {
                     "resource_path": {
                        "type": "string",
                        "description": "Resource URI being configured related to api_uri."
                     },
                     "query_params": {
                        "type": "object",
                        "description": "Query parameters for the Intersight API query language."
                     },
                     "update_method": {
                        "type": "string",
                        "description": "Default: patch\n\nThe HTTP method used for update operations.\nSome Intersight resources require POST operations for modifications.",
                        "enum": [
                           "patch",
                           "post"
                        ]
                     },
                     "api_body": {
                        "type": "object",
                        "description": "The payload for API requests used to modify resources."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIf C(present), will verify the resource is present and will create if needed.\nIf C(absent), will verify the resource is absent and will delete if needed.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     }
                  },
                  "required": [
                     "resource_path"
                  ]
               },
               "intersight_info": {
                  "type": "object",
                  "description": "Gathers information about servers in L(Cisco Intersight,https://intersight.com).\nThis module was called C(intersight_facts) before Ansible 2.9. The usage did not change.",
                  "properties": {
                     "server_names": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Server names to retrieve information from.\nAn empty list will return all servers."
                     }
                  },
                  "required": [
                     "server_names"
                  ]
               },
               "imc_rest": {
                  "type": "object",
                  "description": "Provides direct access to the Cisco IMC REST API.\nPerform any configuration changes and actions that the Cisco IMC supports.\nMore information about the IMC REST API is available from U(http://www.cisco.com/c/en/us/td/docs/unified_computing/ucs/c/sw/api/3_0/b_Cisco_IMC_api_301.html)",
                  "properties": {
                     "hostname": {
                        "type": "string",
                        "description": "IP Address or hostname of Cisco IMC, resolvable by Ansible control host."
                     },
                     "host": {
                        "type": "string",
                        "description": "IP Address or hostname of Cisco IMC, resolvable by Ansible control host."
                     },
                     "ip": {
                        "type": "string",
                        "description": "IP Address or hostname of Cisco IMC, resolvable by Ansible control host."
                     },
                     "username": {
                        "type": "string",
                        "description": "Default: admin\n\nUsername used to login to the switch."
                     },
                     "user": {
                        "type": "string",
                        "description": "Default: admin\n\nUsername used to login to the switch."
                     },
                     "password": {
                        "type": "string",
                        "description": "Default: password\n\nThe password to use for authentication."
                     },
                     "path": {
                        "type": "string",
                        "description": "Name of the absolute path of the filename that includes the body of the http request being sent to the Cisco IMC REST API.\nParameter C(path) is mutual exclusive with parameter C(content)."
                     },
                     "src": {
                        "type": "string",
                        "description": "Name of the absolute path of the filename that includes the body of the http request being sent to the Cisco IMC REST API.\nParameter C(path) is mutual exclusive with parameter C(content)."
                     },
                     "config_file": {
                        "type": "string",
                        "description": "Name of the absolute path of the filename that includes the body of the http request being sent to the Cisco IMC REST API.\nParameter C(path) is mutual exclusive with parameter C(content)."
                     },
                     "content": {
                        "type": "string",
                        "description": "When used instead of C(path), sets the content of the API requests directly.\nThis may be convenient to template simple requests, for anything complex use the M(template) module.\nYou can collate multiple IMC XML fragments and they will be processed sequentially in a single stream, the Cisco IMC output is subsequently merged.\nParameter C(content) is mutual exclusive with parameter C(path)."
                     },
                     "protocol": {
                        "type": "string",
                        "description": "Default: https\n\nConnection protocol to use.",
                        "enum": [
                           "http",
                           "https"
                        ]
                     },
                     "timeout": {
                        "type": "string",
                        "description": "Default: 60\n\nThe socket level timeout in seconds.\nThis is the time that every single connection (every fragment) can spend. If this C(timeout) is reached, the module will fail with a C(Connection failure) indicating that C(The read operation timed out)."
                     },
                     "validate_certs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nIf C(no), SSL certificates will not be validated.\nThis should only set to C(no) used on personally controlled sites using self-signed certificates."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "hostname",
                                    "host",
                                    "ip"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "hostname"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "host"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "ip"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "username",
                                    "user"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "path",
                                    "src",
                                    "config_file"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "hponcfg": {
                  "type": "object",
                  "description": "This modules configures the HP iLO interface using hponcfg.",
                  "properties": {
                     "path": {
                        "type": "string",
                        "description": "The XML file as accepted by hponcfg."
                     },
                     "src": {
                        "type": "string",
                        "description": "The XML file as accepted by hponcfg."
                     },
                     "minfw": {
                        "type": "string",
                        "description": "The minimum firmware level needed."
                     },
                     "executable": {
                        "type": "string",
                        "description": "Default: hponcfg\n\nPath to the hponcfg executable (`hponcfg` which uses $PATH)."
                     },
                     "verbose": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Run hponcfg in verbose mode (-v)."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "path",
                                    "src"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "path"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "src"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "hpilo_info": {
                  "type": "object",
                  "description": "This module gathers information on a specific system using its HP iLO interface. These information includes hardware and network related information useful for provisioning (e.g. macaddress, uuid).\nThis module requires the C(hpilo) python module.\nThis module was called C(hpilo_facts) before Ansible 2.9, returning C(ansible_facts). Note that the M(hpilo_info) module no longer returns C(ansible_facts)!",
                  "properties": {
                     "host": {
                        "type": "string",
                        "description": "The HP iLO hostname/address that is linked to the physical system."
                     },
                     "login": {
                        "type": "string",
                        "description": "Default: Administrator\n\nThe login name to authenticate to the HP iLO interface."
                     },
                     "password": {
                        "type": "string",
                        "description": "Default: admin\n\nThe password to authenticate to the HP iLO interface."
                     },
                     "ssl_version": {
                        "type": "string",
                        "description": "Default: TLSv1\n\nChange the ssl_version used.",
                        "enum": [
                           "SSLv3",
                           "SSLv23",
                           "TLSv1",
                           "TLSv1_1",
                           "TLSv1_2"
                        ]
                     }
                  },
                  "required": [
                     "host"
                  ]
               },
               "hpilo_boot": {
                  "type": "object",
                  "description": "This module boots a system through its HP iLO interface. The boot media can be one of: cdrom, floppy, hdd, network or usb.\nThis module requires the hpilo python module.",
                  "properties": {
                     "host": {
                        "type": "string",
                        "description": "The HP iLO hostname/address that is linked to the physical system."
                     },
                     "login": {
                        "type": "string",
                        "description": "Default: Administrator\n\nThe login name to authenticate to the HP iLO interface."
                     },
                     "password": {
                        "type": "string",
                        "description": "Default: admin\n\nThe password to authenticate to the HP iLO interface."
                     },
                     "media": {
                        "type": "string",
                        "description": "The boot media to boot the system from",
                        "enum": [
                           "cdrom",
                           "floppy",
                           "hdd",
                           "network",
                           "normal",
                           "usb"
                        ]
                     },
                     "image": {
                        "type": "string",
                        "description": "The URL of a cdrom, floppy or usb boot media image. protocol://username:password@hostname:port/filename\nprotocol is either 'http' or 'https'\nusername:password is optional\nport is optional"
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: boot_once\n\nThe state of the boot media.\nno_boot: Do not boot from the device\nboot_once: Boot from the device once and then notthereafter\nboot_always: Boot from the device each time the server is rebooted\nconnect: Connect the virtual media device and set to boot_always\ndisconnect: Disconnects the virtual media device and set to no_boot\npoweroff: Power off the server",
                        "enum": [
                           "boot_always",
                           "boot_once",
                           "connect",
                           "disconnect",
                           "no_boot",
                           "poweroff"
                        ]
                     },
                     "force": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether to force a reboot (even when the system is already booted).\nAs a safeguard, without force, hpilo_boot will refuse to reboot a server that is already running."
                     },
                     "ssl_version": {
                        "type": "string",
                        "description": "Default: TLSv1\n\nChange the ssl_version used.",
                        "enum": [
                           "SSLv3",
                           "SSLv23",
                           "TLSv1",
                           "TLSv1_1",
                           "TLSv1_2"
                        ]
                     }
                  },
                  "required": [
                     "host"
                  ]
               },
               "katello": {
                  "type": "object",
                  "description": "Allows the management of Katello resources inside your Foreman server.",
                  "properties": {
                     "server_url": {
                        "type": "string",
                        "description": "URL of Foreman server."
                     },
                     "username": {
                        "type": "string",
                        "description": "Username on Foreman server."
                     },
                     "password": {
                        "type": "string",
                        "description": "Password for user accessing Foreman server."
                     },
                     "entity": {
                        "type": "string",
                        "description": "The Foreman resource that the action will be performed on (e.g. organization, host).",
                        "enum": [
                           "repository",
                           "manifest",
                           "repository_set",
                           "sync_plan",
                           "content_view",
                           "lifecycle_environment",
                           "activation_key",
                           "product"
                        ]
                     },
                     "action": {
                        "type": "string",
                        "description": "action associated to the entity resource to set or edit in dictionary format.\nPossible Action in relation to Entitys.\nsync (available when entity=product or entity=repository)\npublish (available when entity=content_view)\npromote (available when entity=content_view)",
                        "enum": [
                           "sync",
                           "publish",
                           "promote"
                        ]
                     },
                     "params": {
                        "type": "string",
                        "description": "Parameters associated to the entity resource and action, to set or edit in dictionary format.\nEach choice may be only available with specific entitys and actions.\nPossible Choices are in the format of param_name ([entry,action,action,...],[entity,..],...).\nThe action \"None\" means no action specified.\nPossible Params in relation to entity and action.\nname ([product,sync,None], [repository,sync], [repository_set,None], [sync_plan,None],\n[content_view,promote,publish,None], [lifecycle_environment,None], [activation_key,None])\norganization ([product,sync,None] ,[repository,sync,None], [repository_set,None], [sync_plan,None], \n[content_view,promote,publish,None], [lifecycle_environment,None], [activation_key,None])\ncontent ([manifest,None])\nproduct ([repository,sync,None], [repository_set,None], [sync_plan,None])\nbasearch ([repository_set,None])\nreleaserver ([repository_set,None])\nsync_date ([sync_plan,None])\ninterval ([sync_plan,None])\nrepositories ([content_view,None])\nfrom_environment ([content_view,promote])\nto_environment([content_view,promote])\nprior ([lifecycle_environment,None])\ncontent_view ([activation_key,None])\nlifecycle_environment ([activation_key,None])"
                     },
                     "task_timeout": {
                        "type": "string",
                        "description": "Default: 1000\n\nThe timeout in seconds to wait for the started Foreman action to finish.\nIf the timeout is reached and the Foreman action did not complete, the ansible task fails. However the foreman action does not get canceled."
                     },
                     "verify_ssl": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "verify the ssl/https connection (e.g for a valid certificate)"
                     }
                  },
                  "required": [
                     "server_url",
                     "username",
                     "password",
                     "entity",
                     "params"
                  ]
               },
               "foreman": {
                  "type": "object",
                  "description": "Allows the management of Foreman resources inside your Foreman server.",
                  "properties": {
                     "server_url": {
                        "type": "string",
                        "description": "URL of Foreman server."
                     },
                     "username": {
                        "type": "string",
                        "description": "Username on Foreman server."
                     },
                     "verify_ssl": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether to verify an SSL connection to Foreman server."
                     },
                     "password": {
                        "type": "string",
                        "description": "Password for user accessing Foreman server."
                     },
                     "entity": {
                        "type": "string",
                        "description": "The Foreman resource that the action will be performed on (e.g. organization, host)."
                     },
                     "params": {
                        "type": "string",
                        "description": "Parameters associated to the entity resource to set or edit in dictionary format (e.g. name, description)."
                     }
                  },
                  "required": [
                     "server_url",
                     "username",
                     "password",
                     "entity",
                     "params"
                  ]
               },
               "ome_device_info": {
                  "type": "object",
                  "description": "This module retrieves the list of all devices information with the exhaustive inventory of each device.",
                  "properties": {
                     "hostname": {
                        "type": "string",
                        "description": "Target IP Address or hostname."
                     },
                     "username": {
                        "type": "string",
                        "description": "Target username."
                     },
                     "password": {
                        "type": "string",
                        "description": "Target user password."
                     },
                     "port": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 443\n\nTarget HTTPS port."
                     },
                     "fact_subset": {
                        "type": "string",
                        "description": "Default: basic_inventory\n\nC(basic_inventory) returns the list of the devices.\nC(detailed_inventory) returns the inventory details of specified devices.\nC(subsystem_health) returns the health status of specified devices.",
                        "enum": [
                           "basic_inventory",
                           "detailed_inventory",
                           "subsystem_health"
                        ]
                     },
                     "system_query_options": {
                        "type": "object",
                        "description": "I(system_query_options) applicable for the choices of the fact_subset. Either I(device_id) or I(device_service_tag) is mandatory for C(detailed_inventory) and C(subsystem_health) or both can be applicable."
                     }
                  },
                  "required": [
                     "hostname",
                     "username",
                     "password"
                  ]
               },
               "idrac_server_config_profile": {
                  "type": "object",
                  "description": "Export the Server Configuration Profile (SCP) from the iDRAC or Import from a network share or a local file.",
                  "properties": {
                     "idrac_ip": {
                        "type": "string",
                        "description": "iDRAC IP Address."
                     },
                     "idrac_user": {
                        "type": "string",
                        "description": "iDRAC username."
                     },
                     "idrac_password": {
                        "type": "string",
                        "description": "iDRAC user password."
                     },
                     "idrac_pwd": {
                        "type": "string",
                        "description": "iDRAC user password."
                     },
                     "idrac_port": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 443\n\niDRAC port."
                     },
                     "command": {
                        "type": "string",
                        "description": "Default: export\n\nIf C(import), will perform SCP import operations.\nIf C(export), will perform SCP export operations.",
                        "enum": [
                           "import",
                           "export"
                        ]
                     },
                     "job_wait": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether to wait for job completion or not."
                     },
                     "share_name": {
                        "type": "string",
                        "description": "CIFS or NFS Network Share or a local path."
                     },
                     "share_user": {
                        "type": "string",
                        "description": "Network share user in the format 'user@domain' or 'domain\\\\user' if user is part of a domain else 'user'. This option is mandatory for CIFS Network Share."
                     },
                     "share_password": {
                        "type": "string",
                        "description": "Network share user password. This option is mandatory for CIFS Network Share."
                     },
                     "share_pwd": {
                        "type": "string",
                        "description": "Network share user password. This option is mandatory for CIFS Network Share."
                     },
                     "scp_file": {
                        "type": "string",
                        "description": "Server Configuration Profile file name. This option is mandatory for C(import) command."
                     },
                     "scp_components": {
                        "type": "string",
                        "description": "Default: ALL\n\nIf C(ALL), this module will import all components configurations from SCP file.\nIf C(IDRAC), this module will import iDRAC configuration from SCP file.\nIf C(BIOS), this module will import BIOS configuration from SCP file.\nIf C(NIC), this module will import NIC configuration from SCP file.\nIf C(RAID), this module will import RAID configuration from SCP file.",
                        "enum": [
                           "ALL",
                           "IDRAC",
                           "BIOS",
                           "NIC",
                           "RAID"
                        ]
                     },
                     "shutdown_type": {
                        "type": "string",
                        "description": "Default: Graceful\n\nThis option is applicable for C(import) command.\nIf C(Graceful), it gracefully shuts down the server.\nIf C(Forced),  it forcefully shuts down the server.\nIf C(NoReboot), it does not reboot the server.",
                        "enum": [
                           "Graceful",
                           "Forced",
                           "NoReboot"
                        ]
                     },
                     "end_host_power_state": {
                        "type": "string",
                        "description": "Default: On\n\nThis option is applicable for C(import) command.\nIf C(On), End host power state is on.\nIf C(Off), End host power state is off.",
                        "enum": [
                           "On",
                           "Off"
                        ]
                     },
                     "export_format": {
                        "type": "string",
                        "description": "Default: XML\n\nSpecify the output file format. This option is applicable for C(export) command.",
                        "enum": [
                           "JSON",
                           "XML"
                        ]
                     },
                     "export_use": {
                        "type": "string",
                        "description": "Default: Default\n\nSpecify the type of server configuration profile (SCP) to be exported. This option is applicable for C(export) command.",
                        "enum": [
                           "Default",
                           "Clone",
                           "Replace"
                        ]
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "idrac_password",
                                    "idrac_pwd"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "idrac_password"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "idrac_pwd"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "share_password",
                                    "share_pwd"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "idrac_firmware": {
                  "type": "object",
                  "description": "Update the Firmware by connecting to a network share (either CIFS or NFS) that contains a catalog of available updates.\nNetwork share should contain a valid repository of Update Packages (DUPs) and a catalog file describing the DUPs.\nAll applicable updates contained in the repository are applied to the system.\nThis feature is available only with iDRAC Enterprise License.",
                  "properties": {
                     "idrac_ip": {
                        "type": "string",
                        "description": "iDRAC IP Address."
                     },
                     "idrac_user": {
                        "type": "string",
                        "description": "iDRAC username."
                     },
                     "idrac_password": {
                        "type": "string",
                        "description": "iDRAC user password."
                     },
                     "idrac_pwd": {
                        "type": "string",
                        "description": "iDRAC user password."
                     },
                     "idrac_port": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 443\n\niDRAC port."
                     },
                     "share_name": {
                        "type": "string",
                        "description": "CIFS or NFS Network share."
                     },
                     "share_user": {
                        "type": "string",
                        "description": "Network share user in the format 'user@domain' or 'domain\\\\user' if user is part of a domain else 'user'. This option is mandatory for CIFS Network Share."
                     },
                     "share_password": {
                        "type": "string",
                        "description": "Network share user password. This option is mandatory for CIFS Network Share."
                     },
                     "share_pwd": {
                        "type": "string",
                        "description": "Network share user password. This option is mandatory for CIFS Network Share."
                     },
                     "share_mnt": {
                        "type": "string",
                        "description": "Local mount path of the network share with read-write permission for ansible user. This option is mandatory for Network Share."
                     },
                     "reboot": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether to reboots after applying the updates or not."
                     },
                     "job_wait": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nWhether to wait for job completion or not."
                     },
                     "catalog_file_name": {
                        "type": "string",
                        "description": "Default: Catalog.xml\n\nCatalog file name relative to the I(share_name)."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "idrac_password",
                                    "idrac_pwd"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "idrac_password"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "idrac_pwd"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "share_password",
                                    "share_pwd"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "cpm_user": {
                  "type": "object",
                  "description": "Get/Add/Edit Delete Users from WTI OOB and PDU devices",
                  "properties": {
                     "cpm_action": {
                        "type": "string",
                        "description": "This is the Action to send the module.",
                        "enum": [
                           "getuser",
                           "adduser",
                           "edituser",
                           "deleteuser"
                        ]
                     },
                     "cpm_url": {
                        "type": "string",
                        "description": "This is the URL of the WTI device to send the module."
                     },
                     "cpm_username": {
                        "type": "string",
                        "description": "This is the Basic Authentication Username of the WTI device to send the module."
                     },
                     "cpm_password": {
                        "type": "string",
                        "description": "This is the Basic Authentication Password of the WTI device to send the module."
                     },
                     "use_https": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nDesignates to use an https connection or http connection."
                     },
                     "validate_certs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nIf false, SSL certificates will not be validated. This should only be used\non personally controlled sites using self-signed certificates."
                     },
                     "use_proxy": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Flag to control if the lookup will observe HTTP proxy environment variables when present."
                     },
                     "user_name": {
                        "type": "string",
                        "description": "This is the User Name that needs to be create/modified/deleted"
                     },
                     "user_pass": {
                        "type": "string",
                        "description": "This is the User Password that needs to be create/modified/deleted\nIf the user is being Created this parameter is required"
                     },
                     "user_accesslevel": {
                        "type": "string",
                        "description": "This is the access level that needs to be create/modified/deleted\n0 View, 1 User, 2 SuperUser, 3 Administrator",
                        "enum": [
                           0,
                           1,
                           2,
                           3
                        ]
                     },
                     "user_accessssh": {
                        "type": "string",
                        "description": "If the user has access to the WTI device via SSH\n0 No , 1 Yes",
                        "enum": [
                           0,
                           1
                        ]
                     },
                     "user_accessserial": {
                        "type": "string",
                        "description": "If the user has access to the WTI device via Serial ports\n0 No , 1 Yes",
                        "enum": [
                           0,
                           1
                        ]
                     },
                     "user_accessweb": {
                        "type": "string",
                        "description": "If the user has access to the WTI device via Web\n0 No , 1 Yes",
                        "enum": [
                           0,
                           1
                        ]
                     },
                     "user_accessapi": {
                        "type": "string",
                        "description": "If the user has access to the WTI device via RESTful APIs\n0 No , 1 Yes",
                        "enum": [
                           0,
                           1
                        ]
                     },
                     "user_accessmonitor": {
                        "type": "string",
                        "description": "If the user has ability to monitor connection sessions\n0 No , 1 Yes",
                        "enum": [
                           0,
                           1
                        ]
                     },
                     "user_accessoutbound": {
                        "type": "string",
                        "description": "If the user has ability to initiate Outbound connection\n0 No , 1 Yes",
                        "enum": [
                           0,
                           1
                        ]
                     },
                     "user_portaccess": {
                        "type": "string",
                        "description": "If AccessLevel is lower than Administrator, which ports the user has access"
                     },
                     "user_plugaccess": {
                        "type": "string",
                        "description": "If AccessLevel is lower than Administrator, which plugs the user has access"
                     },
                     "user_groupaccess": {
                        "type": "string",
                        "description": "If AccessLevel is lower than Administrator, which Groups the user has access"
                     },
                     "user_callbackphone": {
                        "type": "string",
                        "description": "This is the Call Back phone number used for POTS modem connections"
                     }
                  },
                  "required": [
                     "cpm_action",
                     "cpm_url",
                     "cpm_username",
                     "cpm_password",
                     "user_name"
                  ]
               },
               "cpm_serial_port_info": {
                  "type": "object",
                  "description": "Get Serial port parameters from WTI OOB and PDU devices",
                  "properties": {
                     "cpm_url": {
                        "type": "string",
                        "description": "This is the URL of the WTI device to send the module."
                     },
                     "cpm_username": {
                        "type": "string",
                        "description": "This is the Username of the WTI device to send the module."
                     },
                     "cpm_password": {
                        "type": "string",
                        "description": "This is the Password of the WTI device to send the module."
                     },
                     "use_https": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nDesignates to use an https connection or http connection."
                     },
                     "validate_certs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nIf false, SSL certificates will not be validated. This should only be used\non personally controlled sites using self-signed certificates."
                     },
                     "use_proxy": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Flag to control if the lookup will observe HTTP proxy environment variables when present."
                     },
                     "port": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Default: ['*']\n\nThis is the serial port number that is getting retrieved. It can include a single port number, multiple port numbers separated by commas, a list of port numbers, or an '*' character for all ports."
                     }
                  },
                  "required": [
                     "cpm_url",
                     "cpm_username",
                     "cpm_password",
                     "port"
                  ]
               },
               "cpm_serial_port_config": {
                  "type": "object",
                  "description": "Set Serial port parameters in WTI OOB and PDU devices",
                  "properties": {
                     "cpm_url": {
                        "type": "string",
                        "description": "This is the URL of the WTI device to send the module."
                     },
                     "cpm_username": {
                        "type": "string",
                        "description": "This is the Username of the WTI device to send the module."
                     },
                     "cpm_password": {
                        "type": "string",
                        "description": "This is the Password of the WTI device to send the module."
                     },
                     "use_https": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nDesignates to use an https connection or http connection."
                     },
                     "validate_certs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nIf false, SSL certificates will not be validated. This should only be used\non personally controlled sites using self-signed certificates."
                     },
                     "use_proxy": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Flag to control if the lookup will observe HTTP proxy environment variables when present."
                     },
                     "port": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "This is the port number that is getting the action performed on."
                     },
                     "portname": {
                        "type": "string",
                        "description": "This is the Name of the Port that is displayed."
                     },
                     "baud": {
                        "type": "string",
                        "description": "This is the baud rate to assign to the port.\n0=300, 1=1200, 2=2400, 3=4800, 4=9600, 5=19200, 6=38400, 7=57600, 8=115200, 9=230400, 10=460800",
                        "enum": [
                           0,
                           1,
                           2,
                           3,
                           4,
                           5,
                           6,
                           7,
                           8,
                           9,
                           10
                        ]
                     },
                     "handshake": {
                        "type": "string",
                        "description": "This is the handshake to assign to the port, 0=None, 1=XON/XOFF, 2=RTS/CTS, 3=Both.",
                        "enum": [
                           0,
                           1,
                           2,
                           3
                        ]
                     },
                     "stopbits": {
                        "type": "string",
                        "description": "This is the stop bits to assign to the port, 0=1 Stop Bit, 1=2 Stop Bit.",
                        "enum": [
                           0,
                           1
                        ]
                     },
                     "parity": {
                        "type": "string",
                        "description": "This is the parity to assign to the port, 0=7-None, 1=7-Even, 2=7-Odd, 3=8-None, 4=8-Even, 5=8-Odd.",
                        "enum": [
                           0,
                           1,
                           2,
                           3,
                           4,
                           5
                        ]
                     },
                     "mode": {
                        "type": "string",
                        "description": "This is the port mode to assign to the port, 0=Any-to-Any. 1=Passive, 2=Buffer, 3=Modem, 4=ModemPPP.",
                        "enum": [
                           0,
                           1,
                           2,
                           3,
                           4
                        ]
                     },
                     "cmd": {
                        "type": "string",
                        "description": "This is the Admin Mode to assign to the port, 0=Deny, 1=Permit.",
                        "enum": [
                           0,
                           1
                        ]
                     },
                     "seq": {
                        "type": "string",
                        "description": "This is the type of Sequence Disconnect to assign to the port, 0=Three Characters (before and after), 1=One Character Only, 2=Off",
                        "enum": [
                           1,
                           2,
                           3
                        ]
                     },
                     "tout": {
                        "type": "string",
                        "description": "This is the Port Activity Timeout to assign to the port, 0=Off, 1=5 Min, 2=15 Min, 3=30 Min, 4=90 Min, 5=1 Min.",
                        "enum": [
                           0,
                           1,
                           2,
                           3,
                           4,
                           5
                        ]
                     },
                     "echo": {
                        "type": "string",
                        "description": "-This is the command echo parameter to assign to the port, 0=Off, 1=On"
                     },
                     "break_allow": {
                        "type": "string",
                        "description": "This is if the break character is allowed to be passed through the port, 0=Off, 1=On"
                     },
                     "logoff": {
                        "type": "string",
                        "description": "This is the logout character to assign to the port\nIf preceded by a ^ character, the sequence will be a control character. Used if seq is set to 0 or 1"
                     }
                  },
                  "required": [
                     "cpm_url",
                     "cpm_username",
                     "cpm_password",
                     "port"
                  ]
               },
               "cpm_plugcontrol": {
                  "type": "object",
                  "description": "Get and Set Plug actions on WTI OOB and PDU devices",
                  "properties": {
                     "cpm_action": {
                        "type": "string",
                        "description": "This is the Action to send the module.",
                        "enum": [
                           "getplugcontrol",
                           "setplugcontrol"
                        ]
                     },
                     "cpm_url": {
                        "type": "string",
                        "description": "This is the URL of the WTI device  to send the module."
                     },
                     "cpm_username": {
                        "type": "string",
                        "description": "This is the Username of the WTI device to send the module."
                     },
                     "cpm_password": {
                        "type": "string",
                        "description": "This is the Password of the WTI device to send the module."
                     },
                     "use_https": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nDesignates to use an https connection or http connection."
                     },
                     "validate_certs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nIf false, SSL certificates will not be validated. This should only be used\non personally controlled sites using self-signed certificates."
                     },
                     "use_proxy": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Flag to control if the lookup will observe HTTP proxy environment variables when present."
                     },
                     "plug_id": {
                        "type": "string",
                        "description": "This is the plug number or the plug name that is to be manipulated For the plugget command, the plug_id 'all' will return the status of all the plugs the user has rights to access."
                     },
                     "plug_state": {
                        "type": "string",
                        "description": "This is what action to take on the plug.",
                        "enum": [
                           "on",
                           "off",
                           "boot",
                           "default"
                        ]
                     }
                  },
                  "required": [
                     "cpm_action",
                     "cpm_url",
                     "plug_id"
                  ]
               },
               "cpm_plugconfig": {
                  "type": "object",
                  "description": "Get and Set Plug Parameters on WTI OOB and PDU devices",
                  "properties": {
                     "cpm_action": {
                        "type": "string",
                        "description": "This is the Action to send the module.",
                        "enum": [
                           "getplugconfig",
                           "setplugconfig"
                        ]
                     },
                     "cpm_url": {
                        "type": "string",
                        "description": "This is the URL of the WTI device to send the module."
                     },
                     "cpm_username": {
                        "type": "string",
                        "description": "This is the Username of the WTI device to send the module."
                     },
                     "cpm_password": {
                        "type": "string",
                        "description": "This is the Password of the WTI device to send the module."
                     },
                     "use_https": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nDesignates to use an https connection or http connection."
                     },
                     "validate_certs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nIf false, SSL certificates will not be validated. This should only be used\non personally controlled sites using self-signed certificates."
                     },
                     "use_proxy": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Flag to control if the lookup will observe HTTP proxy environment variables when present."
                     },
                     "plug_id": {
                        "type": "string",
                        "description": "This is the plug number that is to be manipulated For the getplugconfig command, the plug_id 'all' will return the status of all the plugs the user has rights to access."
                     },
                     "plug_name": {
                        "type": "string",
                        "description": "The new name of the Plug."
                     },
                     "plug_bootdelay": {
                        "type": "string",
                        "description": "On a reboot command, this is the time when a plug will turn on power, after it has been turned off. 0='0.5 Secs', 1='1 Sec', 2='2 Sec', 3='5 Sec', 4='15 Sec', 5='30 Sec', 6='1 Min', 7='2 Mins', 8='3 Mins', 9='5 Mins'.",
                        "enum": [
                           0,
                           1,
                           2,
                           3,
                           4,
                           5,
                           6,
                           7,
                           8,
                           9
                        ]
                     },
                     "plug_default": {
                        "type": "string",
                        "description": "What the Plugs default state is when the device starts. 0 - Off, 1 - On.",
                        "enum": [
                           0,
                           1
                        ]
                     },
                     "plug_bootpriority": {
                        "type": "string",
                        "description": "Prioritizes which plug gets its state changed first. The lower the number the higher the priority. Valid value can from 1 to the maximum number of plugs of the WTI unit."
                     }
                  },
                  "required": [
                     "cpm_action",
                     "cpm_url",
                     "plug_id"
                  ]
               },
               "cobbler_system": {
                  "type": "object",
                  "description": "Add, modify or remove systems in Cobbler",
                  "properties": {
                     "host": {
                        "type": "string",
                        "description": "Default: 127.0.0.1\n\nThe name or IP address of the Cobbler system."
                     },
                     "port": {
                        "type": "string",
                        "description": "Port number to be used for REST connection.\nThe default value depends on parameter C(use_ssl)."
                     },
                     "username": {
                        "type": "string",
                        "description": "Default: cobbler\n\nThe username to log in to Cobbler."
                     },
                     "password": {
                        "type": "string",
                        "description": "The password to log in to Cobbler."
                     },
                     "use_ssl": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nIf C(no), an HTTP connection will be used instead of the default HTTPS connection."
                     },
                     "validate_certs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nIf C(no), SSL certificates will not be validated.\nThis should only set to C(no) when used on personally controlled sites using self-signed certificates."
                     },
                     "name": {
                        "type": "string",
                        "description": "The system name to manage."
                     },
                     "properties": {
                        "type": "object",
                        "description": "A dictionary with system properties."
                     },
                     "interfaces": {
                        "type": "string",
                        "description": "A list of dictionaries containing interface options."
                     },
                     "sync": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Sync on changes.\nConcurrently syncing Cobbler is bound to fail."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the system should be present, absent or a query is made.",
                        "enum": [
                           "absent",
                           "present",
                           "query"
                        ]
                     }
                  },
                  "required": [
                     "password"
                  ]
               },
               "cobbler_sync": {
                  "type": "object",
                  "description": "Sync Cobbler to commit changes.",
                  "properties": {
                     "host": {
                        "type": "string",
                        "description": "Default: 127.0.0.1\n\nThe name or IP address of the Cobbler system."
                     },
                     "port": {
                        "type": "string",
                        "description": "Port number to be used for REST connection.\nThe default value depends on parameter C(use_ssl)."
                     },
                     "username": {
                        "type": "string",
                        "description": "Default: cobbler\n\nThe username to log in to Cobbler."
                     },
                     "password": {
                        "type": "string",
                        "description": "The password to log in to Cobbler."
                     },
                     "use_ssl": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nIf C(no), an HTTP connection will be used instead of the default HTTPS connection."
                     },
                     "validate_certs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nIf C(no), SSL certificates will not be validated.\nThis should only set to C(no) when used on personally controlled sites using self-signed certificates."
                     }
                  },
                  "required": [
                     "password"
                  ]
               },
               "zypper_repository": {
                  "type": "object",
                  "description": "Add or remove Zypper repositories on SUSE and openSUSE",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "A name for the repository. Not required when adding repofiles."
                     },
                     "repo": {
                        "type": "string",
                        "description": "URI of the repository or .repo file. Required when state=present."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nA source string state.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "description": {
                        "type": "string",
                        "description": "A description of the repository"
                     },
                     "disable_gpg_check": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nWhether to disable GPG signature checking of all packages. Has an effect only if state is I(present).\nNeeds zypper version >= 1.6.2."
                     },
                     "autorefresh": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nEnable autorefresh of the repository."
                     },
                     "refresh": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nEnable autorefresh of the repository."
                     },
                     "priority": {
                        "type": "string",
                        "description": "Set priority of repository. Packages will always be installed from the repository with the smallest priority number.\nNeeds zypper version >= 1.12.25."
                     },
                     "overwrite_multiple": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nOverwrite multiple repository entries, if repositories with both name and URL already exist."
                     },
                     "auto_import_keys": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nAutomatically import the gpg signing key of the new or changed repository.\nHas an effect only if state is I(present). Has no effect on existing (unchanged) repositories or in combination with I(absent).\nImplies runrefresh.\nOnly works with C(.repo) files if `name` is given explicitly."
                     },
                     "runrefresh": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nRefresh the package list of the given repository.\nCan be used with repo=* to refresh all repositories."
                     },
                     "enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nSet repository to enabled (or disabled)."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "autorefresh",
                                    "refresh"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "zypper": {
                  "type": "object",
                  "description": "Manage packages on SUSE and openSUSE using the zypper and rpm tools.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Package name C(name) or package specifier or a list of either.\nCan include a version like C(name=1.0), C(name>3.4) or C(name<=2.7). If a version is given, C(oldpackage) is implied and zypper is allowed to update the package within the version range given.\nYou can also pass a url or a local path to a rpm file.\nWhen using state=latest, this can be '*', which updates all installed packages."
                     },
                     "pkg": {
                        "type": "string",
                        "description": "Package name C(name) or package specifier or a list of either.\nCan include a version like C(name=1.0), C(name>3.4) or C(name<=2.7). If a version is given, C(oldpackage) is implied and zypper is allowed to update the package within the version range given.\nYou can also pass a url or a local path to a rpm file.\nWhen using state=latest, this can be '*', which updates all installed packages."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nC(present) will make sure the package is installed. C(latest)  will make sure the latest version of the package is installed. C(absent)  will make sure the specified package is not installed. C(dist-upgrade) will make sure the latest version of all installed packages from all enabled repositories is installed.\nWhen using C(dist-upgrade), I(name) should be C('*').",
                        "enum": [
                           "present",
                           "latest",
                           "absent",
                           "dist-upgrade"
                        ]
                     },
                     "type": {
                        "type": "string",
                        "description": "Default: package\n\nThe type of package to be operated on.",
                        "enum": [
                           "package",
                           "patch",
                           "pattern",
                           "product",
                           "srcpackage",
                           "application"
                        ]
                     },
                     "extra_args_precommand": {
                        "type": "string",
                        "description": "Add additional global target options to C(zypper).\nOptions should be supplied in a single line as if given in the command line."
                     },
                     "disable_gpg_check": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nWhether to disable to GPG signature checking of the package signature being installed. Has an effect only if state is I(present) or I(latest)."
                     },
                     "disable_recommends": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nCorresponds to the C(--no-recommends) option for I(zypper). Default behavior (C(yes)) modifies zypper's default behavior; C(no) does install recommended packages."
                     },
                     "force": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nAdds C(--force) option to I(zypper). Allows to downgrade packages and change vendor or architecture."
                     },
                     "update_cache": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nRun the equivalent of C(zypper refresh) before the operation. Disabled in check mode."
                     },
                     "refresh": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nRun the equivalent of C(zypper refresh) before the operation. Disabled in check mode."
                     },
                     "oldpackage": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nAdds C(--oldpackage) option to I(zypper). Allows to downgrade packages with less side-effects than force. This is implied as soon as a version is specified as part of the package name."
                     },
                     "extra_args": {
                        "type": "string",
                        "description": "Add additional options to C(zypper) command.\nOptions should be supplied in a single line as if given in the command line."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "pkg"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "pkg"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "update_cache",
                                    "refresh"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "yum_repository": {
                  "type": "object",
                  "description": "Add or remove YUM repositories in RPM-based Linux distributions.\nIf you wish to update an existing repository definition use M(ini_file) instead.",
                  "properties": {
                     "async": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nIf set to C(yes) Yum will download packages and metadata from this repo in parallel, if possible."
                     },
                     "bandwidth": {
                        "type": "string",
                        "description": "Maximum available network bandwidth in bytes/second. Used with the I(throttle) option.\nIf I(throttle) is a percentage and bandwidth is C(0) then bandwidth throttling will be disabled. If I(throttle) is expressed as a data rate (bytes/sec) then this option is ignored. Default is C(0) (no bandwidth throttling)."
                     },
                     "baseurl": {
                        "type": "string",
                        "description": "URL to the directory where the yum repository's 'repodata' directory lives.\nIt can also be a list of multiple URLs.\nThis, the I(metalink) or I(mirrorlist) parameters are required if I(state) is set to C(present)."
                     },
                     "cost": {
                        "type": "string",
                        "description": "Default: 1000\n\nRelative cost of accessing this repository. Useful for weighing one repo's packages as greater/less than any other."
                     },
                     "deltarpm_metadata_percentage": {
                        "type": "string",
                        "description": "Default: 100\n\nWhen the relative size of deltarpm metadata vs pkgs is larger than this, deltarpm metadata is not downloaded from the repo. Note that you can give values over C(100), so C(200) means that the metadata is required to be half the size of the packages. Use C(0) to turn off this check, and always download metadata."
                     },
                     "deltarpm_percentage": {
                        "type": "string",
                        "description": "Default: 75\n\nWhen the relative size of delta vs pkg is larger than this, delta is not used. Use C(0) to turn off delta rpm processing. Local repositories (with file:// I(baseurl)) have delta rpms turned off by default."
                     },
                     "description": {
                        "type": "string",
                        "description": "A human readable string describing the repository. This option corresponds to the \"name\" property in the repo file.\nThis parameter is only required if I(state) is set to C(present)."
                     },
                     "enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nThis tells yum whether or not use this repository."
                     },
                     "enablegroups": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nDetermines whether yum will allow the use of package groups for this repository."
                     },
                     "exclude": {
                        "type": "array",
                        "description": "List of packages to exclude from updates or installs. This should be a space separated list. Shell globs using wildcards (eg. C(*) and C(?)) are allowed.\nThe list can also be a regular YAML array."
                     },
                     "failovermethod": {
                        "type": "string",
                        "description": "Default: roundrobin\n\nC(roundrobin) randomly selects a URL out of the list of URLs to start with and proceeds through each of them as it encounters a failure contacting the host.\nC(priority) starts from the first I(baseurl) listed and reads through them sequentially.",
                        "enum": [
                           "roundrobin",
                           "priority"
                        ]
                     },
                     "file": {
                        "type": "string",
                        "description": "File name without the C(.repo) extension to save the repo in. Defaults to the value of I(name)."
                     },
                     "gpgcakey": {
                        "type": "string",
                        "description": "A URL pointing to the ASCII-armored CA key file for the repository."
                     },
                     "gpgcheck": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Tells yum whether or not it should perform a GPG signature check on packages.\nNo default setting. If the value is not set, the system setting from C(/etc/yum.conf) or system default of C(no) will be used."
                     },
                     "gpgkey": {
                        "type": "string",
                        "description": "A URL pointing to the ASCII-armored GPG key file for the repository.\nIt can also be a list of multiple URLs."
                     },
                     "http_caching": {
                        "type": "string",
                        "description": "Default: all\n\nDetermines how upstream HTTP caches are instructed to handle any HTTP downloads that Yum does.\nC(all) means that all HTTP downloads should be cached.\nC(packages) means that only RPM package downloads should be cached (but not repository metadata downloads).\nC(none) means that no HTTP downloads should be cached.",
                        "enum": [
                           "all",
                           "packages",
                           "none"
                        ]
                     },
                     "include": {
                        "type": "string",
                        "description": "Include external configuration file. Both, local path and URL is supported. Configuration file will be inserted at the position of the I(include=) line. Included files may contain further include lines. Yum will abort with an error if an inclusion loop is detected."
                     },
                     "includepkgs": {
                        "type": "array",
                        "description": "List of packages you want to only use from a repository. This should be a space separated list. Shell globs using wildcards (eg. C(*) and C(?)) are allowed. Substitution variables (e.g. C($releasever)) are honored here.\nThe list can also be a regular YAML array."
                     },
                     "ip_resolve": {
                        "type": "string",
                        "description": "Default: whatever\n\nDetermines how yum resolves host names.\nC(4) or C(IPv4) - resolve to IPv4 addresses only.\nC(6) or C(IPv6) - resolve to IPv6 addresses only.",
                        "enum": [
                           4,
                           6,
                           "IPv4",
                           "IPv6",
                           "whatever"
                        ]
                     },
                     "keepalive": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nThis tells yum whether or not HTTP/1.1 keepalive should be used with this repository. This can improve transfer speeds by using one connection when downloading multiple files from a repository."
                     },
                     "keepcache": {
                        "type": "string",
                        "description": "Default: 1\n\nEither C(1) or C(0). Determines whether or not yum keeps the cache of headers and packages after successful installation.",
                        "enum": [
                           "0",
                           "1"
                        ]
                     },
                     "metadata_expire": {
                        "type": "string",
                        "description": "Default: 21600\n\nTime (in seconds) after which the metadata will expire.\nDefault value is 6 hours."
                     },
                     "metadata_expire_filter": {
                        "type": "string",
                        "description": "Default: read-only:present\n\nFilter the I(metadata_expire) time, allowing a trade of speed for accuracy if a command doesn't require it. Each yum command can specify that it requires a certain level of timeliness quality from the remote repos. from \"I'm about to install/upgrade, so this better be current\" to \"Anything that's available is good enough\".\nC(never) - Nothing is filtered, always obey I(metadata_expire).\nC(read-only:past) - Commands that only care about past information are filtered from metadata expiring. Eg. I(yum history) info (if history needs to lookup anything about a previous transaction, then by definition the remote package was available in the past).\nC(read-only:present) - Commands that are balanced between past and future. Eg. I(yum list yum).\nC(read-only:future) - Commands that are likely to result in running other commands which will require the latest metadata. Eg. I(yum check-update).\nNote that this option does not override \"yum clean expire-cache\".",
                        "enum": [
                           "never",
                           "read-only:past",
                           "read-only:present",
                           "read-only:future"
                        ]
                     },
                     "metalink": {
                        "type": "string",
                        "description": "Specifies a URL to a metalink file for the repomd.xml, a list of mirrors for the entire repository are generated by converting the mirrors for the repomd.xml file to a I(baseurl).\nThis, the I(baseurl) or I(mirrorlist) parameters are required if I(state) is set to C(present)."
                     },
                     "mirrorlist": {
                        "type": "string",
                        "description": "Specifies a URL to a file containing a list of baseurls.\nThis, the I(baseurl) or I(metalink) parameters are required if I(state) is set to C(present)."
                     },
                     "mirrorlist_expire": {
                        "type": "string",
                        "description": "Default: 21600\n\nTime (in seconds) after which the mirrorlist locally cached will expire.\nDefault value is 6 hours."
                     },
                     "name": {
                        "type": "string",
                        "description": "Unique repository ID. This option builds the section name of the repository in the repo file.\nThis parameter is only required if I(state) is set to C(present) or C(absent)."
                     },
                     "password": {
                        "type": "string",
                        "description": "Password to use with the username for basic authentication."
                     },
                     "priority": {
                        "type": "string",
                        "description": "Default: 99\n\nEnforce ordered protection of repositories. The value is an integer from 1 to 99.\nThis option only works if the YUM Priorities plugin is installed."
                     },
                     "protect": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nProtect packages from updates from other repositories."
                     },
                     "proxy": {
                        "type": "string",
                        "description": "URL to the proxy server that yum should use. Set to C(_none_) to disable the global proxy setting."
                     },
                     "proxy_password": {
                        "type": "string",
                        "description": "Password for this proxy."
                     },
                     "proxy_username": {
                        "type": "string",
                        "description": "Username to use for proxy."
                     },
                     "repo_gpgcheck": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nThis tells yum whether or not it should perform a GPG signature check on the repodata from this repository."
                     },
                     "reposdir": {
                        "type": "string",
                        "description": "Default: /etc/yum.repos.d\n\nDirectory where the C(.repo) files will be stored."
                     },
                     "retries": {
                        "type": "string",
                        "description": "Default: 10\n\nSet the number of times any attempt to retrieve a file should retry before returning an error. Setting this to C(0) makes yum try forever."
                     },
                     "s3_enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nEnables support for S3 repositories.\nThis option only works if the YUM S3 plugin is installed."
                     },
                     "skip_if_unavailable": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nIf set to C(yes) yum will continue running if this repository cannot be contacted for any reason. This should be set carefully as all repos are consulted for any given command."
                     },
                     "ssl_check_cert_permissions": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nWhether yum should check the permissions on the paths for the certificates on the repository (both remote and local).\nIf we can't read any of the files then yum will force I(skip_if_unavailable) to be C(yes). This is most useful for non-root processes which use yum on repos that have client cert files which are readable only by root."
                     },
                     "sslcacert": {
                        "type": "string",
                        "description": "Path to the directory containing the databases of the certificate authorities yum should use to verify SSL certificates."
                     },
                     "ca_cert": {
                        "type": "string",
                        "description": "Path to the directory containing the databases of the certificate authorities yum should use to verify SSL certificates."
                     },
                     "sslclientcert": {
                        "type": "string",
                        "description": "Path to the SSL client certificate yum should use to connect to repos/remote sites."
                     },
                     "client_cert": {
                        "type": "string",
                        "description": "Path to the SSL client certificate yum should use to connect to repos/remote sites."
                     },
                     "sslclientkey": {
                        "type": "string",
                        "description": "Path to the SSL client key yum should use to connect to repos/remote sites."
                     },
                     "client_key": {
                        "type": "string",
                        "description": "Path to the SSL client key yum should use to connect to repos/remote sites."
                     },
                     "sslverify": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nDefines whether yum should verify SSL certificates/hosts at all."
                     },
                     "validate_certs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nDefines whether yum should verify SSL certificates/hosts at all."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nState of the repo file.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "throttle": {
                        "type": "string",
                        "description": "Enable bandwidth throttling for downloads.\nThis option can be expressed as a absolute data rate in bytes/sec. An SI prefix (k, M or G) may be appended to the bandwidth value."
                     },
                     "timeout": {
                        "type": "string",
                        "description": "Default: 30\n\nNumber of seconds to wait for a connection before timing out."
                     },
                     "ui_repoid_vars": {
                        "type": "string",
                        "description": "Default: releasever basearch\n\nWhen a repository id is displayed, append these yum variables to the string if they are used in the I(baseurl)/etc. Variables are appended in the order listed (and found)."
                     },
                     "username": {
                        "type": "string",
                        "description": "Username to use for basic authentication to a repo or really any url."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "sslcacert",
                                    "ca_cert"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "sslclientcert",
                                    "client_cert"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "sslclientkey",
                                    "client_key"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "sslverify",
                                    "validate_certs"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "yum": {
                  "type": "object",
                  "description": "Installs, upgrade, downgrades, removes, and lists packages and groups with the I(yum) package manager.\nThis module only works on Python 2. If you require Python 3 support see the M(dnf) module.",
                  "properties": {
                     "use_backend": {
                        "type": "string",
                        "description": "Default: auto\n\nThis module supports C(yum) (as it always has), this is known as C(yum3)/C(YUM3)/C(yum-deprecated) by upstream yum developers. As of Ansible 2.7+, this module also supports C(YUM4), which is the \"new yum\" and it has an C(dnf) backend.\nBy default, this module will select the backend based on the C(ansible_pkg_mgr) fact.",
                        "enum": [
                           "auto",
                           "yum",
                           "yum4",
                           "dnf"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "A package name or package specifier with version, like C(name-1.0).\nIf a previous version is specified, the task also needs to turn C(allow_downgrade) on. See the C(allow_downgrade) documentation for caveats with downgrading packages.\nWhen using state=latest, this can be C('*') which means run C(yum -y update).\nYou can also pass a url or a local path to a rpm file (using state=present). To operate on several packages this can accept a comma separated string of packages or (as of 2.0) a list of packages."
                     },
                     "pkg": {
                        "type": "string",
                        "description": "A package name or package specifier with version, like C(name-1.0).\nIf a previous version is specified, the task also needs to turn C(allow_downgrade) on. See the C(allow_downgrade) documentation for caveats with downgrading packages.\nWhen using state=latest, this can be C('*') which means run C(yum -y update).\nYou can also pass a url or a local path to a rpm file (using state=present). To operate on several packages this can accept a comma separated string of packages or (as of 2.0) a list of packages."
                     },
                     "exclude": {
                        "type": "string",
                        "description": "Package name(s) to exclude when state=present, or latest"
                     },
                     "list": {
                        "type": "string",
                        "description": "Package name to run the equivalent of yum list --show-duplicates <package> against. In addition to listing packages, use can also list the following: C(installed), C(updates), C(available) and C(repos).\nThis parameter is mutually exclusive with C(name)."
                     },
                     "state": {
                        "type": "string",
                        "description": "Whether to install (C(present) or C(installed), C(latest)), or remove (C(absent) or C(removed)) a package.\nC(present) and C(installed) will simply ensure that a desired package is installed.\nC(latest) will update the specified package if it's not of the latest available version.\nC(absent) and C(removed) will remove the specified package.\nDefault is C(None), however in effect the default action is C(present) unless the C(autoremove) option is enabled for this module, then C(absent) is inferred.",
                        "enum": [
                           "absent",
                           "installed",
                           "latest",
                           "present",
                           "removed"
                        ]
                     },
                     "enablerepo": {
                        "type": "string",
                        "description": "I(Repoid) of repositories to enable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a C(\",\").\nAs of Ansible 2.7, this can alternatively be a list instead of C(\",\") separated string"
                     },
                     "disablerepo": {
                        "type": "string",
                        "description": "I(Repoid) of repositories to disable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a C(\",\").\nAs of Ansible 2.7, this can alternatively be a list instead of C(\",\") separated string"
                     },
                     "conf_file": {
                        "type": "string",
                        "description": "The remote yum configuration file to use for the transaction."
                     },
                     "disable_gpg_check": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nWhether to disable the GPG checking of signatures of packages being installed. Has an effect only if state is I(present) or I(latest)."
                     },
                     "skip_broken": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nSkip packages with broken dependencies(devsolve) and are causing problems."
                     },
                     "update_cache": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nForce yum to check if cache is out of date and redownload if needed. Has an effect only if state is I(present) or I(latest)."
                     },
                     "expire-cache": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nForce yum to check if cache is out of date and redownload if needed. Has an effect only if state is I(present) or I(latest)."
                     },
                     "validate_certs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nThis only applies if using a https url as the source of the rpm. e.g. for localinstall. If set to C(no), the SSL certificates will not be validated.\nThis should only set to C(no) used on personally controlled sites using self-signed certificates as it avoids verifying the source site.\nPrior to 2.1 the code worked as if this was set to C(yes)."
                     },
                     "update_only": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nWhen using latest, only update installed packages. Do not install packages.\nHas an effect only if state is I(latest)"
                     },
                     "installroot": {
                        "type": "string",
                        "description": "Default: /\n\nSpecifies an alternative installroot, relative to which all packages will be installed."
                     },
                     "security": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nIf set to C(yes), and C(state=latest) then only installs updates that have been marked security related."
                     },
                     "bugfix": {
                        "type": "string",
                        "description": "Default: no\n\nIf set to C(yes), and C(state=latest) then only installs updates that have been marked bugfix related."
                     },
                     "allow_downgrade": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nSpecify if the named package and version is allowed to downgrade a maybe already installed higher version of that package. Note that setting allow_downgrade=True can make this module behave in a non-idempotent way. The task could end up with a set of packages that does not match the complete list of specified packages to install (because dependencies between the downgraded package and others can cause changes to the packages which were in the earlier transaction)."
                     },
                     "enable_plugin": {
                        "type": "string",
                        "description": "I(Plugin) name to enable for the install/update operation. The enabled plugin will not persist beyond the transaction."
                     },
                     "disable_plugin": {
                        "type": "string",
                        "description": "I(Plugin) name to disable for the install/update operation. The disabled plugins will not persist beyond the transaction."
                     },
                     "releasever": {
                        "type": "string",
                        "description": "Specifies an alternative release from which all packages will be installed."
                     },
                     "autoremove": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nIf C(yes), removes all \"leaf\" packages from the system that were originally installed as dependencies of user-installed packages but which are no longer required by any such package. Should be used alone or when state is I(absent)\nNOTE: This feature requires yum >= 3.4.3 (RHEL/CentOS 7+)"
                     },
                     "disable_excludes": {
                        "type": "string",
                        "description": "Disable the excludes defined in YUM config files.\nIf set to C(all), disables all excludes.\nIf set to C(main), disable excludes defined in [main] in yum.conf.\nIf set to C(repoid), disable excludes defined for given repo id."
                     },
                     "download_only": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nOnly download the packages, do not install them."
                     },
                     "lock_timeout": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 30\n\nAmount of time to wait for the yum lockfile to be freed."
                     },
                     "install_weak_deps": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nWill also install all packages linked by a weak dependency relation.\nNOTE: This feature requires yum >= 4 (RHEL/CentOS 8+)"
                     },
                     "download_dir": {
                        "type": "string",
                        "description": "Specifies an alternate directory to store packages.\nHas an effect only if I(download_only) is specified."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "pkg"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "update_cache",
                                    "expire-cache"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "xbps": {
                  "type": "object",
                  "description": "Manage packages with the XBPS package manager.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the package to install, upgrade, or remove."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDesired state of the package.",
                        "enum": [
                           "present",
                           "absent",
                           "latest"
                        ]
                     },
                     "recurse": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nWhen removing a package, also remove its dependencies, provided that they are not required by other packages and were not explicitly installed by a user."
                     },
                     "update_cache": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nWhether or not to refresh the master package lists. This can be run as part of a package installation or as a separate step."
                     },
                     "upgrade": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nWhether or not to upgrade whole system"
                     }
                  }
               },
               "swupd": {
                  "type": "object",
                  "description": "Manages updates and bundles with the swupd bundle manager, which is used by the Clear Linux Project for Intel Architecture.",
                  "properties": {
                     "contenturl": {
                        "type": "string",
                        "description": "URL pointing to the contents of available bundles. If not specified, the contents are retrieved from clearlinux.org."
                     },
                     "format": {
                        "type": "string",
                        "description": "The format suffix for version file downloads. For example [1,2,3,staging,etc]. If not specified, the default format is used."
                     },
                     "manifest": {
                        "type": "string",
                        "description": "The manifest contains information about the bundles at certain version of the OS. Specify a Manifest version to verify against that version or leave unspecified to verify against the current version."
                     },
                     "release": {
                        "type": "string",
                        "description": "The manifest contains information about the bundles at certain version of the OS. Specify a Manifest version to verify against that version or leave unspecified to verify against the current version."
                     },
                     "version": {
                        "type": "string",
                        "description": "The manifest contains information about the bundles at certain version of the OS. Specify a Manifest version to verify against that version or leave unspecified to verify against the current version."
                     },
                     "name": {
                        "type": "string",
                        "description": "Name of the (I)bundle to install or remove."
                     },
                     "bundle": {
                        "type": "string",
                        "description": "Name of the (I)bundle to install or remove."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIndicates the desired (I)bundle state. C(present) ensures the bundle is installed while C(absent) ensures the (I)bundle is not installed.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "update": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Updates the OS to the latest version."
                     },
                     "url": {
                        "type": "string",
                        "description": "Overrides both I(contenturl) and I(versionurl)."
                     },
                     "verify": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Verify content for OS version."
                     },
                     "versionurl": {
                        "type": "string",
                        "description": "URL for version string download."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "manifest",
                                    "release",
                                    "version"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "bundle"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "swdepot": {
                  "type": "object",
                  "description": "Will install, upgrade and remove packages with swdepot package manager (HP-UX)",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "package name."
                     },
                     "state": {
                        "type": "string",
                        "description": "whether to install (C(present), C(latest)), or remove (C(absent)) a package.",
                        "enum": [
                           "present",
                           "latest",
                           "absent"
                        ]
                     },
                     "depot": {
                        "type": "string",
                        "description": "The source repository from which install or upgrade a package."
                     }
                  },
                  "required": [
                     "name",
                     "state"
                  ]
               },
               "svr4pkg": {
                  "type": "object",
                  "description": "Manages SVR4 packages on Solaris 10 and 11.\nThese were the native packages on Solaris <= 10 and are available as a legacy feature in Solaris 11.\nNote that this is a very basic packaging system. It will not enforce dependencies on install or remove.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Package name, e.g. C(SUNWcsr)"
                     },
                     "state": {
                        "type": "string",
                        "description": "Whether to install (C(present)), or remove (C(absent)) a package.\nIf the package is to be installed, then I(src) is required.\nThe SVR4 package system doesn't provide an upgrade operation. You need to uninstall the old, then install the new package.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "src": {
                        "type": "string",
                        "description": "Specifies the location to install the package from. Required when C(state=present).\nCan be any path acceptable to the C(pkgadd) command's C(-d) option. e.g.: C(somefile.pkg), C(/dir/with/pkgs), C(http:/server/mypkgs.pkg).\nIf using a file or directory, they must already be accessible by the host. See the M(copy) module for a way to get them there."
                     },
                     "proxy": {
                        "type": "string",
                        "description": "HTTP[s] proxy to be used if C(src) is a URL."
                     },
                     "response_file": {
                        "type": "string",
                        "description": "Specifies the location of a response file to be used if package expects input on install. (added in Ansible 1.4)"
                     },
                     "zone": {
                        "type": "string",
                        "description": "Default: all\n\nWhether to install the package only in the current zone, or install it into all zones.\nThe installation into all zones works only if you are working with the global zone.",
                        "enum": [
                           "current",
                           "all"
                        ]
                     },
                     "category": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Install/Remove category instead of a single package."
                     }
                  },
                  "required": [
                     "name",
                     "state"
                  ]
               },
               "sorcery": {
                  "type": "object",
                  "description": "Manages \"spells\" on Source Mage GNU/Linux using I(sorcery) toolchain",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the spell\nmultiple names can be given, separated by commas\nspecial value '*' in conjunction with states C(latest) or C(rebuild) will update or rebuild the whole system respectively"
                     },
                     "spell": {
                        "type": "string",
                        "description": "Name of the spell\nmultiple names can be given, separated by commas\nspecial value '*' in conjunction with states C(latest) or C(rebuild) will update or rebuild the whole system respectively"
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether to cast, dispel or rebuild a package\nstate C(cast) is an equivalent of C(present), not C(latest)\nstate C(latest) always triggers C(update_cache=yes)\nstate C(rebuild) implies cast of all specified spells, not only those existed before",
                        "enum": [
                           "present",
                           "latest",
                           "absent",
                           "cast",
                           "dispelled",
                           "rebuild"
                        ]
                     },
                     "depends": {
                        "type": "string",
                        "description": "Comma-separated list of _optional_ dependencies to build a spell (or make sure it is built) with; use +/- in front of dependency to turn it on/off ('+' is optional though)\nthis option is ignored if C(name) parameter is equal to '*' or contains more than one spell\nproviders must be supplied in the form recognized by Sorcery, e.g. 'openssl(SSL)'"
                     },
                     "update": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nWhether or not to update sorcery scripts at the very first stage"
                     },
                     "update_cache": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nWhether or not to update grimoire collection before casting spells"
                     },
                     "update_codex": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nWhether or not to update grimoire collection before casting spells"
                     },
                     "cache_valid_time": {
                        "type": "string",
                        "description": "Time in seconds to invalidate grimoire collection on update\nespecially useful for SCM and rsync grimoires\nmakes sense only in pair with C(update_cache)"
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "spell"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "update_cache",
                                    "update_codex"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "snap": {
                  "type": "object",
                  "description": "Manages snaps packages.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the snap to install or remove. Can be a list of snaps."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDesired state of the package.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "classic": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Confinement policy. The classic confinement allows a snap to have the same level of access to the system as \"classic\" packages, like those managed by APT. This option corresponds to the --classic argument. This option can only be specified if there is a single snap in the task."
                     },
                     "channel": {
                        "type": "string",
                        "description": "Default: stable\n\nDefine which release of a snap is installed and tracked for updates. This option can only be specified if there is a single snap in the task."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "slackpkg": {
                  "type": "object",
                  "description": "Manage binary packages for Slackware using 'slackpkg' which is available in versions after 12.2.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "name of package to install/remove"
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nstate of the package, you can use \"installed\" as an alias for C(present) and removed as one for C(absent).",
                        "enum": [
                           "present",
                           "absent",
                           "latest"
                        ]
                     },
                     "update_cache": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "update the package database first"
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "rpm_key": {
                  "type": "object",
                  "description": "Adds or removes (rpm --import) a gpg key to your rpm database.",
                  "properties": {
                     "key": {
                        "type": "string",
                        "description": "Key that will be modified. Can be a url, a file on the managed node, or a keyid if the key already exists in the database."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIf the key will be imported or removed from the rpm db.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "validate_certs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nIf C(no) and the C(key) is a url starting with https, SSL certificates will not be validated.\nThis should only be used on personally controlled sites using self-signed certificates."
                     },
                     "fingerprint": {
                        "type": "string",
                        "description": "The long-form fingerprint of the key being imported.\nThis will be used to verify the specified key."
                     }
                  },
                  "required": [
                     "key"
                  ]
               },
               "rhsm_repository": {
                  "type": "object",
                  "description": "Manage (Enable/Disable) RHSM repositories to the Red Hat Subscription Management entitlement platform using the C(subscription-manager) command.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIf state is equal to present or disabled, indicates the desired repository state.",
                        "enum": [
                           "present",
                           "enabled",
                           "absent",
                           "disabled"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The ID of repositories to enable.\nTo operate on several repositories this can accept a comma separated list or a YAML list."
                     },
                     "purge": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Disable all currently enabled repositories that are not not specified in C(name). Only set this to C(True) if passing in a list of repositories to the C(name) field. Using this with C(loop) will most likely not have the desired result."
                     }
                  },
                  "required": [
                     "state",
                     "name"
                  ]
               },
               "rhsm_release": {
                  "type": "object",
                  "description": "Sets or unsets the release version used by RHSM repositories.",
                  "properties": {
                     "release": {
                        "type": "string",
                        "description": "RHSM release version to use (use null to unset)"
                     }
                  },
                  "required": [
                     "release"
                  ]
               },
               "rhn_register": {
                  "type": "object",
                  "description": "Manage registration to the Red Hat Network.",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether to register (C(present)), or unregister (C(absent)) a system.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     },
                     "username": {
                        "type": "string",
                        "description": "Red Hat Network username."
                     },
                     "password": {
                        "type": "string",
                        "description": "Red Hat Network password."
                     },
                     "server_url": {
                        "type": "string",
                        "description": "Specify an alternative Red Hat Network server URL.\nThe default is the current value of I(serverURL) from C(/etc/sysconfig/rhn/up2date)."
                     },
                     "activationkey": {
                        "type": "string",
                        "description": "Supply an activation key for use with registration."
                     },
                     "profilename": {
                        "type": "string",
                        "description": "Supply an profilename for use with registration."
                     },
                     "ca_cert": {
                        "type": "string",
                        "description": "Supply a custom ssl CA certificate file for use with registration."
                     },
                     "sslcacert": {
                        "type": "string",
                        "description": "Supply a custom ssl CA certificate file for use with registration."
                     },
                     "systemorgid": {
                        "type": "string",
                        "description": "Supply an organizational id for use with registration."
                     },
                     "channels": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Optionally specify a list of channels to subscribe to upon successful registration."
                     },
                     "enable_eus": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "If C(no), extended update support will be requested."
                     },
                     "nopackages": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "If C(yes), the registered node will not upload its installed packages information to Satellite server."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "ca_cert",
                                    "sslcacert"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "rhn_channel": {
                  "type": "object",
                  "description": "Adds or removes Red Hat software channels.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the software channel."
                     },
                     "sysname": {
                        "type": "string",
                        "description": "Name of the system as it is known in RHN/Satellite."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the channel should be present or not, taking action if the state is different from what is stated."
                     },
                     "url": {
                        "type": "string",
                        "description": "The full URL to the RHN/Satellite API."
                     },
                     "user": {
                        "type": "string",
                        "description": "RHN/Satellite login."
                     },
                     "password": {
                        "type": "string",
                        "description": "RHN/Satellite password."
                     }
                  },
                  "required": [
                     "name",
                     "sysname",
                     "url",
                     "user",
                     "password"
                  ]
               },
               "redhat_subscription": {
                  "type": "object",
                  "description": "Manage registration and subscription to the Red Hat Subscription Management entitlement platform using the C(subscription-manager) command",
                  "properties": {
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nwhether to register and subscribe (C(present)), or unregister (C(absent)) a system",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "username": {
                        "type": "string",
                        "description": "access.redhat.com or Sat6  username"
                     },
                     "password": {
                        "type": "string",
                        "description": "access.redhat.com or Sat6 password"
                     },
                     "server_hostname": {
                        "type": "string",
                        "description": "Specify an alternative Red Hat Subscription Management or Sat6 server"
                     },
                     "server_insecure": {
                        "type": "string",
                        "description": "Enable or disable https server certificate verification when connecting to C(server_hostname)"
                     },
                     "rhsm_baseurl": {
                        "type": "string",
                        "description": "Specify CDN baseurl"
                     },
                     "rhsm_repo_ca_cert": {
                        "type": "string",
                        "description": "Specify an alternative location for a CA certificate for CDN"
                     },
                     "server_proxy_hostname": {
                        "type": "string",
                        "description": "Specify a HTTP proxy hostname"
                     },
                     "server_proxy_port": {
                        "type": "string",
                        "description": "Specify a HTTP proxy port"
                     },
                     "server_proxy_user": {
                        "type": "string",
                        "description": "Specify a user for HTTP proxy with basic authentication"
                     },
                     "server_proxy_password": {
                        "type": "string",
                        "description": "Specify a password for HTTP proxy with basic authentication"
                     },
                     "auto_attach": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nUpon successful registration, auto-consume available subscriptions\nAdded in favor of deprecated autosubscribe in 2.5."
                     },
                     "autosubscribe": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nUpon successful registration, auto-consume available subscriptions\nAdded in favor of deprecated autosubscribe in 2.5."
                     },
                     "activationkey": {
                        "type": "string",
                        "description": "supply an activation key for use with registration"
                     },
                     "org_id": {
                        "type": "string",
                        "description": "Organization ID to use in conjunction with activationkey"
                     },
                     "environment": {
                        "type": "string",
                        "description": "Register with a specific environment in the destination org. Used with Red Hat Satellite 6.x or Katello"
                     },
                     "pool": {
                        "type": "string",
                        "description": "Default: ^$\n\nSpecify a subscription pool name to consume.  Regular expressions accepted. Use I(pool_ids) instead if\npossible, as it is much faster. Mutually exclusive with I(pool_ids).\n"
                     },
                     "pool_ids": {
                        "type": "string",
                        "description": "Specify subscription pool IDs to consume. Prefer over I(pool) when possible as it is much faster.\nA pool ID may be specified as a C(string) - just the pool ID (ex. C(0123456789abcdef0123456789abcdef)),\nor as a C(dict) with the pool ID as the key, and a quantity as the value (ex.\nC(0123456789abcdef0123456789abcdef: 2). If the quantity is provided, it is used to consume multiple\nentitlements from a pool (the pool must support this). Mutually exclusive with I(pool).\n"
                     },
                     "consumer_type": {
                        "type": "string",
                        "description": "The type of unit to register, defaults to system"
                     },
                     "consumer_name": {
                        "type": "string",
                        "description": "Name of the system to register, defaults to the hostname"
                     },
                     "consumer_id": {
                        "type": "string",
                        "description": "References an existing consumer ID to resume using a previous registration\nfor this system. If the  system's identity certificate is lost or corrupted,\nthis option allows it to resume using its previous identity and subscriptions.\nThe default is to not specify a consumer ID so a new ID is created.\n"
                     },
                     "force_register": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nRegister the system even if it is already registered"
                     },
                     "release": {
                        "type": "string",
                        "description": "Set a release version"
                     },
                     "syspurpose": {
                        "type": "object",
                        "description": "Set syspurpose attributes in file C(/etc/rhsm/syspurpose/syspurpose.json) and synchronize these attributes with RHSM server. Syspurpose attributes help attach the most appropriate subscriptions to the system automatically. When C(syspurpose.json) file already contains some attributes, then new attributes overwrite existing attributes. When some attribute is not listed in the new list of attributes, the existing attribute will be removed from C(syspurpose.json) file. Unknown attributes are ignored."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "auto_attach",
                                    "autosubscribe"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "pulp_repo": {
                  "type": "object",
                  "description": "Add or remove Pulp repos from a remote host.",
                  "properties": {
                     "add_export_distributor": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nWhether or not to add the export distributor to new C(rpm) repositories."
                     },
                     "feed": {
                        "type": "string",
                        "description": "Upstream feed URL to receive updates from."
                     },
                     "force_basic_auth": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nhttplib2, the library used by the M(uri) module only sends authentication information when a webservice responds to an initial request with a 401 status. Since some basic auth services do not properly send a 401, logins will fail. This option forces the sending of the Basic authentication header upon initial request."
                     },
                     "generate_sqlite": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nBoolean flag to indicate whether sqlite files should be generated during a repository publish."
                     },
                     "feed_ca_cert": {
                        "type": "string",
                        "description": "CA certificate string used to validate the feed source SSL certificate. This can be the file content or the path to the file. The ca_cert alias will be removed in Ansible 2.14."
                     },
                     "importer_ssl_ca_cert": {
                        "type": "string",
                        "description": "CA certificate string used to validate the feed source SSL certificate. This can be the file content or the path to the file. The ca_cert alias will be removed in Ansible 2.14."
                     },
                     "ca_cert": {
                        "type": "string",
                        "description": "CA certificate string used to validate the feed source SSL certificate. This can be the file content or the path to the file. The ca_cert alias will be removed in Ansible 2.14."
                     },
                     "feed_client_cert": {
                        "type": "string",
                        "description": "Certificate used as the client certificate when synchronizing the repository. This is used to communicate authentication information to the feed source. The value to this option must be the full path to the certificate. The specified file may be the certificate itself or a single file containing both the certificate and private key. This can be the file content or the path to the file.\nIf not specified the default value will come from client_cert. Which will change in Ansible 2.14."
                     },
                     "importer_ssl_client_cert": {
                        "type": "string",
                        "description": "Certificate used as the client certificate when synchronizing the repository. This is used to communicate authentication information to the feed source. The value to this option must be the full path to the certificate. The specified file may be the certificate itself or a single file containing both the certificate and private key. This can be the file content or the path to the file.\nIf not specified the default value will come from client_cert. Which will change in Ansible 2.14."
                     },
                     "feed_client_key": {
                        "type": "string",
                        "description": "Private key to the certificate specified in I(importer_ssl_client_cert), assuming it is not included in the certificate file itself. This can be the file content or the path to the file.\nIf not specified the default value will come from client_key. Which will change in Ansible 2.14."
                     },
                     "importer_ssl_client_key": {
                        "type": "string",
                        "description": "Private key to the certificate specified in I(importer_ssl_client_cert), assuming it is not included in the certificate file itself. This can be the file content or the path to the file.\nIf not specified the default value will come from client_key. Which will change in Ansible 2.14."
                     },
                     "name": {
                        "type": "string",
                        "description": "Name of the repo to add or remove. This correlates to repo-id in Pulp."
                     },
                     "proxy_host": {
                        "type": "string",
                        "description": "Proxy url setting for the pulp repository importer. This is in the format scheme://host."
                     },
                     "proxy_port": {
                        "type": "string",
                        "description": "Proxy port setting for the pulp repository importer."
                     },
                     "proxy_username": {
                        "type": "string",
                        "description": "Proxy username for the pulp repository importer."
                     },
                     "proxy_password": {
                        "type": "string",
                        "description": "Proxy password for the pulp repository importer."
                     },
                     "publish_distributor": {
                        "type": "string",
                        "description": "Distributor to use when state is C(publish). The default is to publish all distributors."
                     },
                     "pulp_host": {
                        "type": "string",
                        "description": "Default: http://127.0.0.1\n\nURL of the pulp server to connect to."
                     },
                     "relative_url": {
                        "type": "string",
                        "description": "Relative URL for the local repository."
                     },
                     "repo_type": {
                        "type": "string",
                        "description": "Default: rpm\n\nRepo plugin type to use (i.e. C(rpm), C(docker))."
                     },
                     "repoview": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nWhether to generate repoview files for a published repository. Setting this to \"yes\" automatically activates `generate_sqlite`."
                     },
                     "serve_http": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nMake the repo available over HTTP."
                     },
                     "serve_https": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nMake the repo available over HTTPS."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nThe repo state. A state of C(sync) will queue a sync of the repo. This is asynchronous but not delayed like a scheduled sync. A state of C(publish) will use the repository's distributor to publish the content.",
                        "enum": [
                           "present",
                           "absent",
                           "sync",
                           "publish"
                        ]
                     },
                     "url_password": {
                        "type": "string",
                        "description": "The password for use in HTTP basic authentication to the pulp API. If the I(url_username) parameter is not specified, the I(url_password) parameter will not be used."
                     },
                     "url_username": {
                        "type": "string",
                        "description": "The username for use in HTTP basic authentication to the pulp API."
                     },
                     "validate_certs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nIf C(no), SSL certificates will not be validated. This should only be used on personally controlled sites using self-signed certificates."
                     },
                     "wait_for_completion": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nWait for asynchronous tasks to complete before returning."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "feed_ca_cert",
                                    "importer_ssl_ca_cert",
                                    "ca_cert"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "feed_client_cert",
                                    "importer_ssl_client_cert"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "feed_client_key",
                                    "importer_ssl_client_key"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "portinstall": {
                  "type": "object",
                  "description": "Manage packages for FreeBSD using 'portinstall'.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "name of package to install/remove"
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nstate of the package",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "use_packages": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nuse packages instead of ports whenever available"
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "portage": {
                  "type": "object",
                  "description": "Manages Gentoo packages",
                  "properties": {
                     "package": {
                        "type": "string",
                        "description": "Package atom or set, e.g. C(sys-apps/foo) or C(>foo-2.13) or C(@world)"
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nState of the package atom",
                        "enum": [
                           "present",
                           "installed",
                           "emerged",
                           "absent",
                           "removed",
                           "unmerged",
                           "latest"
                        ]
                     },
                     "update": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nUpdate packages to the best version available (--update)"
                     },
                     "deep": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nConsider the entire dependency tree of packages (--deep)"
                     },
                     "newuse": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nInclude installed packages where USE flags have changed (--newuse)"
                     },
                     "changed_use": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nInclude installed packages where USE flags have changed, except when\nflags that the user has not enabled are added or removed\n(--changed-use)"
                     },
                     "oneshot": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nDo not add the packages to the world file (--oneshot)"
                     },
                     "noreplace": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nDo not re-emerge installed packages (--noreplace)"
                     },
                     "nodeps": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nOnly merge packages but not their dependencies (--nodeps)"
                     },
                     "onlydeps": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nOnly merge packages' dependencies but not the packages (--onlydeps)"
                     },
                     "depclean": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nRemove packages not needed by explicitly merged packages (--depclean)\nIf no package is specified, clean up the world's dependencies\nOtherwise, --depclean serves as a dependency aware version of --unmerge"
                     },
                     "quiet": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nRun emerge in quiet mode (--quiet)"
                     },
                     "verbose": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nRun emerge in verbose mode (--verbose)"
                     },
                     "sync": {
                        "type": "string",
                        "description": "Sync package repositories first\nIf yes, perform \"emerge --sync\"\nIf web, perform \"emerge-webrsync\"",
                        "enum": [
                           "web",
                           "yes",
                           "no"
                        ]
                     },
                     "getbinpkg": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nPrefer packages specified at PORTAGE_BINHOST in make.conf"
                     },
                     "usepkgonly": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nMerge only binaries (no compiling). This sets getbinpkg=yes."
                     },
                     "keepgoing": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nContinue as much as possible after an error."
                     },
                     "jobs": {
                        "type": "string",
                        "description": "Specifies the number of packages to build simultaneously.\nSince version 2.6: Value of 0 or False resets any previously added\n--jobs setting values"
                     },
                     "loadavg": {
                        "type": "string",
                        "description": "Specifies that no new builds should be started if there are\nother builds running and the load average is at least LOAD\nSince version 2.6: Value of 0 or False resets any previously added\n--load-average setting values"
                     },
                     "quietbuild": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nRedirect all build output to logs alone, and do not display it\non stdout (--quiet-build)"
                     },
                     "quietfail": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nSuppresses display of the build log on stdout (--quiet-fail)\nOnly the die message and the path of the build log will be\ndisplayed on stdout."
                     }
                  }
               },
               "pkgutil": {
                  "type": "object",
                  "description": "Manages CSW packages (SVR4 format) on Solaris 10 and 11.\nThese were the native packages on Solaris <= 10 and are available as a legacy feature in Solaris 11.\nPkgutil is an advanced packaging system, which resolves dependency on installation. It is designed for CSW packages.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Package name, e.g. (C(CSWnrpe))"
                     },
                     "site": {
                        "type": "string",
                        "description": "Specifies the repository path to install the package from.\nIts global definition is done in C(/etc/opt/csw/pkgutil.conf)."
                     },
                     "state": {
                        "type": "string",
                        "description": "Whether to install (C(present)), or remove (C(absent)) a package.\nThe upgrade (C(latest)) operation will update/install the package to the latest version available.\nNote: The module has a limitation that (C(latest)) only works for one package, not lists of them.",
                        "enum": [
                           "present",
                           "absent",
                           "latest"
                        ]
                     },
                     "update_catalog": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "If you want to refresh your catalog from the mirror, set this to (C(yes))."
                     }
                  },
                  "required": [
                     "name",
                     "state"
                  ]
               },
               "pkgng": {
                  "type": "object",
                  "description": "Manage binary packages for FreeBSD using 'pkgng' which is available in versions after 9.0.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name or list of names of packages to install/remove."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nState of the package.\nNote: \"latest\" added in 2.7",
                        "enum": [
                           "present",
                           "latest",
                           "absent"
                        ]
                     },
                     "cached": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Use local package base instead of fetching an updated one."
                     },
                     "annotation": {
                        "type": "string",
                        "description": "A comma-separated list of keyvalue-pairs of the form C(<+/-/:><key>[=<value>]). A C(+) denotes adding an annotation, a C(-) denotes removing an annotation, and C(:) denotes modifying an annotation. If setting or modifying annotations, a value must be provided."
                     },
                     "pkgsite": {
                        "type": "string",
                        "description": "For pkgng versions before 1.1.4, specify packagesite to use for downloading packages. If not specified, use settings from C(/usr/local/etc/pkg.conf).\nFor newer pkgng versions, specify a the name of a repository configured in C(/usr/local/etc/pkg/repos)."
                     },
                     "rootdir": {
                        "type": "string",
                        "description": "For pkgng versions 1.5 and later, pkg will install all packages within the specified root directory.\nCan not be used together with I(chroot) or I(jail) options."
                     },
                     "chroot": {
                        "type": "string",
                        "description": "Pkg will chroot in the specified environment.\nCan not be used together with I(rootdir) or I(jail) options."
                     },
                     "jail": {
                        "type": "string",
                        "description": "Pkg will execute in the given jail name or id.\nCan not be used together with I(chroot) or I(rootdir) options."
                     },
                     "autoremove": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Remove automatically installed packages which are no longer needed."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "pkgin": {
                  "type": "object",
                  "description": "The standard package manager for SmartOS, but also usable on NetBSD or any OS that uses C(pkgsrc).  (Home: U(http://pkgin.net/))",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of package to install/remove;\nmultiple names may be given, separated by commas"
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIntended state of the package",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "update_cache": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nUpdate repository database. Can be run with other steps or on it's own."
                     },
                     "upgrade": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nUpgrade main packages to their newer versions"
                     },
                     "full_upgrade": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nUpgrade all packages to their newer versions"
                     },
                     "clean": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nClean packages cache"
                     },
                     "force": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nForce package reinstall"
                     }
                  }
               },
               "pkg5_publisher": {
                  "type": "object",
                  "description": "IPS packages are the native packages in Solaris 11 and higher.\nThis modules will configure which publishers a client will download IPS packages from.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The publisher's name."
                     },
                     "publisher": {
                        "type": "string",
                        "description": "The publisher's name."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether to ensure that a publisher is present or absent.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "sticky": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Packages installed from a sticky repository can only receive updates from that repository."
                     },
                     "enabled": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Is the repository enabled or disabled?"
                     },
                     "origin": {
                        "type": "string",
                        "description": "A path or URL to the repository.\nMultiple values may be provided."
                     },
                     "mirror": {
                        "type": "string",
                        "description": "A path or URL to the repository mirror.\nMultiple values may be provided."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "publisher"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "publisher"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "pkg5": {
                  "type": "object",
                  "description": "IPS packages are the native packages in Solaris 11 and higher.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "An FRMI of the package(s) to be installed/removed/updated.\nMultiple packages may be specified, separated by C(,)."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether to install (I(present), I(latest)), or remove (I(absent)) a package.",
                        "enum": [
                           "absent",
                           "latest",
                           "present"
                        ]
                     },
                     "accept_licenses": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Accept any licences."
                     },
                     "accept": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Accept any licences."
                     },
                     "accept_licences": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Accept any licences."
                     },
                     "be_name": {
                        "type": "string",
                        "description": "Creates a new boot environment with the given name."
                     },
                     "refresh": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: True\n\nRefresh publishers before execution."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "accept_licenses",
                                    "accept",
                                    "accept_licences"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "pacman": {
                  "type": "object",
                  "description": "Manage packages with the I(pacman) package manager, which is used by Arch Linux and its variants.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name or list of names of the package(s) or file(s) to install, upgrade, or remove. Can't be used in combination with C(upgrade)."
                     },
                     "package": {
                        "type": "string",
                        "description": "Name or list of names of the package(s) or file(s) to install, upgrade, or remove. Can't be used in combination with C(upgrade)."
                     },
                     "pkg": {
                        "type": "string",
                        "description": "Name or list of names of the package(s) or file(s) to install, upgrade, or remove. Can't be used in combination with C(upgrade)."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nDesired state of the package.",
                        "enum": [
                           "absent",
                           "latest",
                           "present"
                        ]
                     },
                     "recurse": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "When removing a package, also remove its dependencies, provided that they are not required by other packages and were not explicitly installed by a user. This option is deprecated since 2.8 and will be removed in 2.10, use `extra_args=--recursive`."
                     },
                     "force": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "When removing package, force remove package, without any checks. Same as `extra_args=\"--nodeps --nodeps\"`. When update_cache, force redownload repo databases. Same as `update_cache_extra_args=\"--refresh --refresh\"`."
                     },
                     "extra_args": {
                        "type": "string",
                        "description": "Additional option to pass to pacman when enforcing C(state)."
                     },
                     "update_cache": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether or not to refresh the master package lists.\nThis can be run as part of a package installation or as a separate step."
                     },
                     "update-cache": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether or not to refresh the master package lists.\nThis can be run as part of a package installation or as a separate step."
                     },
                     "update_cache_extra_args": {
                        "type": "string",
                        "description": "Additional option to pass to pacman when enforcing C(update_cache)."
                     },
                     "upgrade": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether or not to upgrade the whole system. Can't be used in combination with C(name)."
                     },
                     "upgrade_extra_args": {
                        "type": "string",
                        "description": "Additional option to pass to pacman when enforcing C(upgrade)."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "package",
                                    "pkg"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "update_cache",
                                    "update-cache"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "package_facts": {
                  "type": "object",
                  "description": "Return information about installed packages as facts",
                  "properties": {
                     "manager": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "Default: ['auto']\n\nThe package manager used by the system so we can query the package information.\nSince 2.8 this is a list and can support multiple package managers per system.\nThe 'portage' and 'pkg' options were added in version 2.8."
                     },
                     "strategy": {
                        "type": "string",
                        "description": "Default: first\n\nThis option controls how the module queries the package managers on the system. C(first) means it will return only information for the first supported package manager available. C(all) will return information for all supported and available package managers on the system.",
                        "enum": [
                           "first",
                           "all"
                        ]
                     }
                  }
               },
               "package": {
                  "type": "object",
                  "description": "Installs, upgrade and removes packages using the underlying OS package manager.\nFor Windows targets, use the M(win_package) module instead.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Package name, or package specifier with version.\nSyntax varies with package manager. For example C(name-1.0) or C(name=1.0).\nPackage names also vary with package manager; this module will not \"translate\" them per distro. For example C(libyaml-dev), C(libyaml-devel)."
                     },
                     "state": {
                        "type": "string",
                        "description": "Whether to install (C(present)), or remove (C(absent)) a package.\nYou can use other states like C(latest) ONLY if they are supported by the underlying package module(s) executed."
                     },
                     "use": {
                        "type": "string",
                        "description": "Default: auto\n\nThe required package manager module to use (yum, apt, etc). The default 'auto' will use existing facts or try to autodetect it.\nYou should only use this field if the automatic selection is not working for some reason."
                     }
                  },
                  "required": [
                     "name",
                     "state"
                  ]
               },
               "opkg": {
                  "type": "object",
                  "description": "Manages OpenWrt packages",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "name of package to install/remove"
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nstate of the package",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     },
                     "force": {
                        "type": "string",
                        "description": "Default: absent\n\nopkg --force parameter used",
                        "enum": [
                           "",
                           "depends",
                           "maintainer",
                           "reinstall",
                           "overwrite",
                           "downgrade",
                           "space",
                           "postinstall",
                           "remove",
                           "checksum",
                           "removal-of-dependent-packages"
                        ]
                     },
                     "update_cache": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nupdate the package db first"
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "openbsd_pkg": {
                  "type": "object",
                  "description": "Manage packages on OpenBSD using the pkg tools.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "A name or a list of names of the packages."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nC(present) will make sure the package is installed. C(latest) will make sure the latest version of the package is installed. C(absent) will make sure the specified package is not installed.",
                        "enum": [
                           "absent",
                           "latest",
                           "present"
                        ]
                     },
                     "build": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nBuild the package from source instead of downloading and installing a binary. Requires that the port source tree is already installed. Automatically builds and installs the 'sqlports' package, if it is not already installed."
                     },
                     "ports_dir": {
                        "type": "string",
                        "description": "Default: /usr/ports\n\nWhen used in combination with the C(build) option, allows overriding the default ports source directory."
                     },
                     "clean": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nWhen updating or removing packages, delete the extra configuration file(s) in the old packages which are annotated with @extra in the packaging-list."
                     },
                     "quick": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nReplace or delete packages quickly; do not bother with checksums before removing normal files."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "macports": {
                  "type": "object",
                  "description": "Manages MacPorts packages (ports)",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "A list of port names."
                     },
                     "port": {
                        "type": "string",
                        "description": "A list of port names."
                     },
                     "selfupdate": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nUpdate Macports and the ports tree, either prior to installing ports or as a separate step.\nEquivalent to running C(port selfupdate)."
                     },
                     "update_cache": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nUpdate Macports and the ports tree, either prior to installing ports or as a separate step.\nEquivalent to running C(port selfupdate)."
                     },
                     "update_ports": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nUpdate Macports and the ports tree, either prior to installing ports or as a separate step.\nEquivalent to running C(port selfupdate)."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIndicates the desired state of the port.",
                        "enum": [
                           "present",
                           "absent",
                           "active",
                           "inactive"
                        ]
                     },
                     "upgrade": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nUpgrade all outdated ports, either prior to installing ports or as a separate step.\nEquivalent to running C(port upgrade outdated)."
                     },
                     "variant": {
                        "type": "string",
                        "description": "A port variant specification.\nC(variant) is only supported with state: I(installed)/I(present)."
                     },
                     "variants": {
                        "type": "string",
                        "description": "A port variant specification.\nC(variant) is only supported with state: I(installed)/I(present)."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "port"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "selfupdate",
                                    "update_cache",
                                    "update_ports"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "variant",
                                    "variants"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "layman": {
                  "type": "object",
                  "description": "Uses Layman to manage an additional repositories for the Portage package manager on Gentoo Linux. Please note that Layman must be installed on a managed node prior using this module.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The overlay id to install, synchronize, or uninstall. Use 'ALL' to sync all of the installed overlays (can be used only when C(state=updated))."
                     },
                     "list_url": {
                        "type": "string",
                        "description": "An URL of the alternative overlays list that defines the overlay to install. This list will be fetched and saved under C(${overlay_defs})/${name}.xml), where C(overlay_defs) is readed from the Layman's configuration."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether to install (C(present)), sync (C(updated)), or uninstall (C(absent)) the overlay.",
                        "enum": [
                           "present",
                           "absent",
                           "updated"
                        ]
                     },
                     "validate_certs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nIf C(no), SSL certificates will not be validated. This should only be set to C(no) when no other option exists.  Prior to 1.9.3 the code defaulted to C(no)."
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "installp": {
                  "type": "object",
                  "description": "Manage packages using 'installp' on AIX",
                  "properties": {
                     "accept_license": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Whether to accept the license for the package(s)."
                     },
                     "name": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "One or more packages to install or remove.\nUse C(all) to install all packages available on informed C(repository_path)."
                     },
                     "pkg": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "One or more packages to install or remove.\nUse C(all) to install all packages available on informed C(repository_path)."
                     },
                     "repository_path": {
                        "type": "string",
                        "description": "Path with AIX packages (required to install)."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nWhether the package needs to be present on or absent from the system.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "pkg"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "pkg"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "homebrew_tap": {
                  "type": "object",
                  "description": "Tap external Homebrew repositories.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "The GitHub user/organization repository to tap."
                     },
                     "tap": {
                        "type": "string",
                        "description": "The GitHub user/organization repository to tap."
                     },
                     "url": {
                        "type": "string",
                        "description": "The optional git URL of the repository to tap. The URL is not assumed to be on GitHub, and the protocol doesn't have to be HTTP. Any location and protocol that git can handle is fine.\nI(name) option may not be a list of multiple taps (but a single tap instead) when this option is provided."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nstate of the repository.",
                        "enum": [
                           "present",
                           "absent"
                        ]
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "tap"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "tap"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     }
                  ]
               },
               "homebrew_cask": {
                  "type": "object",
                  "description": "Manages Homebrew casks.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "name of cask to install/remove"
                     },
                     "pkg": {
                        "type": "string",
                        "description": "name of cask to install/remove"
                     },
                     "package": {
                        "type": "string",
                        "description": "name of cask to install/remove"
                     },
                     "cask": {
                        "type": "string",
                        "description": "name of cask to install/remove"
                     },
                     "path": {
                        "type": "string",
                        "description": "Default: /usr/local/bin\n\n':' separated list of paths to search for 'brew' executable."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nstate of the cask",
                        "enum": [
                           "present",
                           "absent",
                           "upgraded"
                        ]
                     },
                     "sudo_password": {
                        "type": "string",
                        "description": "The sudo password to be passed to SUDO_ASKPASS."
                     },
                     "update_homebrew": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nupdate homebrew itself first. Note that C(brew cask update) is a synonym for C(brew update)."
                     },
                     "update-brew": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nupdate homebrew itself first. Note that C(brew cask update) is a synonym for C(brew update)."
                     },
                     "install_options": {
                        "type": "string",
                        "description": "options flags to install a package"
                     },
                     "options": {
                        "type": "string",
                        "description": "options flags to install a package"
                     },
                     "accept_external_apps": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nallow external apps"
                     },
                     "upgrade_all": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nupgrade all casks (mutually exclusive with `upgrade`)"
                     },
                     "upgrade": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nupgrade all casks (mutually exclusive with `upgrade_all`)"
                     },
                     "greedy": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nupgrade casks that auto update; passes --greedy to brew cask outdated when checking if an installed cask has a newer version available"
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "pkg",
                                    "package",
                                    "cask"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "pkg"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "package"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "cask"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "update_homebrew",
                                    "update-brew"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "install_options",
                                    "options"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "homebrew": {
                  "type": "object",
                  "description": "Manages Homebrew packages",
                  "properties": {
                     "name": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "list of names of packages to install/remove"
                     },
                     "pkg": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "list of names of packages to install/remove"
                     },
                     "package": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "list of names of packages to install/remove"
                     },
                     "formula": {
                        "$ref": "#/definitions/ansible_array",
                        "description": "list of names of packages to install/remove"
                     },
                     "path": {
                        "type": "string",
                        "description": "Default: /usr/local/bin\n\nA ':' separated list of paths to search for 'brew' executable. Since a package (I(formula) in homebrew parlance) location is prefixed relative to the actual path of I(brew) command, providing an alternative I(brew) path enables managing different set of packages in an alternative location in the system."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nstate of the package",
                        "enum": [
                           "head",
                           "latest",
                           "present",
                           "absent",
                           "linked",
                           "unlinked"
                        ]
                     },
                     "update_homebrew": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nupdate homebrew itself first"
                     },
                     "update-brew": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nupdate homebrew itself first"
                     },
                     "upgrade_all": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nupgrade all homebrew packages"
                     },
                     "upgrade": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nupgrade all homebrew packages"
                     },
                     "install_options": {
                        "type": "string",
                        "description": "options flags to install a package"
                     },
                     "options": {
                        "type": "string",
                        "description": "options flags to install a package"
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "pkg",
                                    "package",
                                    "formula"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "update_homebrew",
                                    "update-brew"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "upgrade_all",
                                    "upgrade"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "install_options",
                                    "options"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "flatpak_remote": {
                  "type": "object",
                  "description": "Allows users to add or remove flatpak remotes.\nThe flatpak remotes concept is comparable to what is called repositories in other packaging formats.\nCurrently, remote addition is only supported via I(flatpakrepo) file URLs.\nExisting remotes will not be updated.\nSee the M(flatpak) module for managing flatpaks.",
                  "properties": {
                     "executable": {
                        "type": "string",
                        "description": "Default: flatpak\n\nThe path to the C(flatpak) executable to use.\nBy default, this module looks for the C(flatpak) executable on the path."
                     },
                     "flatpakrepo_url": {
                        "type": "string",
                        "description": "The URL to the I(flatpakrepo) file representing the repository remote to add.\nWhen used with I(state=present), the flatpak remote specified under the I(flatpakrepo_url) is added using the specified installation C(method).\nWhen used with I(state=absent), this is not required.\nRequired when I(state=present)."
                     },
                     "method": {
                        "type": "string",
                        "description": "Default: system\n\nThe installation method to use.\nDefines if the I(flatpak) is supposed to be installed globally for the whole C(system) or only for the current C(user).",
                        "enum": [
                           "system",
                           "user"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The desired name for the flatpak remote to be registered under on the managed host.\nWhen used with I(state=present), the remote will be added to the managed host under the specified I(name).\nWhen used with I(state=absent) the remote with that name will be removed."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIndicates the desired package state.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "flatpak": {
                  "type": "object",
                  "description": "Allows users to add or remove flatpaks.\nSee the M(flatpak_remote) module for managing flatpak remotes.",
                  "properties": {
                     "executable": {
                        "type": "string",
                        "description": "Default: flatpak\n\nThe path to the C(flatpak) executable to use.\nBy default, this module looks for the C(flatpak) executable on the path."
                     },
                     "method": {
                        "type": "string",
                        "description": "Default: system\n\nThe installation method to use.\nDefines if the I(flatpak) is supposed to be installed globally for the whole C(system) or only for the current C(user).",
                        "enum": [
                           "system",
                           "user"
                        ]
                     },
                     "name": {
                        "type": "string",
                        "description": "The name of the flatpak to manage.\nWhen used with I(state=present), I(name) can be specified as an C(http(s)) URL to a C(flatpakref) file or the unique reverse DNS name that identifies a flatpak.\nWhen supplying a reverse DNS name, you can use the I(remote) option to specify on what remote to look for the flatpak. An example for a reverse DNS name is C(org.gnome.gedit).\nWhen used with I(state=absent), it is recommended to specify the name in the reverse DNS format.\nWhen supplying an C(http(s)) URL with I(state=absent), the module will try to match the installed flatpak based on the name of the flatpakref to remove it. However, there is no guarantee that the names of the flatpakref file and the reverse DNS name of the installed flatpak do match."
                     },
                     "remote": {
                        "type": "string",
                        "description": "Default: flathub\n\nThe flatpak remote (repository) to install the flatpak from.\nBy default, C(flathub) is assumed, but you do need to add the flathub flatpak_remote before you can use this.\nSee the M(flatpak_remote) module for managing flatpak remotes."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIndicates the desired package state.",
                        "enum": [
                           "absent",
                           "present"
                        ]
                     }
                  },
                  "required": [
                     "name"
                  ]
               },
               "dpkg_selections": {
                  "type": "object",
                  "description": "Change dpkg package selection state via --get-selections and --set-selections.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "Name of the package"
                     },
                     "selection": {
                        "type": "string",
                        "description": "The selection state to set the package to.",
                        "enum": [
                           "install",
                           "hold",
                           "deinstall",
                           "purge"
                        ]
                     }
                  },
                  "required": [
                     "name",
                     "selection"
                  ]
               },
               "dnf": {
                  "type": "object",
                  "description": "Installs, upgrade, removes, and lists packages and groups with the I(dnf) package manager.",
                  "properties": {
                     "name": {
                        "type": "string",
                        "description": "A package name or package specifier with version, like C(name-1.0). When using state=latest, this can be '*' which means run: dnf -y update. You can also pass a url or a local path to a rpm file. To operate on several packages this can accept a comma separated string of packages or a list of packages."
                     },
                     "pkg": {
                        "type": "string",
                        "description": "A package name or package specifier with version, like C(name-1.0). When using state=latest, this can be '*' which means run: dnf -y update. You can also pass a url or a local path to a rpm file. To operate on several packages this can accept a comma separated string of packages or a list of packages."
                     },
                     "list": {
                        "type": "string",
                        "description": "Various (non-idempotent) commands for usage with C(/usr/bin/ansible) and I(not) playbooks. See examples."
                     },
                     "state": {
                        "type": "string",
                        "description": "Whether to install (C(present), C(latest)), or remove (C(absent)) a package.\nDefault is C(None), however in effect the default action is C(present) unless the C(autoremove) option is enabled for this module, then C(absent) is inferred.",
                        "enum": [
                           "absent",
                           "present",
                           "installed",
                           "removed",
                           "latest"
                        ]
                     },
                     "enablerepo": {
                        "type": "string",
                        "description": "I(Repoid) of repositories to enable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a \",\"."
                     },
                     "disablerepo": {
                        "type": "string",
                        "description": "I(Repoid) of repositories to disable for the install/update operation. These repos will not persist beyond the transaction. When specifying multiple repos, separate them with a \",\"."
                     },
                     "conf_file": {
                        "type": "string",
                        "description": "The remote dnf configuration file to use for the transaction."
                     },
                     "disable_gpg_check": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nWhether to disable the GPG checking of signatures of packages being installed. Has an effect only if state is I(present) or I(latest)."
                     },
                     "installroot": {
                        "type": "string",
                        "description": "Default: /\n\nSpecifies an alternative installroot, relative to which all packages will be installed."
                     },
                     "releasever": {
                        "type": "string",
                        "description": "Specifies an alternative release from which all packages will be installed."
                     },
                     "autoremove": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nIf C(yes), removes all \"leaf\" packages from the system that were originally installed as dependencies of user-installed packages but which are no longer required by any such package. Should be used alone or when state is I(absent)"
                     },
                     "exclude": {
                        "type": "string",
                        "description": "Package name(s) to exclude when state=present, or latest. This can be a list or a comma separated string."
                     },
                     "skip_broken": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nSkip packages with broken dependencies(devsolve) and are causing problems."
                     },
                     "update_cache": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nForce dnf to check if cache is out of date and redownload if needed. Has an effect only if state is I(present) or I(latest)."
                     },
                     "expire-cache": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nForce dnf to check if cache is out of date and redownload if needed. Has an effect only if state is I(present) or I(latest)."
                     },
                     "update_only": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nWhen using latest, only update installed packages. Do not install packages.\nHas an effect only if state is I(latest)"
                     },
                     "security": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nIf set to C(yes), and C(state=latest) then only installs updates that have been marked security related."
                     },
                     "bugfix": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nIf set to C(yes), and C(state=latest) then only installs updates that have been marked bugfix related."
                     },
                     "enable_plugin": {
                        "type": "string",
                        "description": "I(Plugin) name to enable for the install/update operation. The enabled plugin will not persist beyond the transaction."
                     },
                     "disable_plugin": {
                        "type": "string",
                        "description": "I(Plugin) name to disable for the install/update operation. The disabled plugins will not persist beyond the transaction."
                     },
                     "disable_excludes": {
                        "type": "string",
                        "description": "Disable the excludes defined in DNF config files.\nIf set to C(all), disables all excludes.\nIf set to C(main), disable excludes defined in [main] in dnf.conf.\nIf set to C(repoid), disable excludes defined for given repo id."
                     },
                     "validate_certs": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nThis only applies if using a https url as the source of the rpm. e.g. for localinstall. If set to C(no), the SSL certificates will not be validated.\nThis should only set to C(no) used on personally controlled sites using self-signed certificates as it avoids verifying the source site."
                     },
                     "allow_downgrade": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nSpecify if the named package and version is allowed to downgrade a maybe already installed higher version of that package. Note that setting allow_downgrade=True can make this module behave in a non-idempotent way. The task could end up with a set of packages that does not match the complete list of specified packages to install (because dependencies between the downgraded package and others can cause changes to the packages which were in the earlier transaction)."
                     },
                     "install_repoquery": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nThis is effectively a no-op in DNF as it is not needed with DNF, but is an accepted parameter for feature parity/compatibility with the I(yum) module."
                     },
                     "download_only": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: no\n\nOnly download the packages, do not install them."
                     },
                     "lock_timeout": {
                        "$ref": "#/definitions/ansible_number",
                        "description": "Default: 30\n\nAmount of time to wait for the dnf lockfile to be freed."
                     },
                     "install_weak_deps": {
                        "$ref": "#/definitions/ansible_truth",
                        "description": "Default: yes\n\nWill also install all packages linked by a weak dependency relation."
                     },
                     "download_dir": {
                        "type": "string",
                        "description": "Specifies an alternate directory to store packages.\nHas an effect only if I(download_only) is specified."
                     }
                  },
                  "allOf": [
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "name",
                                    "pkg"
                                 ],
                                 "type": "object"
                              }
                           },
                           {
                              "oneOf": [
                                 {
                                    "required": [
                                       "name"
                                    ],
                                    "type": "object"
                                 },
                                 {
                                    "required": [
                                       "pkg"
                                    ],
                                    "type": "object"
                                 }
                              ]
                           }
                        ]
                     },
                     {
                        "allOf": [
                           {
                              "not": {
                                 "required": [
                                    "update_cache",
                                    "expire-cache"
                                 ],
                                 "type": "object"
                              }
                           }
                        ]
                     }
                  ]
               },
               "apt_rpm": {
                  "type": "object",
                  "description": "Manages packages with I(apt-rpm). Both low-level (I(rpm)) and high-level (I(apt-get)) package manager binaries required.",
                  "properties": {
                     "pkg": {
                        "type": "string",
                        "description": "name of package to install, upgrade or remove."
                     },
                     "state": {
                        "type": "string",
                        "description": "Default: present\n\nIndicates the desired package state.",
                        "enum": [
                           "absent",
                           "present
